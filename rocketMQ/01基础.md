[TOC]

# 应用场景

![image-20240717005239743](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202407170052983.png)

- **特点**
  - 异步
  - 解耦
  - 削峰

![image-20240717005751328](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202407170057585.png)

![image-20240717010145742](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202407170101873.png)

![image-20240717010948093](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202407170109305.png)

![image-20240717011908042](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202407170119221.png)

![image-20240717012245249](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202407170122407.png)

- 首先，会发送half消息，该消息不会被消费者消费。
- 然后RocketMQ会回复half消息
- 回复之后订单系统开始执行本地事务
- 并且返回本地事务的执行状态给RocketMQ，如果是Commit状态，则事务提交。如果是Rollback状态则事务丢弃掉
- 如果是未确定状态，则会对事务进行状态回查，并检查本地事务的状态。这个过程会重试15次。

![image-20240719014549779](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202407190145954.png)

其实同步刷盘并非是严格意义上的同步，它的刷盘间隔有10ms，所以同步刷盘并不能严格意义上的保证数据不丢失。

![image-20240719015423131](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202407190154324.png)

master可以分为同步主节点和异步主节点：同步master是指数据存到master，master立马给一个回馈。而异步master则是指开辟一个异步线程用于反馈。

并且master节点挂掉以后，slave不会主动切换；而kafka则可以解决这个问题，内部会选举出一个slave作为master。

![image-20240815231247388](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202408152312620.png)

![image-20240815231532314](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202408152315429.png)

将订单系统的数据写入到降级缓存中，比如redis，然后不断地去轮询RocketMQ，这样当RocketMQ重启来以后可以第一时间将数据写入到RocketMQ。

![image-20240815231739526](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202408152317742.png)
