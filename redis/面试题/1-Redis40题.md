## 1. 什么是Redis

Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。

Redis 与其他 key - value 缓存产品有以下三个特点：

- Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。
- Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。
- Redis支持数据的备份，即master-slave模式的数据备份。



Redis 是一种基于内存的数据库，对数据的读写操作都是在内存中完成，因此**读写速度非常快**，常用于**缓存，消息队列、分布式锁等场景**。

Redis 提供了多种数据类型来支持不同的业务场景，比如 String(字符串)、Hash(哈希)、 List (列表)、Set(集合)、Zset(有序集合)、Bitmaps（位图）、HyperLogLog（基数统计）、GEO（地理信息）、Stream（流），并且对数据类型的操作都是**原子性**的，因为执行命令由单线程负责的，不存在并发竞争的问题。

除此之外，Redis 还支持**事务 、持久化、Lua 脚本、多种集群方案（主从复制模式、哨兵模式、切片机群模式）、发布/订阅模式，内存淘汰机制、过期删除机制**等等。



**Redis的优势：**

- **性能极高** – Redis能读的速度是110000次/s,写的速度是81000次/s 。
- **丰富的数据类型** – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。
- **原子** – Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。
- **丰富的特性** – Redis还支持 publish/subscribe, 通知, key 过期等等特性。



**Redis与其他的key-value存储有什么不同？**

Redis 有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis 的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。

Redis 运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样 Redis 可以做很多内部复杂性很强的事情。同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。





## 2. Redis的数据类型

Redis 支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及 zset（sorted set 有序集合）。

我们实际项目中比较常用的是 string，hash 如果你是 Redis 中高级用户，还需要加上下面几种数据结构 HyperLogLog、Geo、Pub/Sub。

如果你说还玩过 Redis Module，像 BloomFilter，RedisSearch，Redis-ML，面试官的眼睛就开始发亮了。





## 3. 使用Redis有哪些好处？

- **性能极高** – Redis能读的速度是110000次/s,写的速度是81000次/s 。
- **丰富的数据类型** – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。
- **原子** – Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。
- **丰富的特性** – Redis还支持 publish/subscribe, 通知, key 过期等等特性。



## 4. Redis相比Memcached的优势和区别？

**Redis和Memcached共同点：**

1、都是基于内存的数据库，一般都用来当做缓存使用

2、都要过期策略

3、两者的性能都非常高



**Redis和Memcached的区别：**

- Memcached所有的值均是简单的字符串String，而Redis作为其替代者，支持更丰富的数据类型，比如：list，set，hash，zset等
- 内存使用效率对比：使用简单的key-value存储的话，Memcached的内存利用率更高，而如果Redis采用hash结构来做key-value存储，由于其组合式的压缩，其内存利用率会高于Memcached。
- 性能对比：由于Redis只使用单核，而Memcached可以使用多核，所以平均每一个核上Redis在存储小数据时比Memcached性能更高。而在100k以上的数据中，Memcached性能要高于Redis，虽然Redis最近也在存储大数据的性能上进行优化，但是比起Memcached，还是稍有逊色。
- Redis支持数据持久化且数据可备份，Memcached无法进行持久化，数据不能备份，只能用于缓存使用，且重启后数据全部丢失
- Memcached通过预分配内存池的方式来管理内存，能高效分配内存空间，并且减少内存碎片的产生。Redis需要临时申请内存空间，并且更容易产生内存碎片。
- Redis原生支持集群模式，Memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据。
- Redis支持发布订阅模型，Lua脚本，事务等功能，而Memcached不支持。



## 5. Redis是单线程单进程的吗？

Redis 是单进程单线程的，Redis 利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销。



## 6. Redis中一个字符串的智能存储最大容量是多少？

512M



## 7. Redis持久化的机制是什么，各自的优缺点？

Redis的持久化就是把内存的数据写到磁盘中，防止服务器宕机出现数据丢失。

redis优良中持久化方式：

- 默认的RDB（Redis DataBase）。按照一定的时间将内存的数据以快照的形式存在磁盘中，产生对应的快照文件dump.rdb。通过redis.conf配置文件中的save参数来定义快照的周期。
- AOF（Append Only File）。将Redis每次执行的命令存到单独的日志文件中（所有的命令行记录以redis命令请求协议的格式完全持久化存储为aof文件），当重启redis时会从持久化的日志中恢复数据。

优缺点：

> RDB

优点：

1、只有一个dump.rdb文件，方便持久化。

2、容灾性好，一个文件可以保存到安全的磁盘。

3、数据大时，恢复数据的速度比AOF快

4、性能最大化，可以fork子进程来完成写的操作，让主进程继续处理命令，所以是IO最大化。使用单独子进程来进行持久化，主进程不会进行任何IO操作，保证了redis的高性能。

5、二进制文件体积小

缺点：

1、数据安全性低，因RDB是间隔一段时间进行持久化，如果持久化之间，服务器宕机或者redis发生故障，会导致数据丢失。所以这种方式更合适数据要求不严谨的时候。

![图片](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202307172147215.png)



> AOF

优点：

1、数据安全，AOF持久化可以通过appendfsync属性，有always，每进行一次命令操作就记录到aof文件中。

2、通过Append模式写文件，即使中途宕机。也可以通过redis-check-aof工具解决数据一致性问题。

缺点：

1、AOF文件比RDB大，且恢复速度比RDB慢

2、数据大时，启动效率比RDB低。



> 总体比较

1、AOF文件比RDB更新频率高，优先使用AOF还原数据

2、AOF比RDB更安全，也更大。

3、RDB性能比AOF快

4、如果两个都配置了，优先加载AOF



## 8. Redis常见性能问题与解决方案

### 内存不足问题

Redis是一个基于内存的数据库，如果内存不足，就会导致redis崩溃。解决方案是增加内存，或者通过开启Redis的虚拟内存功能来解决。虚拟内存可以将一部分数据写入磁盘，但是也会带来一些性能损失。



### 热Key问题

当某些key被频繁访问时，就会导致redis的性能下降。解决方案是使用redis集群，将热key分散到不同的节点上，或者使用缓存淘汰策略，如LRU，LFU等。



### Redis单线程模型问题

Redis采用单线程模型，虽然能够减少并发冲突，但是在高并发的场景下性能会受到影响。解决方案是通过使用Redis集群来实现分布式策略，或者使用多个Redis实例来提高性能。



### Redis的持久化

Redis支持两种持久化方式：RDB和AOF。RDB方式是将Redis的内存快照写入磁盘，AOF方式是将Redis的命令写入磁盘。如果持久化的操作频繁，会导致Redis的性能下降。解决方案就是合理设置持久化策略，选择合适的持久化方式，或者使用Redis的集群方式。



### 网络带宽限制问题

当Redis的网络带宽不足时，会导致Redis性能下降。解决方案是使用更高带宽的网络，或者通过使用Redis集群来实现负载均衡。



### 内存占用过高

可以使用Redis的持久化机制，将数据保存到磁盘上，减少内存占用；或者使用Redis的LRU策略，自动删除最近最少使用的键值对，释放内存空间。



### 频繁的key过期

如果业务场景需要大量使用过期键，可以考虑使用Redis的volatile-lru或volatile-ttl策略，自动删除最近最少使用或TTL最近的键值对，避免占用过多内存。



### 大量的全量同步

如果Redis作为主从架构的主节点，频繁进行全量同步会影响性能，可以通过设置主从节点的复制方式为部分重同步（PSYNC），只传输增量数据，减少全量同步的次数和数据量。



### 大量的短连接请求

如果客户端发起大量的短连接请求，会导致Redis服务器频繁的创建和销毁连接，可以考虑使用连接池技术，复用已经建立的连接，避免频繁的创建和销毁连接。



### 大量的数据写入

如果业务场景需要大量的数据写入操作，可以通过使用Redis的管道技术，将多个写入操作打包成一个请求发送给Redis，减少网络通信的开销和延迟，提高写入性能。



总之，Redis的性能问题有很多，需要根据具体的业务场景和应用需求，选择合适的解决方案，进行优化和调整，以下是一些场景的解决方法：

1. 使用Redis集群：将Redis数据分布在多个节点上，可以提高Redis的性能和可用性，同时可以将数据分散存储，避免单个Redis节点负载过高。
2. 使用Redis主从复制：使用主从复制可以将读操作分布到从节点上，减少主节点的负载，从而提高redis的性能和可用性。
3. 合理配置redis：包括调整redis的内存限制，网络参数，最大连接数等等，可以提高redis的性能和稳定性。
4. 使用redis的持久化机制：使用AOF持久化可以将redis数据写入到磁盘上，避免redis进程退出时数据丢失，提高Redis的可用性。
5. 避免大数据集操作：对于大的数据集，避免一次性读取和写入全部数据，可以分批次进行操作，避免Redis阻塞。
6. 合理选择Redis数据结构：对于不同的数据类型，选择合适的Redis数据结构可以提高Redis的性能，例如使用哈希表存储键值对，使用列表存储日志数据等等。



## 9. Redis过期键的删除策略

Redis是可以对key设置过期时间的，因此需要有相应的机制将已过期的键值对删除，而做这个工作的就是过期键删除策略。

内存中的数据可以通过TTL指令获取其状态：`ttl key`

TTL返回的值有三种情况：正数，-1，-2

- **正数**：代表该数据在内存中还能存活的时间
- **-1**：永久有效的数据
- **-2** ：已经过期的数据 或被删除的数据 或 未定义的数据



### 如何设置过期时间

设置key过期时间的命令一共有4个：

- `expire <key> <n>`：设置 `key`在 `n`秒后过期，比如 `expire key 100`表示设置 `key`在100秒后过期。
- `pexpire <key> <n>`：设置 `key`在 `n`毫秒后过期，比如 `pexpire key 100000`表示设置 `key`在100000毫秒（100秒）后过期。
- `expireat <key> <n>`：设置 `key`在某个时间戳（精确到秒）之后过期，比如 `expireat key 1655654400`表示 `key`在时间戳1655654400后过期（精确到秒）
- `pexpireat <key> <n>`：设置 `key`在某个时间戳（精确到毫秒）之后过期，比如 `pexpireat key 1655654400000`表示 `key`在时间戳1655654400000后过期（精确到毫秒）

当然在设置字符串时，也可以对 `key`设置过期时间，共有3种命令：

- `set <key> <value> ex <n>`：设置键值对的时候，同时指定过期时间（精确到秒）
- `set <key> <value> px <n>`：设置键值对的时候，同时指定过期时间（精确到毫秒）
- `setex <key> <n> <value>`：设置键值对的时候，同时指定过期时间（精确到秒）

如果你想查看某个键的剩余存活时间，可以使用 `ttl <key>`命令

```shell
# 设置键值对的时候，同时指定过期时间位 60 秒
> setex key1 60 value1
OK

# 查看 key1 过期时间还剩多少
> ttl key1
(integer) 56
> ttl key1
(integer) 52
```

如果突然反悔，取消key的过期时间，则可以使用 `persist <key>`命令。

```shell
# 取消 key1 的过期时间
> persist key1
(integer) 1

# 使用完 persist 命令之后，
# 查下 key1 的存活时间结果是 -1，表明 key1 永不过期 
> ttl key1 
(integer) -1
```

### 如何判定key已经过期

每当我们对一个key设置了过期时间时，Redis会把该key带上过期时间存储到一个 **过期字典（expire dict）**中，也就是过期字典保存了数据库中所有key的过期时间。

过期字典存储在redisDB结构中，如下：

```c
typedef struct redisDb {
    dict *dict;    /* 数据库键空间，存放着所有的键值对 */
    dict *expires; /* 键的过期时间 */
    ....
} redisDb;
```

过期字典数据结构如下：

- 过期字典的key是一个指针，指向某个键对象；
- 过期字典的value是一个long long类型的整数，这个整数保存了key的过期时间

![img](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202307202321508.png)

字典实际上是哈希表，哈希表最大的好处就是让我们可以利用 `O(1)`的时间复杂度来快速查找。当**我们查阅到一个key时，Redis首先检查该key是否存在于过期字典中**：

- 如果不在，则正常读取键值。
- 如果存在，则会获取该key的过期时间，然后与当前系统时间进行对比，如果比系统时间大，那就没有过期，否则判定该key已过期。

过期键判断流程如下图所示：

![img](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202307202331651.png)



### 过期删除策略有哪些

在说Redis的过期删除策略之前，先跟大家介绍下常见的三种过期删除策略：

- 定时删除
- 惰性删除
- 定期删除



> **定时删除策略是怎么样的？**

定时删除策略的做法是，在设置key的过期事件时，同时创建一个定时事件，当时间到达时，由事件处理器自动执行key的删除操作。

定时删除策略的优点：

- 可以保证过期key会被尽快删除，也就是内存可以被尽快地释放。因此**定时删除对内存是最友好的**。

定时删除策略的缺点：

- 在过期key比较多的情况下，删除过期key可能会占用相当一部分cpu时间，在内存不紧张但是CPU时间紧张的情况下，将CPU时间用于删除和当前任务无关的过期键上，无疑会对服务器的响应时间和吞吐量造成影响。所以定时删除策略对CPU不友好。



> **惰性删除是怎么样的？**

惰性删除的策略是，不主动删除过期建，每次从数据库访问key时，都检测key是否已经过期，如果过期则删除该key。

惰性删除策略的优点：

- 因为每次访问时，才会检查key是否过期，所以此策略只会使用很少的系统资源，因此，惰性删除策略对CPU时间最友好

惰性删除策略的缺点：

- 如果一个key已经过期，而这个key有仍然保留在数据库中，那么只要这个key一直没有被访问，它所占用的内存就不会被释放，造成了一定的内存空间的浪费。所以，惰性删除对内存不友好



> **定期删除策略是怎么样的？**

定期删除的策略是，每过一段时间 **随机**中数据库中取出一定数量的key进行检查，并删除其中的过期key。

定期删除策略的优点：

- 通过限制删除操作的时长和频率，来减少删除操作对cpu的影响，同时也能删除一部分过期的数据，减少了过期键对空间的无效占用

定期删除策略的缺点：

- 内存清理方面没有定时删除效果好，同时没有惰性删除使用的系统资源少。
- 难以确定删除操作执行的时长和频率。如果执行的太频繁，定期删除策略和定时删除策略一样，对CPU不友好；如果执行的太少，那又和惰性删除一样了，过期key占用的内存无法得到及时地释放。



### Redis过期删除策略是什么

前面介绍了三种过期删除策略，每一种都有优缺点，仅使用某一个策略都不能满足实际需求。

所以，Redis选择 **惰性删除+定期删除**这两种策略配合使用，以求在合理使用CPU时间和避免内存浪费之间取得平衡。

> **Redis是怎么实现惰性删除的？**

Redis的惰性删除策略由db.c文件中的 `expireIfNeeded`函数实现，代码如下：

```c
int expireIfNeeded(redisDb *db, robj *key) {
    // 判断 key 是否过期
    if (!keyIsExpired(db,key)) return 0;
    ....
    /* 删除过期键 */
    ....
    // 如果 server.lazyfree_lazy_expire 为 1 表示异步删除，反之同步删除；
    return server.lazyfree_lazy_expire ? dbAsyncDelete(db,key) :
                                         dbSyncDelete(db,key);
}
```

Redis在访问和修改key之前，都会调用 `expireIfNeeded`函数对其进行检查，检查key是否过期：

- 如果过期，则删除该key，至于选择异步删除还是同步删除，根据 `lazyfree_lazy_expire`参数配置决定（Redis4.0版本开始提高该参数），然后返回null给客户端；
- 如果没有过期，则不做任何操作，然后返回正常的键值对给客户端；

惰性删除的流程图：

![img](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202307210003608.png)



> **Redis是怎么实现定期删除的？**

定期删除策略的做法是：每隔一段时间，从数据库中随机取出一定量的key进行检查，并删除其中的已过期的key。

1、这个间隔检查的时间是多长呢？

在Redis中，默认每秒进行10次过期检查一次数据库，此配置可通过Redis的配置文件redis.conf进行配置，配置键为hz，它的默认值是hz 10。

特别强调一下，每次检查数据库并不是遍历过期字典中的所有key，而是从数据库中随机抽取一定数量的key进行过期检查。

2、随机抽取的数量是多少？

我查了下源码，定期删除的实现在 `expire.c`文件下的 `activateExpireCycle`函数中，其中随机抽查的数量由 `ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP`定义的，它是写死在代码中的，数量是20。

也就是说，数据库每轮抽查时，会随机选择20个key判断是否已经过期。

接下来，详细说说Redis定期删除的流程：

1. 从过期字典中随机抽取20个key；
2. 检查这20个key是否过期，并删除已过期的key；
3. 如果本轮检查的已过期key的数量，超过5个（20/4），也就是已过期key的数量占比随机抽取key的数量大于25%，则继续重复步骤1；如果已过期key的数量小于25%，则停止继续删除过期key，然后等待下一轮再检查。

可以看到定期删除是一个循环的流程。

那么Redis为了保证定期删除不会出现循环过度，导致线程卡死现象，为此增加了定期删除循环流程的时间上限，默认不会超过25ms。

针对定期检查的流程，我写了个伪代码：

```c
do {
    //已过期的数量
    expired = 0；
    //随机抽取的数量
    num = 20;
    while (num--) {
        //1. 从过期字典中随机抽取 1 个 key
        //2. 判断该 key 是否过期，如果已过期则进行删除，同时对 expired++
    }
    
    // 超过时间限制则退出
    if (timelimit_exit) return;

  /* 如果本轮检查的已过期 key 的数量，超过 25%，则继续随机抽查，否则退出本轮检查 */
} while (expired > 20/4); 
```

定期删除的流程图：

![img](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202307210017551.png)





## 10. 内存淘汰策略

前面说的过期删除策略是删除已过期的key，而当Redis的运行内存已经超过Redis设置的最大内存之后，则会使用内存淘汰策略删除符合条件的key，以此来保障Redis高效的运行。



### 如何设置Redis最大运行内存？

在配置文件redis.conf中，可以通过参数 `maxmemory <bytes>`来设定最大运行内存，只有在Redis的运行内存到达了我们设置的最大运行内存，才会触发内存淘汰策略。不同位数的操作系统，`maxmemory`的默认值是不同的：

- 在64位操作系统中，`maxmemory`的默认值是0，表示没有内存大小限制，那么不管用户存放多少数据到Redis中，Redis也不会对可用内存进行检查，直到Redis实例因内存不足而崩溃也无作为。
- 在32位操作系统中，`maxmemory`的默认值是3G，因为32位的机器最大支持4GB的内存，而系统本身就需要一定的内存资源来支持运行，所以32位操作系统限制最大3GB的可用内存是非常合理的，这样可以避免因为内存不足而导致Redis实例崩溃。



### Redis内存淘汰策略有哪些？

Redis内存淘汰策略大体分为八种，这八种策略大体分为 **不进行数据淘汰**和 **进行数据淘汰**两类策略。

1、不进行数据淘汰的策略

`noeviction`（Redis3.0之后，默认的内存淘汰策略）：它表示当运行内存超过最大设置内存时，不淘汰任何数据，这是如果有新的数据写入，则会触发OOM，但是如果没有数据写入的话，只是单纯的查询或者删除操作的话，还是可以正常工作的。

2、进行数据淘汰的策略

针对 **进行数据淘汰**这一类策略，又可以细分为 **在设置了过期时间的数据中进行淘汰**和 **在所有数据范围内进行淘汰**这两类策略。

在设置了过期时间的数据中进行淘汰：

- volatile-random：随机淘汰设置了过期时间的任意键值；
- volatile-ttl（time to live）：优先淘汰更早过期的键值。
- volatile-lru（Redis3.0之前，默认的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最久未使用的键值；
- volatile-lfu（Redis 4.0后新增的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最少使用的键值；

在所有数据范围内进行淘汰：

- allkeys-random：随机淘汰任意键值；
- allkeys-lru：淘汰整个键值中最近最久未使用的键值；
- allkeys-lfu（Redis 4.0后新增的内存淘汰策略）：淘汰整个键值中最近最少使用的键值。



> **如何查看当前Redis使用的内存淘汰策略**

可以使用`config get maxmemory-policy`命令，来查看当前Redis的内存淘汰策略，命令如下：

```shell
127.0.0.1:6379> config get maxmemory-policy
1) "maxmemory-policy"
2) "noeviction"
```

可以看出，当前Redis使用的是 `noeviction`类型的内存淘汰策略，它是Redis 3.0之后默认使用的内存淘汰策略，表示当运行内存超过最大设置内存时，不淘汰任何数据，但新增操作会报错。



> **如何修改Redis的内存淘汰策略**

设置内存淘汰策略有两种方法：

- 方式一：通过 `config set maxmemory-policy <策略>`命令设置。它的优点是设置之后立即生效，不需要重启Redis服务，缺点是重启Redis之后，设置就会失效。
- 方式二：通过修改Redis配置文件，修改 `maxmemory-policy <策略>`，它的优点是重启Redis服务后配置不会失效，缺点是必须重启Redis服务才会生效。



### LRU算法和LFU算法的区别

LFU内存淘汰算法是Redis 4.0以后新增的内存淘汰策略，之所以要新增这个算法，是为了解决LRU算法的问题。

> **什么是LRU算法？**

LRU全称是 Least Recently Used翻译为最近最少使用，会选择淘汰最近最少使用的数据。

传统的LRU算法的实现是基于 **链表 ** 结构，链表中的元素按照操作顺序从前往后排列，**最新操作的键会被移动到表头**，当需要内存淘汰时，只需要删除链表尾部的元素即可，因为链表尾部的元素就代表最久未被使用的元素。

Redis并没有使用这样的方式实现LRU算法，因为传统的LRU算法存在两个问题：

- 需要用链表管理所有的缓存数据，这会带来额外的空间开销。
- 当有数据被访问时，需要在链表上把该数据移动到头端，如果有大量的数据被访问，就会带来很多链表移动操作，会很耗时，进而会降低Redis缓存性能。



> **Redis是如何实现LRU算法的？**

Redis实现的是一种近似LRU算法，目的是为了更好的节约内存，**它的实现方式是在Redis的对象结构体中添加一个额外的字段，用于记录此数据的最后一次访问时间。**

当Redis进行内存淘汰时，会使用随机采样的方式来淘汰数据，它是随机取5个值（此值可配置），然后淘汰最久没有使用的那个。

Redis实现的LRU算法的优点：

- 不用为所有的数据维护一个大链表，节省了空间占用
- 不用在每次数据访问时都移动链表项，提升了缓存的性能；

但是LRU有一个问题，**无法解决缓存污染的问题**，比如应用一次读取了大量的数据，而这些数据只会被读取这一次，那么这些数据会留存在缓存中很长一段时间，造成缓存污染。

因此，在Redis 4.0以后引入LFU算法来解决这个问题。



> **什么是LFU算法？**

LFU算法全称是Least Frequently Used翻译为最近不常用，LFU算法是根据数据访问次数来淘汰数据的，它的核心思想是“如果数据过去被访问多次，那么将来被访问的频率也更高”。

所以，LFU算法会记录每个数据的访问次数。当一个数据被再次访问时，就会增加该数据的访问次数。这样就解决了偶尔被访问一次之后，数据留存在缓存中很长一段时间的问题，相比于LRU算法，解决了缓存污染的问题。



> **Redis是如何实现LFU算法的？**

LFU算法相比较于LRU算法的实现，多记录了 **数据访问频次**的信息。Redis对象的结构如下：

```c
typedef struct redisObject {
    ...
      
    // 24 bits，用于记录对象的访问信息
    unsigned lru:24;  
    ...
} robj;
```

Redis对象中的lru字段，在LRU算法下和LFU算法下使用方式并不相同。

**在LRU算法中**，Redis对象头的24bits的lru字段是用来记录key的访问时间戳，因此在LRU模式下，Redis可以根据对象头中的lru字段记录的值，来比较最后一次key的访问时间，从而淘汰最久未被使用的key。

**在LFU算法中**，Redis对象头的24bits的lru字段被分成两段来存储，高16bits存储ldt（Last Decrement Time），低8bits存储logc（Logistics Counter）。

![img](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202307220009514.png)

- ldt是用来记录key的访问时间戳
- logc是用来记录key的访问频次，它的值越小表示使用频率越低，越容易淘汰，每个新加入的key的logc初始值为5

注意，logc并不是单纯的访问次数，而是访问频次（访问频率），因为logc会随时间的推移而衰减的。

在每次key被访问的时候，会先对logc做一个衰减操作，衰减的值跟前后访问时间的差距有关系，如果上一次访问的时间与这一次访问的时间差距很大，那么衰减的值就越大，这样实现的LFU算法是根据**访问频率**来淘汰数据的，而不只是访问次数。访问频率需要考虑key的访问是多长时间段内发生的。key的先前访问距离当前访问越长，那么这个key的访问频率相应地也会降低，这样被淘汰的概率也会越大。

对logc做完衰减操作后，就开始对logc进行增加操作，增加操作并不是简单的 +1，而是根据概率增加，如果logc越大的key，他的logc就越难再增加。

所以，Redis在访问key时，对于logc是这样变化的：

1、先按照上次访问距离当前的时长，来对logc进行衰减

2、然后，再按照一定概率增加logc的值

redis.conf提供了两个配置项，用于调整LFU算法从而控制logc的增长和衰减：

- `lfu-decay-time`用于调整logc的衰减速度，它是一个以分钟为单位的数值，默认值为1，`lfu-decay-time`值越大，衰减越慢
- `lfu-log-factor`用于调整logc的增长速度，`lfu-log-factor`值越大，logc增长越慢



### 总结

Redis使用的过期删除策略是 惰性删除+定期删除，删除的对象是已经过期的key。

![img](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202307220846601.png)

内存淘汰策略是解决内存过大的问题，当Redis的运行内存超过了最大运行内存时，就会触发内存淘汰策略，Redis 4.0以后共实现了8种：

![img](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202307220849078.png)



## 11. 缓存污染

上一讲介绍了缓存满了，通过内存淘汰机制来淘汰掉数据。如果有的数据一直滞留在缓存中，但又没有应用时间，时间长了，就可能会占据大部分的缓存空间。

### 缓存污染

- 在一些场景下，有些数据被访问次数非常少，甚至只会被访问一次。当这些数据服务完访问请求后，如果继续留存在缓存中，只会白白占用缓存空间。
- 缓存污染严重的话，大量不再访问的数据滞留在缓存中，数据会占满整个空间，我们再往缓存中写入数据的时候，就需要淘汰已有缓存，引入额外操作时间开销，进而影响应用的性能。



### 如何解决

解决缓存污染的问题实际上就是要把不会被再次访问的数据筛选出来并删除掉，为后续写入的数据腾出空间。

缓存淘汰策略就是找出那些可以删除数据的规则，下面介绍8种缓存淘汰策略：



### 缓存淘汰策略

Redis共支持八种淘汰策略，分别是noeviction、volatile-random、volatile-ttl、volatile-lru、volatile-lfu、allkeys-lru、allkeys-random 和 allkeys-lfu 策略。看了一堆单词，很迷惑，没关系这里只是先总体概述一下。下面分别展开详细介绍。其中allkeys开头的淘汰策略的是在所有数据中进行淘汰，共有三种。volatile开头的淘汰策略是在设置了过期时间的数据中进行淘汰，共有四种。



**1、noeviction**

该策略是Redis3.0以后默认使用的而内存淘汰策略，它表示当运行内存找过最大内存设置时，不淘汰任何数据，这是如果有新的数据写入，则会触发OOM（Out Of Memory）。但是如果没有数据写入的话，还是可以正常工作。



**2、volatile-random**

这个算比较简单，在设置了过期时间的键值对中，进行随机删除。因为是随机删除，无法把不再访问的数据筛选出来，所以可能依然会存在缓存污染的现象， 无法解决缓存污染的问题。



**3、volatile-ttl**

这种算法判断淘汰数据时，比随机删除多进行一步过期时间的排序。redis在筛选需删除的数据时，越早过期的数据优先被删除。



**4、volatile-lru**

会使用 LRU 算法筛选设置了过期时间的键值对。

> LRU算法：LRU 算法的全称是 Least Recently Used。按照最近最少使用的原则来筛选数据。

Redis优化的LRU算法实现：

Redis会记录每个数据的最近一次被访问的时间戳。在Redis决定淘汰数据时，第一次会随机选出N个数据，把他们作为一个候选集合。接下来，Redis会比较这N个数据的lru字段，把lru字段值最小的数据从缓存中淘汰出去。通过随机读取待删除集合，可以让redis不用维护一个巨大的链表，也不用操作链表，进而提升性能。

Redis选出的N个数据，通过配置参数maxmemory-samples进行配置，个数N越大，则候选集合越大，选择到的最久未被使用的就更准确，N越小，选择到的最久未被使用的数据的概率也会随之减小。



**5、volatile-lfu**

会使用LFU算法选择设置了过期时间的键值对。

> **LFU算法：LFU缓存策略在LRU策略的基础上，为每个数据增加了一个计数器，来统计这个数据的访问次数。当使用LFU策略筛选淘汰数据时，首先会根据数据的访问次数进行筛选，把访问次数最低的数据淘汰出缓存。如果两个数据的访问次数相同，LFU策略在比较这两个数据的访问时效性，把距离上一次访问时间更久的数据淘汰出缓存。**

Redis的LFU算法实现:

当 LFU 策略筛选数据时，Redis 会在候选集合中，根据数据 lru 字段的后 8bit 选择访问次数最少的数据进行淘汰。当访问次数相同时，再根据 lru 字段的前 16bit 值大小，选择访问时间最久远的数据进行淘汰。

Redis 只使用了 8bit 记录数据的访问次数，而 8bit 记录的最大值是 255，这样在访问快速的情况下，如果每次被访问就将访问次数加一，很快某条数据就达到最大值255，可能很多数据都是255，那么退化成LRU算法了。所以Redis为了解决这个问题，实现了一个更优的计数规则，并可以通过配置项，来控制计数器增加的速度。

`lfu-log-factor` ，用计数器当前的值乘以配置项 `lfu_log_factor` 再加 1，再取其倒数，得到一个 p 值；然后，把这个 p 值和一个取值范围在（0，1）间的随机数 r 值比大小，只有 p 值大于 r 值时，计数器才加 1。

`lfu-decay-time`， 控制访问次数衰减。LFU 策略会计算当前时间和数据最近一次访问时间的差值，并把这个差值换算成以分钟为单位。然后，LFU 策略再把这个差值除以 `lfu_decay_time` 值，所得的结果就是数据 counter 要衰减的值。

`lfu-log-factor`设置越大，递增概率越低，`lfu-decay-time`设置越大，衰减速度会越慢。

我们在应用 LFU 策略时，一般可以将 lfu_log_factor 取值为 10。
如果业务应用中有短时高频访问的数据的话，建议把 lfu_decay_time 值设置为 1。可以快速衰减访问次数。

volatile-lfu 策略是 Redis 4.0 后新增。



**6、allkeys-lru**

使用 LRU 算法在所有数据中进行筛选。具体LFU算法跟上述 volatile-lru 中介绍的一致，只是筛选的数据范围是全部缓存，这里就不在重复。



**7、allkeys-random**

从所有键值对中随机选择并删除数据。volatile-random 跟 allkeys-random算法一样，随机删除就无法解决缓存污染问题。



**8、allkeys-lfu**

使用 LFU 算法在所有数据中进行筛选。具体LFU算法跟上述 volatile-lfu 中介绍的一致，只是筛选的数据范围是全部缓存，这里就不在重复。

allkeys-lfu 策略是 Redis 4.0 后新增。



**总结**

Redis 4.0 之前一共实现了 6 种内存淘汰策略分别是 noeviction、volatile-random、volatile-ttl、volatile-lru、allkeys-lru、allkeys-random，在 4.0 之后，又增加了 2 种策略分别是 allkeys-lfu，volatile-lfu 。建议优先使用 allkeys-lru 策略。使用allkeys开头的策略，在所有数据中进行选择，防止客户端因不规范等原因，随意设置的缓存数据，没配置超时时间。还可以利用 LRU 这一经典缓存算法的优势，把最近最常访问的数据留在缓存中，提升应用的访问性能。



以下[缓存淘汰策略](https://baike.baidu.com/item/缓存污染/22455761?fr=aladdin)摘自博客园

要解决缓存污染的关键点是能识别出只访问一次或者访问次数很少的数据。
从能否解决缓存污染这一维度来分析Redis的8种缓存淘汰策略：
1、noeviction策略：不会淘汰数据，解决不了。
2、volatile-ttl策略：给数据设置合理的过期时间。当缓存写满时，会淘汰剩余存活时间最短的数据，避免滞留在缓存中，造成污染。
3、volatile-random策略：随机选择数据，无法把不再访问的数据筛选出来，会造成缓存污染。
4、volatile-lru策略：LRU策略只考虑数据的访问时效，对只访问一次的数据，不能很快筛选出来。
5、volatile-lfu策略：LFU策略在LRU策略基础上进行了优化，筛选数据时优先筛选并淘汰访问次数少的数据。
6、allkeys-random策略：随机选择数据，无法把不再访问的数据筛选出来，会造成缓存污染。
7、allkeys-lru策略：LRU策略只考虑数据的访问时效，对只访问一次的数据，不能很快筛选出来。
8、allkeys-lfu策略：LFU策略在LRU策略基础上进行了优化，筛选数据时优先筛选并淘汰访问次数少的数据。

归纳如下表：

|    缓存淘汰策略     | 解决缓存污染 |
| :-----------------: | :----------: |
|   noeviction策略    |     不能     |
|  volatile-ttl策略   |      能      |
| volatile-random策略 |     不能     |
|  volatile-lru策略   |     不能     |
|  volatile-lfu策略   |      能      |
| allkeys-random策略  |     不能     |
|   allkeys-lru策略   |     不能     |
|   allkeys-lfu策略   |      能      |





## 12. 为什么Redis需要把所有数据放到内存中

Redis 为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以 Redis 具有快速和数据持久化的特征。如果不将数据放在内存中，磁盘 I/O 速度将严重影响 Redis 的性能。





## 13. 为什么用Redis作为MySQL的缓存

主要是因为Redis具有高性能和高并发两种特性。

1、Redis具备高性能

假如用户第一次访问 MySQL 中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据缓存在 Redis 中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了，操作 Redis 缓存就是直接操作内存，所以速度相当快。

![img](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308022358917.png)

如果 MySQL 中的对应数据改变之后，同步改变 Redis 缓存中相应的数据即可，不过这里会有 Redis 和 MySQL 双写一致性的问题，后面我们会提到。



2、Redis 具备高并发

单台设备的 Redis 的 QPS（Query Per Second，每秒钟处理完请求的次数） 是 MySQL 的 10 倍，Redis 单机的 QPS 能轻松破 10w，而 MySQL 单机的 QPS 很难破 1w。

所以，直接访问 Redis 能够承受的请求是远远大于直接访问 MySQL 的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。







































