# Redis虚拟内存

## 一、简介

和大多数NoSql数据库一样，redis同样遵循key-value数据存储模型。在有些情况下，redis会将key-value保存在内存中以提高数据查询和数据修改的效率，然而这样的做法并非总是很好的选择，鉴于此，我们可以将之进一步优化，即尽量在内存中只保留key的数据，这样可以保证数据检索的效率，而value数据在很少使用的时候则被持久化到磁盘中。

在实际的应用中，大约只有10%的key属于比较常用的键，这样的redis就可以通过虚存将其余不常用的key和value换出到磁盘中，而一旦被换出的key或value需要被读取时，redis将其再次读回到主内存中。



## 二、应用场景

对于大多数的数据库而言，最理想的方式就是将所有的数据都加载到内存中，而之后的查询操作则可以完全基于内存数据完成。然而在现实中这样的场景却并不普遍，更多的情况则是只有部分数据可以被加载到内存中。

在redis中，有一个非常重要的概念，即keys一般不会被交换，所以如果你的数据库中有大量的keys，其中每个key仅仅关联很小的value，那么这种场景就不是非常适合是用虚拟内存，如果恰恰相反，数据库表中只是包含少量的keys，而每一个key所关联的value非常大，那么这种场景对于使用虚拟内存就再合适不过了。

在实际的应用中，为了能让虚存更为充分的发挥作用以帮助我们提高系统的运行效率，我们可以将带有很多较小值的keys合并为带有少量较大值的keys，其中最主要的方法就是将原来key-value模式改为基于Hash的模式，这样可以让很多原来的keys成为Hash中的属性。



## 三、配置

（1）在配置文件中添加以下配置项，以使当前Redis服务器在启动时打开虚拟内存功能。

```javascript
 vm-enabled yes
```

（2） 将所有大于vm-max-memory的数据存入虚拟内存中，无论vm-max-memory设置多小，所有的索引数据都是内存存储的（redis的索引数据就是keys），也就是说，当vm-max-memory设置为0的时候，其实是所有的value都存在于磁盘，默认值为0

```javascript
vm-max-memory (bytes)
```

如果内存中的数据大于该值，则有部分对象被持久化到磁盘中，其中被持久化对象所占用的内存将被释放，直到已用内存小于该值时才停止持久化。

Redis的交换规则是尽量考虑"最老"的数据，即最长时间没有使用的数据将被持久化。如果两个对象的age相同，那么Value较大的数据将先被持久化。需要注意的是，==Redis不会将Keys持久化到磁盘==，因此如果仅仅keys的数据就已经达到了虚拟内存设置的大小，那么这种数据模型将不适合使用虚拟内存机制，或者是将该值设置的更大，以容纳整个Keys的数据。在实际的应用，如果考虑使用Redis虚拟内存，我们应尽可能的分配更多的虚拟内存交给Redis使用，以避免频繁的将数据持久化到磁盘上。

（3）在配置文件中设定页的数量及每一页所占用的字节数。为了将内存中的数据传送到磁盘上，我们需要使用交换文件。这些文件与数据持久性无关，Redis会在退出前会将它们全部删除。由于对交换文件的访问方式大多为随机访问，因此建议将交换[文件存储](https://cloud.tencent.com/product/cfs?from=20065&from_column=20065)在固态磁盘上，这样可以大大提高系统的运行效率。

```javascript
vm-pages 134217728
vm-page-size 32    
```

在上面的配置中，Redis将需要持久化的文件划分为vm-pages个页，其中每个页所占用的字节为vm-page-size，那么Redis最终可用的交换文件大小为：vm-pages *  vm-page-size。由于一个value可以存放在一个或多个页上，但是一个页不能持有多个value，鉴于此，我们在设置vm-page-size时需要充分考虑Redis的该特征。

（4）在Redis的配置文件中有一个非常重要的配置参数，即：

```javascript
 vm-max-threads 4
```

该参数表示Redis在对交换文件执行IO操作时所应用的最大线程数量。通常而言，我们推荐该值等于主机的CPU cores。如果将该值设置为0，那么Redis在与交换文件进行IO交互时，将以同步的方式执行此操作。



## 四、Redis同步数据方式

对于Redis而言，如果操作交换文件是以同步的方式进行，那么当某一客户端正在访问交换文件中的数据时，其它客户端如果再试图访问交换文件中的数据，该客户端的请求就将被挂起，直到之前的操作结束为止。特别是在相对较慢或较忙的磁盘上读取较大的数据值时，这种阻塞所带来的影响就更为突兀了。

然而同步操作也并非一无是处，事实上，从全局执行效率视角来看，同步方式要好于异步方式，毕竟同步方式节省了线程切换、线程间同步，以及线程拉起等操作产生的额外开销。特别是当大部分频繁使用的数据都可以直接从主内存中读取时，同步方式的表现将更为优异。

至于最终选用哪种配置方式，最好的方式是不断的实验和调优。



## 五、相关说明

首先说明下redis的虚拟内存与os的虚拟内存不是一码事，但是思路和目的都是相同的。就是暂时把不经常访问的数据从内存交换到磁盘中，从而腾出宝贵的内存空间用于其他需要访问的数据。尤其是对于redis这样的内存数据库，内存总是不够用的。==**除了可以将数据分割到多个redis server外。另外的能够提高数据库容量的办法就是使用vm把那些不经常访问的数据交换的磁盘上。**==如果我们的存储的数据总是有少部分数据被经常访问，大部分数据很少被访问，对于网站来说确实总是只有少量用户经常活跃。当少量数据被经常访问时，使用vm不但能提高单台redis server数据库的容量，而且也不会对性能造成太多影响。

redis没有使用os提供的虚拟内存机制而是自己在用户态实现了自己的虚拟内存机制，作者在自己的blog专门解释了其中原因。http://antirez.com/post/redis-virtual-memory-story.html
主要的理由有两点：

> 1.os 的虚拟内存是已4k页面为最小单位进行交换的。而redis的大多数对象都远小于4k，所以一个os页面上可能有多个redis对象。另外redis的集 合对象类型如list,set可能存在与多个os页面上。最终可能造成只有10%key被经常访问，但是所有os页面都会被os认为是活跃的，这样只有内存真正耗尽时os才会交换页面。
>
> 2.相比于os的交换方式。redis可以将被交换到磁盘的对象进行压缩,保存到磁盘的对象可以去除指针和对象元数据信息。一般压缩后的对象会比内存中的对象小10倍。这样redis的 vm会比os vm能少做很多io操作。

下面是vm相关配置

```javascript
vm-enabled yes             #开启vm功能
vm-swap-file /tmp/redis.swap         #交换出来的value保存的文件路径/tmp/redis.swap
vm-max-memory 1000000          #redis使用的最大内存上限，超过上限后redis开始交换value到磁盘文件中。
vm-page-size 32          #每个页面的大小32个字节
vm-pages 134217728         #最多使用在文件中使用多少页面,交换文件的大小 = vm-page-size * vm-pages
vm-max-threads 4          #用于执行value对象换入换出的工作线程数量。0表示不使用工作线程（后面介绍)
```

redis的vm在设计上为了保证key的查找速度，只会将value交换到swap文件中。

所以如果是内存问题是由于太多 **value很小的key**造成 的，那么vm并不能解决。

和os一样redis也是按页面来交换对象的。redis规定同一个页面只能保存一个对象。但是一个对象可以保存在多个页面中。 

在redis使用的内存没超过vm-max-memory之前是不会交换任何value的。当超过最大内存限制后，redis会选择较老的对象。如果两个对象一样老会优先交换比较大的对象，精确的公式swappability = age*log(size_in_memory)。 

对于vm-page-size的设置应该根据自己的应用将页面的大小设置为可以容纳大多数对象的大小。太大了会浪费磁盘空间，太小了会造成交换文件出现碎片。对于交换文件中的每个页面，redis会在内存中对应一个1bit值来记录页面的空闲状态。所以像上面配置中页面数量(vm-pages 134217728 )会占用16M内存用来记录页面空闲状态。

vm-max-threads表示用做交换任务的线程数量。如果大于0推荐设为服务器的`cpu core`的数量。如果是0则交换过程在主线程进行。



> 参数配置讨论完后，再来简单介绍下vm是如何工作的：

**当vm-max-threads设为0时(Blocking VM)**

==换出==

主线程定期检查发现内存超出最大上限后，会直接以阻塞的方式，将选中的对象保存到swap文件中，并释放对象占用的内存,此过程会一直重复直到下面条件满足：

- 1. 内存使用降到最大限制以下
- 2. swap文件满了
- 3. 几乎全部的对象都被交换到磁盘了

==换入==

当有client请求value被换出的key时。主线程会以阻塞的方式从文件中加载对应的value对象，加载时会阻塞client，然后处理client的请求。



**当vm-max-threads大于0(Threaded VM)**

==换出==

当主线程检测到使用内存超过最大上限，会将选中的要交换的对象信息放到一个队列中交由工作线程后台处理，主线程会继续处理client请求。

==换入==

如果有client请求的key被换出了，主线程先阻塞发出命令的client，然后将加载对象的信息放到一个队列中，让工作线程去加载。加载完毕后工作线程通知主线程。主线程再执行client的命令。这种方式只阻塞请求 value被换出的key的client。

总的来说`blocking vm`的方式总的性能会好一些，**因为不需要线程同步，创建线程和恢复被阻塞的client等开销。**但是也相应的牺牲了响应性。`threaded vm`的方式主线程不会阻塞在磁盘`io`上，所以响应性更好。如果我们的应用不太经常发生换入换出，而且也不太在意有点延迟的话则推荐使用`blocking vm`的方式。
