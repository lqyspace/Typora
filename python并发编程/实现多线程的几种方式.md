# python实现多线程的几种方式

## 1、threading.Tread 模块
> 继承实现

```python
import threading
import time as tm

"""
继承实现
"""

class TestThread(threading.Thread):
    def __init__(self,name):
        super(TestThread,self).__init__()
        self.name =name

    def run(self):
        print("线程{} 开始".format(self.name))
        tm.sleep(5)
        print("线程{} 结束".format(self.name))

def main():
    threads = []
    thread_name = ['1','2','3']
    for name in thread_name:
        t = TestThread(name)
        threads.append(t)
    for thread in threads:
        thread.start()  # 线程启动
    for thread in threads:
        thread.join()  # 阻塞主线程


if __name__=="__main__":
  main()
  
  
---------------输出-----------------
线程1开始
线程2开始
线程3开始



（5秒后）

线程1开始
线程2开始
线程3开始
线程3结束
线程2结束
线程1结束
```

> 函数实现

```python
import threading
import time as tm

"""
函数实现
"""
def main(name):
    print("线程{}开始".format(name))
    tm.sleep(5)
    print("线程{}结束".format(name))


if __name__ == "__main__":
    
    # 函数实现
    threads = []
    thread_name = ['1','2','3']
    for name in thread_name:
        t = threading.Thread(target=main,args=(name,))
        t.start()
        threads.append(t)
    for thread in threads:
        thread.join()
    

---------------输出-----------------
线程1开始
线程2开始
线程3开始



（5秒后）

线程1开始
线程2开始
线程3开始
线程3结束
线程2结束
线程1结束
```
    注意：join的作用：
      阻塞主线程，等待子线程都结束之后在执行主线程
## 2、实例

> 线程池

```python
import threading
import time

def job():
    print("这是一个需要执行的任务。。。。。")
    print("当前线程的个数:", threading.active_count() )
    time.sleep(1)
    print("当前线程的信息:", threading.current_thread())



if __name__ == '__main__':
    # 创建多线程时， 需要制定该线程执行的任务.name线程名字 target目标函数名
    t1 = threading.Thread(target=job,name='job1')
    t2 = threading.Thread(target=job,name='job2')
    t1.start()
    t2.start()
    print(threading.active_count())
	print("程序执行结束.....")

---------------输出-----------------
这是一个需要执行的任务。。。。。
当前线程的个数: 3
这是一个需要执行的任务。。。。。
3
程序执行结束.....
当前线程的个数: 3
当前线程的信息: <Thread(job1, started 140416648140544)>
当前线程的信息: <Thread(job2, started 140416639747840)>

```
出现的问题：主线程执行已经结束，但是子线程还在运行

join()方法可以等待所有子线程执行结束，再执行主线程

```python
import threading
import time

def job():
    print("这是一个需要执行的任务。。。。。")
    print("当前线程的个数:", threading.active_count() )
    time.sleep(1)
    print("当前线程的信息:", threading.current_thread())
	  


if __name__ == '__main__':
    # 创建多线程时， 需要制定该线程执行的任务.name线程名字 target目标函数名
    t1 = threading.Thread(target=job,name='job1')
    t2 = threading.Thread(target=job,name='job2')
    t1.start()
    t2.start()
    print(threading.active_count())

    # 出现的问题: 主线程执行结束， 但是子线程还在运行。
    # 等待所有的子线程执行结束之后， 再执行主线程
    t1.join()
    t2.join()
    print("程序执行结束.....")

---------------输出-----------------
这是一个需要执行的任务。。。。。
当前的线程的个数： 2
这是一个需要执行的任务。。。。。
当前的线程的个数： 3
主线程： 3
当前线程的信息：当前线程的信息： <Thread(job2, started 1252)>
 <Thread(job1, started 11664)>
程序执行结束！

```

参考链接：
[python-实现多线程的三种方法](https://blog.csdn.net/weixin_43067754/article/details/86763905)

[Python实现多线程的几种方式](https://www.cnblogs.com/frank-shen/p/10276666.html)