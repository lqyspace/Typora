# 数据库的事务隔离级别

## 前言

数据库的隔离级别有4个，由低到高依次为 `Read uncommitted`、`Read committed`、`Repeatable read`、`Serializable`，这四个级别可以逐个解决脏读，不可重复读，幻读这几类问题。

√：可能出现    ×：不会出现

|                  | 脏读 | 不可重复读 | 幻读 |
| ---------------- | ---- | ---------- | ---- |
| read uncommitted | √    | √          | √    |
| read committed   | ×    | √          | √    |
| repeatable read  | ×    | ×          | √    |
| serializable     | ×    | ×          | ×    |

注意：我们讨论隔离级别场景，主要是在多个事务并发的情况下，因此，接下来的讲解都是围绕事务并发。



## Read uncommitted 读未提交

顾名思义，就是一个事务可以读取到另一个事务未提交的数据。

在多个事务并发进行过程中，一个事务可以读取到另一个事务未提交的数据，这也就导致了脏读的现象。

公司发工资了，领导把5000元打到singo的账户上，但是该事务并未提交，而singo正好去查账户，发现工资已经到账，是5000元整，非常高兴。可是不幸的，领导发给singo的工资金额不对，是2000元，于是迅速回滚了事务，修改金额后，将事务提交。最后singo领到的实际工资只有2000元，singo空欢喜一场。

![img](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202307091827029.png)

出现上述情况，即我们所说的脏读 ，两个并发的事务，“事务A：领导给singo发工资”、“事务B：singo查询工资账户”，事务B读取了事务A尚未提交的数据。

当隔离级别设置为Read uncommitted 时，就可能出现脏读，如何避免脏读，请看下一个隔离级别。



## Read committed 读提交

顾名思义，就是一个事务要等另一个事务提交之后才能读取数据。

多事务并发进行过程中，==在实际的操作中，读操作在读取未提交事务的数据时，只能读取以前的数据，更新的数据需要等到更新操作被提交以后才能被读取到。==这也就导致了在同一个事务中，两次查询结果不一致的情况，即不可重复读的现象。

singo拿着工资卡去消费，系统读取到卡里确实有2000元，而在此时她的老婆也正好在网上转账，把singo工资卡的2000元转到另一账户，并在 singo之前提交了事务，当singo扣款时，系统检查到singo的工资卡已经没有钱（==第二次检测金额当然等到妻子转出金额事务提交完==，如何没提交完的时候检测的结果当然是一样的咯），扣款失败，singo十分纳闷，明明卡里有钱，为何......

这就是读提交，若有事务对数据进行更新（Update）操作时，读操作事务要等到这个更新操作事务提交后才能读取数据，可以解决脏读问题。==在实际的操作中，读操作只能读到未提交事务的以前的数据，更新的数据需要在更新操作被提交以后才能被读取。==

但是在这个案例中，出现了**一个==事务范围内两个相同的查询却返回了不同的数据，这就是不可重复读。==**

 当隔离级别设置为Read committed 时，避免了脏读，但是可能会造成不可重复读。

 大多数数据库的默认级别就是Read committed，比如Sql Server , Oracle。如何解决不可重复读这一问题，请看下一个隔离级别。repeatable read!



## Repeatable read 重复读

重复读，就是在开始读取数据（事务开启）时，不再允许修改操作。

在多事务并发进行时，A事务执行更新操作，B事务执行读操作。A事务更新完数据以后并且提交了事务，此时在B事务中读到的数据仍然是更新以前的数据，这样就保证了在B事务中读到的数据都是一致的，解决了不可重复读的问题，如果想要B事务也读到更新以后的数据，需要让B事务也被提交。

事例：singo拿着信用卡去享受生活（卡里当然是只有2000元），当他埋单时（==事务开启，不允许其他事务的UPDATE修改操作==），收费系统事先检测到他的卡里有2000元。这个时候他的妻子不能转出金额了。接下来收费系统就可以扣款了。

分析：重复读可以解决不可重复读问题。写到这里，应该明白的一点就是，==不可重复读对应的是修改，即UPDATE操作==。但是可能还会有==幻读==问题。因为==幻读问题对应的是插入INSERT操作，而不是UPDATE操作。==

- 什么时候会出现幻读？

事例：singo某一天去消费，花了2千元，然后他的妻子去查看他今天的消费记录（全表扫描FTS，妻子事务开启），看到确实是花了2千元，就在这个时候，程序员花了1万买了一部电脑，即==新增INSERT==了一条消费记录，并提交。当妻子打印程序员的消费记录清单时（妻子事务提交），发现花了1.2万元，似乎出现了幻觉，这就是幻读。



---

- 那怎么解决幻读问题？Serializable！

---



## Serializable 序列化

`Serializable` 是最高的事务隔离级别，在该级别下，事务==串行化顺序执行==，可以避免脏读、不可重复读与幻读。但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。



---

==值得一提的是：大多数数据库默认的事务隔离级别是Read committed，比如Sql Server , Oracle。Mysql的默认隔离级别是Repeatable read。==

















