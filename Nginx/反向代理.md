# 反向代理

## 网关、代理、反向代理

![image-20220522203927519](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202205222039583.png)

反向代理：**用户**通过**互联网**将请求发送到机房的**网关的路由**上，然后网关将用户的请求发送到一个**Nginx的代理服务器**上，然后Nginx会将用户的所有请求转发到后端的**应用服务器**上，后端的应用服务器将结果返回给Nginx的代理服务器上，后端的应用服务器是不会被用户直接访问到的 ，在Nginx与应用服务器之间形成一段**内网**。



![image-20220522211654457](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202205222116518.png)

正向代理：用户通过一层网关（代理服务器），访问到外网，用户和外网不能直接访问，代理服务器和网关可以直接访问。



网关：访问网络的入口，我们称之为网关。



这里的代理服务器就相当于网关。



你的下载速度取决于你的网关的上行带宽，如果你的网关只有10m，即使你有100m的网络，你也只能达到最大的10m速度。（解决办法：只能提高网关的上行带宽）





![image-20220522212400219](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202205222124305.png)

隧道式代理：一进一出都经过代理

DR模式代理：进的时候走代理，出的时候直接发给网关，应用服务器相当于只能从内网接收数据，但可以将数据直接发给外网，这个过程是通过lvs实现的，lvs是跟nginx一样的存在。



lvs是一个非常简单的软件，它直接嵌在linux的内核里。





## 反向代理在系统架构中的应用场景

![image-20220522212940049](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202205222129111.png)



![image-20220522212949845](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202205222129938.png)

![image-20220522213004933](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202205222130020.png)







![image-20220522213408506](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202205222134632.png)

![image-20220522213422463](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202205222134579.png)

![image-20220522213726806](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202205222137961.png)





## Nginx的反向代理配置

**关键字：proxy_pass**

> 代理一台服务器：

```
server {
	listen 80;
	server_name localhost;
	
	location / {
		# proxy_pass可以接代理的具体的网址：主机或网址；或者 一组服务器。
		# 不支持 https 的proxy_path。
		# 可以支持：http://192.168.102.116 ,代理一台服务器
		proxy_pass http://www.baidu.com;
		# 当配置proxy_pass时，下面两个要注释掉
		# root html;
		# index index.html index.htm;
	}
}
```

> 代理多台服务器：负载均衡，雨露均沾。

```
upstream httpds {
	server 192.168.102.112:80;
	server 192.168.102.113:80;
}

server {
	listen 80;
	server_name localhost;
	
	location / {
		# httpds 是被定义的一个虚拟的名称
		proxy_pass http://httpds;
		# root html;
		# index index.html index.htm;
	}

}
```





![image-20220522215949632](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202205222159698.png)



## 基于反向代理的负载均衡器

![image-20220522214213354](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202205222142443.png)



- 应用服务器是一个集群，里面是大量相同内容的服务器。
- nginx 反向代理，使用轮训的算法 访问集群里的应用服务器，相当于每个应用服务器都能用上，而不会使某一个服务器的压力过大。
- 在代理的过程中如果出现某一个服务器不能服务，nginx服务器就会进行 retry 到另一台可用的服务器上，然后使不能用的服务器下线，当服务器可用时再上线。





## 负载均衡器

> 负载均衡的策略

weight：负载均衡的比例。

![image-20220522222338497](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202205222223568.png)

```
upstream httpds {
	server 192.168.102.112:80 weight=8;
	server 192.168.102.113:80 weight=2;
	server 192.168.102.114:80 weight=2;
}

server {
	listen 80;
	server_name localhost;
	
	location / {
		# httpds 是被定义的一个虚拟的名称
		proxy_pass http://httpds;
		# root html;
		# index index.html index.htm;
	}

}
```

> down : 使某些机器不参与负载均衡

```
upstream httpds {
	server 192.168.102.112:80 weight=8 down;
	server 192.168.102.113:80 weight=2;
	server 192.168.102.114:80 weight=2;
}

server {
	listen 80;
	server_name localhost;
	
	location / {
		# httpds 是被定义的一个虚拟的名称
		proxy_pass http://httpds;
		# root html;
		# index index.html index.htm;
	}

}
```

> backup：正常情况下不用这台机器，当其他的机器不能用，才用这台机器。

```
upstream httpds {
	server 192.168.102.112:80 weight=8 down;
	server 192.168.102.113:80 weight=2;
	server 192.168.102.114:80 weight=1 backup;
}

server {
	listen 80;
	server_name localhost;
	
	location / {
		# httpds 是被定义的一个虚拟的名称
		proxy_pass http://httpds;
		# root html;
		# index index.html index.htm;
	}

}
```

![image-20220522230547918](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202205222305004.png)

## 其他的负载均衡策略

### 轮训

默认情况下使用轮训方式，逐一转发，这种方式适用于无状态请求。

缺点：不能保持会话。



### weight

指定轮训的几率，weight和访问比率成正比，由于后端性能不均的情况。

```
upstream httpds {
	server 192.168.102.112:80 weight=8 down;
	server 192.168.102.113:80 weight=2;
	server 192.168.102.114:80 weight=1 backup;
}
```

- down：表示当前的 server 暂时不能参与负载。
- weight：默认为1，weight越大，负载的权重就越大。
- backup：其他所有的非backup机器down或者忙的时候，请求backup机器。



### ip_hash

根据客户端的ip地址转发同一台服务器，可以保持会话。

- 判断来源的ip地址，相同的ip指向相同的服务器

缺点：如果客户端的ip地址更换的话，也无法保持会话。比如随时移动的时候。



### least_conn

最少链接访问

缺点：造成流量倾斜。

不常用，几乎用不着

### url_hash

根据用户访问的url定向转发请求。

定向流量转发。

适用于：访问固定资源

缺点：不能维持会话



### fair

根据后端服务器响应时间转发请求，响应时间优先转发。

缺点：造成流量倾斜。



以上四种很少用：

- 动态上下线做不到
- 只从固定的配置文件里转发网址



改进：用LuaJIT脚本的方式在Nginx里面编程来动态的管理服务的列表。包括检测服务上下线的情况，包括里面服务的权重值，包括流量定向的转发。







现在主流的会话保持方式：下发token——无状态会话保持。

- 用户请求nginx服务器 ，nginx服务器会找到一台专门进行权限认证的服务器。当用户的请求到这个权限校验的服务器上时，首先校验请求（比如是否登陆），如果校验成功，则下发权限token给客户端，这个token不再记录cookie和session，而是里面存储用户的状态信息，服务器端不存token，服务器端只做校验，服务器将token下发给客户端，解密token的密码客户端没有，只有服务器端有，客户端不需要读懂token，只需要每次访问的时候带着这个token，如果token被更改，则服务器解不开，则认为校验失败。











