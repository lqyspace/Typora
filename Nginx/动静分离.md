# 动静分离



## 使用动静分离的场景

![image-20220523005023585](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202205230050719.png)

- **适合中小型网站**
- **起到系统加速的作用**

![image-20220523005310341](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202205230053416.png)

- tomcat 负责处理动态请求，同时也负责发送静态资源。



## 动静分离的原理

![image-20220523005424178](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202205230054264.png)

- 直接将静态资源放到Nginx里，不再让tomcat发送
- 而动态请求则通过tomcat进行发送



## Nginx动静分离配置

> 简单的配置方法

1、将应用服务器的静态资源删除。

2、将应用服务器的静态资源传到 Nginx 代理服务器上。

3、多写几个location应用于静态资源。

```
server {
	listen 80;
	server_name localhost;
	
	location / {
		proxy_pass http://192.168.122.113:8080;
	}
	
	// 请注意 /css 这种格式的根目录的优先级要比 / 的优先级要高
	location /css {
		root html;
		index index.html index.htm;
	}
	location /js {
		root html;
		index index.html index.htm;
	}
	location /img {
		root html;
		index index.html index.htm;
	}
}
```

![image-20220523011003232](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202205230110315.png)



> location匹配规则

**语法规则 **

```go
location [ = | ~ | ~* | ^~] uri {...}

location @name {...}
```

语法规则很简单，一个location关键字，后面跟着可选的修饰符，后面是要匹配的字符，花括号时要执行的操作。



**修饰符**

- = 表示 精确匹配。只有请求的url路径与后面的字符串完全相等时，才会命中。
- ~ 表示该规则是使用正则表达式，区分大小写。
- ~* 表示该规则是使用正则表达式，不区分大小写。
- ^~ 表示如果该符号后面的字符是最佳匹配的，即采用改规则，不再进行后续的查找。



**匹配过程**

对请求的 url 序列化，例如，对 %xx 等字符进行解码，去除 url 中多个相连的 /，解析 url 中的  . ，.. 等。这一步是匹配的前置工作。



location 有两种表示形式，一种是使用前缀字符，一种是使用正则。如果是正则的话，前面有 ~ 或 ~* 修饰符。



1、首先先检查使用前缀字符定义的 location，选择最长匹配的项并记录下来。

2、如果找到了精确匹配的 location，也就是使用了 = 修饰符的location，结束查找，并使用它的配置。

3、然后按顺序查找使用正则定义的location，如果匹配则停止查找，使用它定义的配置。

4、如果没有匹配的正则location，则使用前面记录的最长匹配前缀字符location。



基于以上的匹配过程，我们可以得到以下两点启示：

1. **使用正则定义的location在配置文件中出现的顺序很重要**。因为找到第一个匹配的正则后，查找就停止了，后面定义的正则就是再匹配也没有机会了。
2. **使用精确匹配可以提高查找的速度**。例如经常请求`/`的话，可以使用`=`来定义location。



**示例**

接下来我们以一个例子来具体说明一下匹配过程。

假如我们有下面的一段配置文件：

```nginx
location = / {
    [ configuration A ]
}

location / {
    [ configuration B ]
}

location /user/ {
    [ configuration C ]
}

location ^~ /images/ {
    [ configuration D ]
}

location ~* \.(gif|jpg|jpeg)$ {
    [ configuration E ]
}

```

请求`/`精准匹配A，不再往下查找。



请求`/index.html`匹配B。首先查找匹配的前缀字符，找到最长匹配是配置B，接着又按照顺序查找匹配的正则。结果没有找到，因此使用先前标记的最长匹配，即配置B。

请求`/user/index.html`匹配C。首先找到最长匹配C，由于后面没有匹配的正则，所以使用最长匹配C。
请求`/user/1.jpg`匹配E。首先进行前缀字符的查找，找到最长匹配项C，继续进行正则查找，找到匹配项E。因此使用E。

请求`/images/1.jpg`匹配D。首先进行前缀字符的查找，找到最长匹配D。但是，特殊的是它使用了`^~`修饰符，不再进行接下来的正则的匹配查找，因此使用D。这里，如果没有前面的修饰符，其实最终的匹配是E。大家可以想一想为什么。

请求`/documents/about.html`匹配B。因为B表示任何以`/`开头的URL都匹配。在上面的配置中，只有B能满足，所以匹配B。





**location @name的用法**

@用来定义一个命名location。主要用于内部重定向，不能用来处理正常的请求。其用法如下：

```nginx
location / {
    try_files $uri $uri/ @custom
}
location @custom {
    # ...do something
}
```

上例中，当尝试访问url找不到对应的文件就重定向到我们自定义的命名location（此处为custom）。



**值得注意的是，命名location中不能再嵌套其它的命名location。**



**URL尾部的/需不需要**

关于URL尾部的`/`有三点也需要说明一下。第一点与location配置有关，其他两点无关。

1. location中的字符有没有`/`都没有影响。也就是说`/user/`和`/user`是一样的。
2. 如果URL结构是`https://domain.com/`的形式，尾部有没有`/`都不会造成重定向。因为浏览器在发起请求的时候，默认加上了`/`。虽然很多浏览器在地址栏里也不会显示`/`。这一点，可以访问[baidu](https://link.segmentfault.com/?enc=V70nu6llP7NOXvzBkcJ7VQ%3D%3D.c%2Bse5TYG6waeGD8jq5edcra%2FwEJ4p4pM9Iny5sZnjA0%3D)验证一下。
3. 如果URL的结构是`https://domain.com/some-dir/`。尾部如果缺少`/`将导致重定向。因为根据约定，URL尾部的`/`表示目录，没有`/`表示文件。所以访问`/some-dir/`时，服务器会自动去该目录下找对应的默认文件。如果访问`/some-dir`的话，服务器会先去找`some-dir`文件，找不到的话会将`some-dir`当成目录，重定向到`/some-dir/`，去该目录下找默认文件。可以去测试一下你的网站是不是这样的。



**总结**

location的配置有两种形式，前缀字符和正则。查找匹配的时候，先查找前缀字符，选择最长匹配项，再查找正则。正则的优先级高于前缀字符。

正则的查找是按照在配置文件中的顺序进行的。因此正则的顺序很重要，建议越精细的放的越靠前。

使用`=`精准匹配可以加快查找的顺序，如果根域名经常被访问的话建议使用`=`。































