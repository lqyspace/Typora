

## 1、get请求与post请求的区别

### 1、是什么

- 两者都是 `HTTP` 协议发送请求的方法
- `GET`方法请求一个指定资源的表示形式，使用 `GET` 请求应该只被用于获取数据，是 **无副作用**
- `POST` 方法用于将实体提交到指定资源，通常导致在服务器上的状态变化或**副作用**
- 本质上都是 `TCP` 链接，并无差别
- 但是由于 `HTTP` 的规定和浏览器/服务器的限制，导致他们在应用过程中会体现出一些差别

### 2、区别

从`w3schools`得到的标准答案的区别如下：

- `GET` 在浏览器回退时是无害的，而POST会再次提交请求
- `GET` 产生的 `url` 地址可以被 `Bookmark` ，而 `POST` 不可以
- `GET` 请求会被浏览器主动 `cache` ，而 `POST` 不会，除非手动设置
- `GET`请求只能进行 `url` 编码，而 `POST` 请求支持多种编码方式
- `GET`请求参数会被完整保留在浏览器历史记录里，而 `POST` 中的参数不会被保留
- `GET` 请求在 `url`中传送的参数 `url` 有长度限制的，而 `POST` 则没有
- 对参数的数据类型，`GET`只接受 `ASCII`字符，而 `POST` 没有限制
- `GET` 比 `POST`更不安全，因为参数直接暴露在 `URL` 上，所以不能用来传递敏感信息
- `GET`参数通过 `URL` 传递，而 `POST` 则放在 `Request Body`中
- `GET` 比 `POST` 更快

### 3、参数位置

貌似从上面看到的 `GET` 和 `POST` 请求区别非常大，但二者实质并没有区别，只是报文格式不同；

`GET` 和 `POST` 只是 `HTTP` 协议的两种请求方式，而 `HTTP` 协议是基于 `TCP/IP` 的应用层协议；无论 `GET` 还是 `POST` 用的都是同一个传输层协议，所以在传输上没有区别；

当不携带参数的时候，两者最大的区别为第一行方法名不同：

> POST /uri HTTP/1.1 \r\n
>
> GET /uri HTTP/1.1 \r\n

当携带参数的时候，我们都知道 `GET` 请求是放在 `url` 中，`POST`请求是放在 `Body` 中

`GET` 方法简约版报文是这样的：

```js
GET /index.html?name=qiming.c&age=22 HTTP/1.1
Host: localhost
```

`POST` 方法简约版报文是这样的

```js
POST /index.html HTTP/1.1
Host: localhost
Content-Type: application/x-www-form-urlencoded

name=qiming.c&age=22
```

注意：这里只是约定，并不属于 `HTTP`规范，相反的，我们可以在 `POST` 请求中 `url`中写入参数，或者 `GET` 请求中 `body` 携带参数。

其实两种方法的本质上是TCP连接，没有差别，也就是说，如果不按规范来也是可以，只要前后端约定好怎么传递参数就可以。也就是说可以在URL上写参数，然后方法使用POST；也可以在body写参数，然后方法使用GET,只要后端服务支持这种传参方式就可以。



### 4、参数长度

`HTTP` 协议没有 `Body` 和 `URL` 的长度限制，对 `URL` 限制的大多是浏览器和服务器的原因。

`IE`对 `URL` 长度的限制是2083字节（`2K+35`）。对于其他的浏览器，如 `Netscape`、`FireFox` 等，理论上没有长度限制，其限制取决于操作系统的支持。

这里限制的是整个 `URL` 的长度，而不仅仅是参数指定的长度。

服务器处理长 `URL` 要消耗比较多的资源，为了性能和安全考虑，会给 `URL`长度加限制。



### 5、安全

`POST` 比 `GET` 安全，因为数据在地址栏上不可见。

然而，从传输的角度来说，他们都是不安全的，因为 `HTTP` 在网络上也是明文传输的，只要在网络节点上捉包，就能完整地获取数据报文。

只有 `HTTPS` 才能加密安全。



### 6、数据包

对于 `GET` 请求，浏览器会把 `http header` 和 `data` 一并发送出去，服务器响应 200（返回数据）。

对于 `POST`请求，浏览器先发送 `http header` ，服务器响应 100 `continue`，浏览器再发送 `data`，服务器响应200 `ok`。

并不是所有浏览器都会在 `POST`中发送两次包，`FireFox`就只发送一次。



### 7、常见问题

1、GET方法参数写法是固定的吗？

在常见约定中，我们的参数是写在`?`后面，用`&`分割每个参数。

而后端服务在解析报文的过程是用过获取TCP数据，用正则等工具从数据中获取Header和Body，从而提取参数。也就是说，我们可以约定自己的写法，只要服务端可以解析出来就可以，比如GO语言常用的WEB框架gin，常用的写法是:`https://www.bitbo.com/book/page/12/name/bitbo`，或者直接前后端约定好参数位置`https://www.bitbo.com/book/12/bitbo`，也可以用常用的`?`和`&`方式。

2、POST方法比GET方法安全？

按照网上大部分文章的解释，POST比GET安全，因为数据在地址栏不可见。然而，从传输的角度来说，POST和GET方式都是不安全的，因为HTTP在网络上是明文传输的，只要在网络节点上抓包，就能完整的获取数据报文。**要想安全传输就只有加密，也就是加上安全协议，使用`HTTPS`协议**。

3、GET方法的长度有限制？

网上大部分的观点在评论者POST和GET的时候都有这一条，提到游览器地址栏输入的参数是有限的。然而HTTP协议其实并没有Body和URL的长度限制，对URL的限制大多是游览器和服务器的原因，比如服务器出于性能和安全的考虑，防止恶意构造长URL来攻击，处理长URL会消耗比较多的资源。所以给URL长度加上限制。

4、POST方法会产生两个TCP数据包？

有些文章提到，POST会将Header和body分开发送，**先发送Header，服务器返回100状态码再发送body**。然而HTTP协议并没有明确说明POST会产生两个TCP数据包，**所以header和body分开发送是部分游览器或者框架的请求方式，并不属于post必然行为**。



### 8、使用常见

`GET`请求：

- 希望请求中的`URL`可以被手动输入

- 希望请求中的`URL`可以被存在书签里，或者历史里，或者快速拨号里面，或者分享给别人。

- 希望请求中的`URL`是可以被搜索引擎收录的。

- 希望带云压缩的浏览器，比如`Opera mini/Turbo 2`, 只有`GET`才能在服务器端被预取的。

- 希望请求中的`URL`可以被缓存


`POST`请求：

- 表单提交。

- 请求参数中有敏感信息。

- 请求参数很长，可能超过浏览器或服务器的限制。


总的来说，`GET`适合于查询操作，`POST`适合于新增、修改、删除操作。



## 2、TCP/IP网络模型有哪几层

### 1、应用层

- 应用层只需要专注于为用户提供应用功能，比如 `HTTP`、`FTP`、`Telnet`、`DNS`、`SMTP` 等
- 应用层是不用去关心数据是如何传输的，就类似于，我们寄快递的时候，只需要把包裹交给快递员，由他负责运输快递，我们不需要关心快递是如何被运输的。
- 应用层是工作在操作系统中的用户态，传输层及以下则工作在内核态。



### 2、传输层

- 应用层的数据包会传给传输层，**传输层**（*Transport Layer*）是为应用层提供网络支持的。
- 在传输层会有两个传输协议，分别是 `TCP` 和 `UDP`。
- `TCP` 的全称叫传输控制协议（*Transmission Control Protocol*），大部分应用使用的正是 `TCP` 传输层协议，比如 `HTTP` 应用层协议。`TCP` 相比 `UDP` 多了很多特性，比如流量控制、超时重传、拥塞控制等，这些都是为了保证数据包能可靠地传输给对方。
- `UDP` 相对来说就很简单，简单到只负责发送数据包，不保证数据包是否能抵达对方，但它实时性相对更好，传输效率也高。当然，`UDP` 也可以实现可靠传输，把 `TCP` 的特性在应用层上实现就可以，不过要实现一个商用的可靠 `UDP` 传输协议，也不是一件简单的事情。
- 应用需要传输的数据可能会非常大，如果直接传输就不好控制，因此当传输层的**数据包**大小超过 `MSS`（`TCP` 最大报文段长度） ，就要将数据包分块，这样即使中途有一个分块丢失或损坏了，只需要重新发送这一个分块，而不用重新发送整个数据包。在 `TCP` 协议中，我们把每个分块称为一个 **`TCP` 段**（*TCP Segment*）。
- 当设备作为接收方时，传输层则要负责把数据包传给应用，但是一台设备上可能会有很多应用在接收或者传输数据，因此需要用一个编号将应用区分开来，这个编号就是**端口**
  - 比如 80 端口通常是 Web 服务器用的，22 端口通常是远程登录服务器用的。而对于浏览器（客户端）中的每个标签栏都是一个独立的进程，操作系统会为这些进程分配临时的端口号。
- 由于传输层的报文中会携带端口号，因此接收方可以识别出该报文是发送给哪个应用。

![img](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202305291834636.png)



### 3、网络层

- 网络层最常使用的是 `IP` 协议（*Internet Protocol*），`IP` 协议会将传输层的报文作为数据部分，再加上 `IP` 包头组装成 `IP` 报文，如果 `IP` 报文大小超过 `MTU`（以太网中一般为 1500 字节）就会**再次进行分片**，得到一个即将发送到网络的 `IP` 报文。
- 一般用 `IP` 地址给设备进行编号，对于 `IPv4` 协议， `IP` 地址共 32 位，分成了四段（比如，192.168.100.1），每段是 8 位。
- 将 `IP` 地址分成两种意义：主机号、网络号
  - 网络号：负责标识该 `IP` 地址属于哪一个子网
  - 主机号：负责标识同一子网下的不同主机；
- 需要配合子网掩码才能算出网络号和主机号
  - 比如 `10.100.122.0/24` ，后面的 `/24` 表示就是 `255.255.255.0` 子网掩码。
  - 将 `ip` 为 `10.100.122.2` 与 `255.255.255.0`进行与运算，就可以得到网络号。
  - 将 `255.255.255.0`取反后与 `IP` 地址进行按位与运算，就可以得到主机号。

![image-20230529154103358](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202305291545259.png)



- `IP` 地址除了寻址功能，还有路由的功能，**`IP` 协议的寻址作用是告诉我们去往下一个目的地该朝哪个方向走，路由则是根据「下一个目的地」选择路径。寻址更像在导航，路由更像在操作方向盘**。

![IP地址的网络号](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202305291548308.png)

### 4、网络接口层

- 生成了 `IP` 头部之后，接下来要交给**网络接口层**（*Link Layer*）在 `IP` 头部的前面加上 `MAC` 头部，并封装成数据帧（Data frame）发送到网络上。

![img](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202305291550077.png)

`IP` 头部中的接收方 `IP` 地址表示网络包的目的地，通过这个地址我们就可以判断要将包发到哪里，但在以太网的世界中，这个思路是行不通的。

什么是以太网呢？电脑上的以太网接口，`Wi-Fi`接口，以太网交换机、路由器上的千兆，万兆以太网口，还有网线，它们都是以太网的组成部分。以太网就是一种在「局域网」内，把附近的设备连接起来，使它们之间可以进行通讯的技术。

以太网在判断网络包目的地时和 `IP` 的方式不同，因此必须采用相匹配的方式才能在以太网中将包发往目的地，而 `MAC` 头部就是干这个用的，所以，在以太网进行通讯要用到 `MAC` 地址。

`MAC` 头部是以太网使用的头部，它包含了接收方和发送方的 `MAC` 地址等信息，我们可以通过 `ARP` 协议获取对方的 `MAC` 地址。

所以说，网络接口层主要为网络层提供「链路级别」传输的服务，负责在以太网、`WiFi` 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标识网络上的设备。



### 5、总结

综上所述，`TCP/IP` 网络通常是由上到下分成 4 层，分别是**应用层，传输层，网络层和网络接口层**。

![img](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202305291558113.png)

各层的封装格式：

![img](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202305291559489.png)

**网络接口层**的传输单位是**`帧（frame）`**，`IP` 层的传输单位是**`包（packet）`**，`TCP` 层的传输单位是**`段（segment）`**，`HTTP` 的传输单位则是**`消息或报文（message）`**。但这些名词并没有什么本质的区分，可以统称为数据包。



## 3、在浏览器输入网址后直到浏览器显示页面的过程

接下来以这个拓扑模型作为例子，探讨其中发生了什么？

![简单的网络模型](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202305291609777.png)



### 1、解析URL

首先浏览器做的第一步工作就是要对 `URL` 进行解析，从而生成发送给 `Web` 服务器的请求信息。

![URL 解析](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202305291610311.jpeg)

当没有路径名时，就代表访问根目录下事先设置的**默认文件**，也就是 `/index.html` 或者 `/default.html` 这些文件，这样就不会发生混乱了。

对 `URL` 进行解析之后，浏览器确定了 Web 服务器和文件名，接下来就是根据这些信息来生成 HTTP 请求消息了。

![HTTP 的消息格式](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202305291610648.png)

### 2、真实地址查询-DNS

通过浏览器解析 URL 并生成 HTTP 消息后，需要委托操作系统将消息发送给 `Web` 服务器。

但在发送之前，还有一项工作需要完成，那就是**查询服务器域名对应的 IP 地址**，因为委托操作系统发送消息时，必须提供通信对象的 IP 地址。

所以，有一种服务器就专门保存了 `Web` 服务器域名与 `IP` 的对应关系，它就是 `DNS` 服务器。

> **域名的层级关系**

`DNS` 中的域名都是用**句点**来分隔的，比如 `www.server.com`，这里的句点代表了不同层次之间的**界限**。

在域名中，**越靠右**的位置表示其层级**越高**。

实际上域名最后还有一个点，比如 `www.server.com.`，这个最后的一个点代表`根域名`。

也就是，`.` 根域是在最顶层，它的下一层就是 `.com` 顶级域，再下面是 `server.com`。

所以域名的层级关系类似一个树状结构：

- 根 `DNS` 服务器`（.）`
- 顶级域 `DNS` 服务器`（.com）`
- 权威 `DNS` 服务器`（server.com）`

根域的 `DNS` 服务器信息保存在互联网中所有的 `DNS` 服务器中。

这样一来，任何 `DNS` 服务器就都可以找到并访问根域 `DNS` 服务器了。

因此，客户端只要能够找到任意一台 `DNS` 服务器，就可以通过它找到根域 `DNS` 服务器，然后再一路顺藤摸瓜找到位于下层的某台目标 `DNS` 服务器。

![DNS 树状结构](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202305291612135.png)



> **域名的解析流程**

1. 客户端首先会发出一个 `DNS` 请求，问 www.server.com 的 `IP` 是啥，并发给本地 `DNS` 服务器（也就是客户端的 `TCP/IP` 设置中填写的 `DNS` 服务器地址）。
2. 本地域名服务器收到客户端的请求后，如果缓存里的表格能找到 www.server.com，则它直接返回 `IP` 地址。如果没有，本地 `DNS` 会去问它的根域名服务器：“老大， 能告诉我 www.server.com 的 `IP` 地址吗？” 根域名服务器是最高层次的，它不直接用于域名解析，但能指明一条道路。
3. 根 `DNS` 收到来自本地 `DNS` 的请求后，发现后置是 `.com`，说：“www.server.com 这个域名归 `.com` 区域管理”，我给你 `.com` 顶级域名服务器地址给你，你去问问它吧。”
4. 本地 `DNS` 收到顶级域名服务器的地址后，发起请求问“老二， 你能告诉我 www.server.com 的 `IP` 地址吗？”
5. 顶级域名服务器说：“我给你负责 www.server.com 区域的权威 DNS 服务器的地址，你去问它应该能问到”。
6. 本地 `DNS` 于是转向问权威 `DNS` 服务器：“老三，www.server.com对应的`IP`是啥呀？” `server.com` 的权威 `DNS` 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。
7. 权威 `DNS` 服务器查询后将对应的 `IP` 地址 `X.X.X.X` 告诉本地 `DNS`。
8. 本地 `DNS` 再将 `IP` 地址返回客户端，客户端和目标建立连接。

![域名解析的工作流程](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202305291620326.png)

`DNS` 域名解析的过程蛮有意思的，整个过程就和我们日常生活中找人问路的过程类似，**只指路不带路**。



> **那是不是每次域名解析都要经过这么多的步骤**

当然不是，还有缓存这个东西的嘛。

浏览器会先看自身有没有对这个域名的缓存，如果有，就直接返回，如果没有，就去问操作系统，操作系统也会去看自己的缓存，如果有，就直接返回，如果没有，再去 hosts 文件看，也没有，才会去问`「本地 DNS 服务器」`。



### 3、指南好帮手——协议栈

通过 `DNS` 获取到 `IP` 后，就可以把 `HTTP` 的传输工作交给操作系统中的**协议栈**。

协议栈的内部分为几个部分，分别承担不同的工作。上下关系是有一定的规则的，上面的部分会向下面的部分委托工作，下面的部分收到委托的工作并执行。

![img](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202305291625188.png)

应用程序（浏览器）通过调用 Socket 库，来委托协议栈工作。协议栈的上半部分有两块，分别是负责收发数据的 `TCP` 和 `UDP` 协议，这两个传输协议会接受应用层的委托执行收发数据的操作。

协议栈的下面一半是用 `IP` 协议控制网络包收发操作，在互联网上传数据时，数据会被切分成一块块的网络包，而将网络包发送给对方的操作就是由 `IP` 负责的。

此外 `IP` 中还包括 `ICMP` 协议和 `ARP` 协议。

- `ICMP` 用于告知网络包传送过程中产生的错误以及各种控制信息。
- `ARP` 用于根据 `IP` 地址查询相应的以太网 `MAC` 地址。

`IP` 下面的网卡驱动程序负责控制网卡硬件，而最下面的网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收操作。



### 4、可靠传输——TCP

`HTTP` 是基于 `TCP` 协议传输的，所以先了解一下 `TCP` 协议。

> **TCP包头的格式**

![TCP 包头格式](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202305291659588.png)

首先，**源端口号**和**目标端口**号是不可少的，如果没有这两个端口号，数据就不知道应该发给哪个应用。

接下来有包的**序号**，这个是为了解决包**乱序**的问题。

还有应该就是**确认号**，目的是确认发出去对方是否有收到。如果没有收到就应该重新发送，直到送达，这个是为了解决**丢包**的问题。

接下来还有一些**状态位**。例如 `SYN` 是发起一个连接，`ACK` 是回复，`RST` 是重新连接，`FIN` 是结束连接等。TCP 是面向连接的，因而双方要维护连接的状态，这些带状态位的包的发送，会引起双方的状态变更。

还有一个重要的就是**窗口大小**。TCP 要做**流量控制**，通信双方各声明一个窗口（缓存大小），标识自己当前能够的处理能力，别发送的太快，撑死我，也别发的太慢，饿死我。

除了做流量控制以外，TCP还会做**拥塞控制**，对于真正的通路堵车不堵车，它无能为力，唯一能做的就是控制自己，也即控制发送的速度。不能改变世界，就改变自己嘛。



> **TCP传输数据之前，要进行三次握手建立连接**

在 `HTTP` 传输数据之前，首先需要 `TCP` 建立连接，`TCP`连接的建立通常称作 `三次握手`。

这个所谓的 `链接`，只是双方计算机里维护一个状态机，主要作用就是为了确认双方的接受能力和发送能力是否正常，指定自己的初始化序列号为后面的可靠性传输做准备。在建立连接的过程中，双方的状态变化的时序图就像这样。

![TCP 三次握手](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202305291710989.png)

![img](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202305291724102.png)

![image-20221212004219997.png](https://github.com/wolverinn/Waking-Up/blob/master/_v_images/image-20221212004219997.png?raw=true)

- 一开始客户端和服务端都处于 `CLOSED`状态，先是服务端主动监听某个窗口，处于 `LISTENED`状态。
- 第一次握手：客户端主动发起连接 `SYN`，客户端将 `SYN`置为1，并随机产生一个初始化序列号 `IsN(c)`（ 也就是`seq`） 发送给服务端 ，之后处于 `SYN_SENT`状态。
- 第二次握手：服务端收到客户端的 `SYN=1` 之后，知道客户端请求建立连接，将自己的 `SYN`置为1，`ACK`置为1，产生一个 `acknowledge number=sequence number+1`（将客户端的`ISN`+1作为 `acknowledge number`的值 ），并随机产生一个自己的初始化序列 `ISN(c)` ， 发送给客户端，之后处于 `SYN-RCVD`状态。
- 第三次握手：客户端检查 `acknowledge number`是否为客户端的序列号+1，`ACK`是否为1，检查正确之后将自己的 `ACK`置为1，产生一个 `acknowledge number` = 服务器发的序列号 + 1，发送给服务器；之后客户端进入 `ESTABLISHED`状态；然后服务器检查客户端发来的 `ACK`是否为1，`acknowledge number`是否为服务器的序列号+1之后，如果都是，则也进入 `ESTABLISHED`状态，完成三次握手，建立连接。

所以三次握手目的是**保证通信双方都有发送和接受能力**。



**思考：为什么不是两次握手？**

如果是两次握手，发送端可以确定自己发送的信息对方能收到，也能确定对方发的包自己能收到，即客户端可以确认对方的发送能力和接受能力；但是，接收端只能确认对方法的包自己能收到，但是无法确认自己发的包对方是否能收到，即接收端只能确认对方的发送能力，不确定对方的接受能力是否正常。

并且两次握手的话，客户端有可能因为网络阻塞等原因会发送多个请求报文，延时到达的请求又会与服务器端建立连接，浪费掉许多服务器的资源。

> client 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 server。本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。假设不采用 “三次握手”，那么只要 server 发出确认，新的连接就建立了。由于现在 client 并没有发出建立连接的请求，因此不会理睬 server 的确认，也不会向 server 发送数据。但 server 却以为新的运输连接已经建立，并一直等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。采用 “三次握手” 的办法可以防止上述现象发生。例如刚才那种情况，client 不会向 server 的确认发出确认。server 由于收不到确认，就知道 client 并没有要求建立连接。



还有就是两次握手会给 `SYN flood` 攻击提供机会。

> SYN攻击/SYN flood攻击：三次握手过程中Server发完`SYN+ACK`到未收到Client的`ACK`之间的状态称为**半连接**。**SYN攻击**的原理是，黑客在短时间内伪造大量不同的`IP`地址高并发地对Server发SYN包。让服务器瞬间拥有大量半连接状态的连接，服务器需要不断地重发到超时为止，伪造的SYN包长时间占用未连接队列，从而导致系统资源被大量占用，而正常的SYN请求却被丢弃，最终使系统瘫痪，用户无法正常访问。



**思考：可以采用四次握手吗？**

可以，但是会降低传输效率。

四次握手是指：第二次握手：Server只发送 `ACK` 和 `acknowledge number` ；而Server的 `SYN` 和 初始化序列会在第三次握手时发送；原来协议中的第三次握手变为第四次握手。出于优化的目的，四次握手中的二，三可以合并。



**思考：第三次握手中，如果客户端的`ACK`未送到服务器，会怎么样？**

Server端：

由于Server端没有收到Client发送的`ACK`，因此会重发之前的 `SYN+ACK`（默认重发5次，之后自动关闭连接进入 `CLOSED`状态），Client收到后会重传 `ACK`给Server。

Client端，两种情况：

1、在Server进行超时重转的过程中，如果Client向服务器发送数据，数据头部的 `ACK`是为1，所以服务器收到数据之后会读取 `acknowledge number`，进入 `ESTABLISHED`状态。

2、在Server进入 `CLOSED`状态之后，如果Client向服务器发送数据，服务器会以 `RST` 包应答。



**思考：如果已经建立的连接，但客户端出现了故障怎么办？**

服务器每收到一次客户端的请求后，都会重新复为一个计时器，时间通常是设置2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没有反应，服务器则认为客户端出现了故障，接着就关闭连接。



**思考：初始序列号是什么？**

TCP连接的一方A，随机选择一个**32位的序列号（Sequence Number）**作为发送数据的**初始序列号（Initial Sequence Number，`ISN`）**，比如为1000，以该序列号为原点，对要传送的数据进行编号：1001、1002...三次握手时，把这个初始序列号传送给另一方B，以便在传输数据时，B可以确认什么样的数据编号是合法的；同时在进行数据传输时，A还可以确认B收到的每一个字节，如果A收到了B的确认编号（acknowledge number）是2001，就说明编号为1001-2000的数据已经被B成功接受。



> **思考：四次挥手**

![img](https://camo.githubusercontent.com/245cf8925daac2792d36f0f07066826a955175fe6e09030ae0a7ae17d1be9954/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f30613365626239302d626562612d313165622d383566362d3666616337376330633962332e706e67)

![image-20221212004254912.png](https://github.com/wolverinn/Waking-Up/blob/master/_v_images/image-20221212004254912.png?raw=true)

`TCP`终止一个连接，需要经过4次挥手。

过程如下：

- 第一次挥手：客户端将 `FIN`置为1，并发送一个 `FIN`报文，报文中指定一个序列号发给Server，客户端进入 `FIN_WAIT_1`状态；
- 第二次挥手：Server收到 `FIN`后，发送一个 `ACK=1`，`acknowledge number=收到的序列号+1`表明收到客户端的报文了；Server进入 `CLOSED_WAIT`状态。此时客户端没有要发送的数据了，但仍可以接受服务器发来的数据，客户端收到服务端的`ACK`进入。
- 第三次挥手：如果服务端也想断开连接，和客户端的第一次挥手一样，给客户端发 `FIN`报文， Server将`FIN`置为1，发送一个序号给Client，服务端进入 `LAST_ACK`状态。
- 第四次挥手：Client收到服务器的 `FIN`之后，进入 `TIME_WAIT`状态；接着将 `ACK`置为1，发送一个 `acknowledge number`=服务端序列号+1给服务器，服务端收到后，确认 `acknowledge number`后进入 `CLOSED`状态，不再向客户端发送数据，客户端等待 `2*MSL`（报文段最长寿命）时间后，也进入 `CLOSED`状态。完成4次挥手。



**思考：四次挥手的原因**

服务端在收到客户端断开连接`Fin`报文后，并不会立即关闭连接，而是先发送一个`ACK`包先告诉客户端收到关闭连接的请求，只有当服务器的所有报文发送完毕之后，才发送`FIN`报文断开连接，因此需要四次挥手。



**思考：为什么不能把服务器发送的 `ACK`和 `FIN` 合并起来，变成3次握手（`CLOED_WAIT`状态意味着什么？）**

因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复`ACK`，表示接收到了断开连接的请求。等到数据发完之后再发FIN，断开服务器到客户端的数据传送。



**思考：如果第2次挥手时服务器的 `ACK` 没有送达客户端，会怎么样？**

客户端没有收到 `ACK`确认，会重新发送 `FIN`请求。



**思考：客户端 `TIME_WAIT`状态意味着什么？**

第四次挥手时，客户端发送给服务器的`ACK`有可能丢失，`TIME_WAIT`状态就是用来重发可能丢失的`ACK`报文。如果Server没有收到`ACK`，就会重发`FIN`，如果Client在`2*MSL`的时间内收到了`FIN`，就会重新发送`ACK`并再次等待`2MSL`，防止Server没有收到`ACK`而不断重发FIN。

`MSL`(Maximum Segment Lifetime)，指一个片段在网络中最大的存活时间，`2MSL`就是一个发送和一个回复所需的最大时间。如果直到`2MSL`，Client都没有再次收到`FIN`，那么Client推断`ACK`已经被成功接收，则结束TCP连接。



> **如何查看TCP的连接状态**

TCP 的连接状态查看，在 Linux 可以通过 `netstat -napt` 命令查看。

![TCP 连接状态查看](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202305292107005.png)



> **TCP分割数据**

如果 HTTP 请求消息比较长，超过了 `MSS` 的长度，这时 TCP 就需要把 HTTP 的数据拆解成一块块的数据发送，而不是一次性发送所有数据。

![MTU 与 MSS](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202305292109993.png)

- `MTU`：一个网络包的最大长度，以太网中一般为 `1500` 字节。
- `MSS`：除去 `IP` 和 `TCP` 头部之后，一个网络包所能容纳的 `TCP` 数据的最大长度。

数据会被以 `MSS` 的长度为单位进行拆分，拆分出来的每一块数据都会被放进单独的网络包中。也就是在每个被拆分的数据加上 `TCP` 头信息，然后交给 `IP` 模块来发送数据。

![数据包分割](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202305292112657.png)



> **TCP报文生成**

TCP 协议里面会有两个端口，一个是浏览器监听的端口（通常是随机生成的），一个是 Web 服务器监听的端口（`HTTP` 默认端口号是 `80`， `HTTPS` 默认端口号是 `443`）。

在双方建立了连接后，TCP 报文中的数据部分就是存放 HTTP 头部 + 数据，组装好 TCP 报文之后，就需交给下面的网络层处理。

网络包的报文如下图。

![TCP 层报文](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202305292203095.png)



### 5、远程定位——IP

TCP 模块在执行连接、收发、断开等各阶段操作时，都需要委托 `IP` 模块将数据封装成**网络包**发送给通信对象。

IP报文头部的格式：

![IP 包头格式](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202305292209861.jpeg)

在 `IP` 协议里面需要有**源地址 `IP`** 和 **目标地址 `IP`**：

- 源地址`IP`，即是客户端输出的 `IP` 地址；
- 目标地址，即通过 `DNS` 域名解析得到的 Web 服务器 `IP`。

因为 HTTP 是经过 TCP 传输的，所以在 `IP` 包头的**协议号**，要填写为 `06`（十六进制），表示协议为 TCP。





> **假设客户端有多个网卡，就会有多个 `IP`地址，那 `IP` 头部的源地址应该选哪个 `IP`呢？**

当存在多个网卡时，在填写源地址 `IP` 时，就需要判断到底应该填写哪个地址。这个判断相当于在多块网卡中判断应该使用哪个一块网卡来发送包。

这个时候就需要根据**路由表**规则，来判断哪一个网卡作为源地址 `IP`。

在 Linux 操作系统，我们可以使用 `route -n` 命令查看当前系统的路由表。

![路由表](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202305292216984.png)

举个例子，根据上面的路由表，我们假设 Web 服务器的目标地址是 `192.168.10.200`。

![路由规则判断](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202305292219674.png)

1. 首先先和第一条目的子网掩码（`Genmask`）进行 **与运算**，得到结果为 `192.168.10.0`，但是第一个条目的 `Destination` 是 `192.168.3.0`，两者不一致所以匹配失败。
2. 再与第二条目的子网掩码进行 **与运算**，得到的结果为 `192.168.10.0`，与第二条目的 `Destination 192.168.10.0` 匹配成功，所以将使用 `eth1` 网卡的 `IP` 地址作为 `IP` 包头的源地址。

那么假设 Web 服务器的目标地址是 `10.100.20.100`，那么依然依照上面的路由表规则判断，判断后的结果是和第三条目匹配。

第三条目比较特殊，它目标地址和子网掩码都是 `0.0.0.0`，这表示**默认网关**，如果其他所有条目都无法匹配，就会自动匹配这一行。并且后续就把包发给路由器，`Gateway` 即是路由器的 `IP` 地址。

> **`IP`报文生成**

![IP 层报文](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202305292227264.jpeg)





### 6、两点传输——MAC

生成了 `IP` 头部之后，接下来网络包还需要在 `IP` 头部的前面加上 **MAC 头部**。

> **MAC包头格式**

MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息。

![MAC 包头格式](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202305292230769.png)

在 MAC 包头里需要**发送方 MAC 地址**和**接收方目标 MAC 地址**，用于**两点之间的传输**。

一般在 `TCP/IP` 通信里，MAC 包头的**协议类型**只使用：

- `0800` ： `IP` 协议
- `0806` ： `ARP` 协议



> **MAC发送方和接收方如何确认**

**发送方**的 MAC 地址获取就比较简单了，MAC 地址是在网卡生产时写入到 ROM 里的，只要将这个值读取出来写入到 MAC 头部就可以了。

**接收方**的 MAC 地址就有点复杂了，只要告诉以太网对方的 MAC 的地址，以太网就会帮我们把包发送过去，那么很显然这里应该填写对方的 MAC 地址。

所以先得搞清楚应该把包发给谁，这个只要查一下**路由表**就知道了。在路由表中找到相匹配的条目，然后把包发给 `Gateway` 列中的 `IP` 地址就可以了。



> **既然知道要发给谁，按如何获取对方的 MAC 地址呢？**

不知道对方 MAC 地址？不知道就喊呗。

此时就需要 `ARP` 协议帮我们找到路由器的 MAC 地址。

![ARP 广播](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202305292249472.png)

`ARP` 协议会在以太网中以**广播**的形式，对以太网所有的设备喊出：“这个 `IP` 地址是谁的？请把你的 MAC 地址告诉我”。

然后就会有人回答：“这个 `IP` 地址是我的，我的 MAC 地址是 `XXXX`”。

如果对方和自己处于同一个子网中，那么通过上面的操作就可以得到对方的 MAC 地址。然后，我们将这个 MAC 地址写入 MAC 头部，MAC 头部就完成了。

> **好像每次都要广播获取，这不是很麻烦吗？**

放心，在后续操作系统会把本次查询结果放到一块叫做 **`ARP` 缓存**的内存空间留着以后用，不过缓存的时间就几分钟。

也就是说，在发包时：

- 先查询 `ARP` 缓存，如果其中已经保存了对方的 MAC 地址，就不需要发送 `ARP` 查询，直接使用 `ARP` 缓存中的地址。
- 而当 `ARP` 缓存中不存在对方 MAC 地址时，则发送 `ARP` 广播查询。



> **查看 `ARP` 缓存内容**

在 Linux 系统中，我们可以使用 `arp -a` 命令来查看 `ARP` 缓存的内容。

![ARP 缓存内容](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202305292258686.png)



> **MAC 报文生成**

至此，网络包的报文如下图。

![MAC 层报文](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202305292259315.jpeg)

















