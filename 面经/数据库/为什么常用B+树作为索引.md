### 前言

索引就像是字典中的目录，我们可以借助目录快速检索到我们需要的字的解释。同样的道理，在数据库中，索引也可以帮助我们快速检索到我们所需要的数据，而且查询效率非常高。



### 为什么有了索引查询就会变快？

我们知道数据库村是有两种介质，一个是内存，一个是硬盘。内存是一种临时性存储介质，而且容量非常有限，如果服务器断电的话，会导致数据库的丢失。硬盘是一种永久性存储介质（如果不损坏的话），所以说我们需要把数据存放在硬盘里面才是最安全的。

但是有一个问题，如果我们把数据存放在硬盘里，我们对其中数据进行查询的时候，就会产生硬盘的 `I/O` 操作。相比较于内存存取来说的话，硬盘在存取时 `I/O` 消耗的时间更多。而索引的作用就是尽量减少硬盘的 `I/O` 操作，从而降低时间的花费。你可以对比查字典的操作，目录（索引）可以帮助你减少翻页的操作，是一个道理。



### 先聊聊二叉树

二叉树，顾名思义，就是每个节点最多有两个“叉”，也就是两个子节点，分别是左子节点和右子节点。不过二叉树并不要求每个节点都有两个子节点，有的节点只有左子节点，有的节点只有右子节点。

以最基础的二叉搜索树为例，假设搜索插入的数值为 `key`：

- 如果 `key`大于根节点，则在右子树中进行查找。
- 如果 `key`小于根节点，则在左子树中进行查找。
- 如果 `key`等于根节点，则直接返回结果。

假设创建数列{30，25，36，32，40，20，28}，同样的数据，不同的插入顺序，树的结果是不一样的，如下图所示：

![img](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306092256477.png)

可能存在极端的情况，当二叉树的深度非常大时会退化成链表。

上图中第一棵树的深度是3，也就是最多需要3次就能找出节点。而第二棵树的深度是7，最多需要7次才能找出节点。

图中右边也属于二分查找树，但是性能方面已经退化成链表，查找数据的时间复杂度 `O(n)`。为了解决这个问题，人们提出了平衡二叉搜索树（`AVL`树），它在**二分搜索树**的基础上增加了约束，保证了每个节点的左子树和右子树的高度之差不能超过1，也就是说节点的左子树和右子树仍然是平衡二叉树。

常见的平衡二叉树有很多种，包括平衡二叉搜索树，红黑树，数堆，伸展树。

平衡二叉搜索树是最早提出来的自平衡二叉搜索树，**当我们提到了平衡二叉树时一般指的就是平衡二叉搜索树**。事实上第一棵树就是平衡二叉搜索树，搜索的时间复杂度是$O(log_2n)$。

上面我们说到，查询时间的多少主要取决于硬盘的 `I/O`操作，如果我们采用二叉树的形式，即使通过二叉搜索树进行改良，树的深度也是 $O(log_2n)$，当 $n$比较大时，深度也是很大的。如图所示：

![img](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306092313388.png)

每访问一个节点就需要进行一次磁盘的 `I/O`操作，对于上面的树来说，我们需要进行5次 `I/O`操作。虽然平衡二叉树比较的效率高，但是树的深度同样也很高，这就意味着磁盘 `I/O`操作次数多，会影响整体数据查询的效率。



### 再看看B树

在上文中，我们知道如果二叉树作为索引会使树的高度变得很高，增加磁盘的 `I/O`次数，影响数据查询的时间。B树的出现就是为了解决这个问题，B树的英文是 Balance Tree（也有很多人翻译成 B-树，而这是一样的，都是B树），也就是平衡的多路搜索树，它的高度远小于平衡二叉树的高度。在文件系统和数据库系统中的索引结构常采用 `B树`来实现。

B树结构的示意图

![img](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306100901960.png)

B树作为平衡的多路搜索树，它的每一个节点最多包含M个子节点，M称为B树的阶。在图中，我们可以看到，每一个磁盘块中包括了关键字、子节点的指针。如果一个磁盘块有x个关键字，那么它就有x+1个子节点指针。对于一个100阶的B树来说，如果有3层的话那么就可以存储约100万的索引数据。对于大量的索引数据来说，采用B树的结构是非常合适的，因为树的高度要远小于二叉树的高度。

结合B树的结构示意图，我们一起来看看B树是怎么进行搜索的，假设我们想要查找的关键字是9，那么步骤可以分为以下几步：

- 首先与根节点的关键字（17,35）进行比较，9小于17那么得到的指针P1；
- 其次，按照指针P1找到磁盘块2，关键字为（8,12），因为9位于8和12之间，所以我们可以得到指针P2；
- 最后，根据指针P2我们可以找到磁盘块6，关键字为（9,10），然后我们找到了关键字9。



我们可以看出，在B树的搜索过程中，我们比较的次数并不少，但是如果我们将数据读取出来然后在内存中进行比较，那么这个时间就可以忽略不计。**而读取磁盘块本身需要进行`I/O`操作，消耗的时间比在内存中进行比较所需要的时间要多**，**是数据查找用时的重要因素**，B树相比于平衡二叉树来说磁盘的`I/O`次数要少，查询数据的效率要高。



### B树Plus（B+树）

1. B+树是基于B树改良过来的，目前主流的数据库都支持B+树作为索引方式，我们以`MySql`为例，对比一下B+树和B树的区别：
2. B+树中有k个孩子的节点，就有k个关键字。也就是**孩子数量=关键字数量**。而B树中，**孩子数量=关键字数量+1**。
3. 非叶子节点的关键字也会同时存在子节点上，并且是在子节点中所有关键字的最大（或最小）。
4. B+树中，非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。而B树中，非叶子节点既保存索引，也保存数据记录。

所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大小从小到大的顺序链接。

下图就是一棵B+树，阶数为3，根节点的关键字为1、18、35分别就是子节点（1,8,14）、（18,24,31）和（35,41,53）中的最小值。每一层父节点的关键字都会出现在下一层的子节点的关键字中，因此在叶子节点中包括了所有的关键字信息，并且每一个叶子节点都有一个指向下一个叶子节点的指针，这样就形成了链表。

![img](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306101039484.png)

比如，我们想要查找关键字16，B+树就会自顶向下逐层查找：

1. 与根节点的关键字（1,18,35）进行比较，16在1和18之间，得到指针P1（指向磁盘块2）
2. 找到磁盘块2，关键字为（1,8,14），因为16大于14，所以得到指针P3（指向磁盘块7）
3. 找到磁盘块7，关键字为（14,16,17），然后我们找到了关键字16，所以可以找到关键字16对应的数据。



整个过程中一共进行了3次 `I/O`操作，看起来B+树和B树差不多，但是B+树和B树有着根本的区别：B+树的中间节点并不直接存放数据，这样做的好处就是：

- B+树的查询效率更稳定。因为B+树每次只有访问到叶子节点才能找到数据，而在B树中，非叶子节点也存储了数据信息，因此就会造成查询效率不稳定的情况，有时候访问到了非叶子节点就找到了关键字，有的时候需要访问到叶子节点才能找到关键字。
- B+的查询效率高，这是因为通常B+树比B树更矮胖（阶数更大，深度更低），查询所需要的磁盘 `I/O`也会更少。**同样的磁盘页大小，B+树可以存储更多的节点关键字**。
- 除了对单个单词的查询上效率高，在查询范围上，B+树的效率比B树的效率更高。这是因为所有的关键字都出现在B+树的叶子节点中，并通过了有序链表进行连接。而在B树中则需要通过中序遍历才能完成查询范围的查找，效率要低很多



磁盘的 `I/O`操作次数对索引的使用效率至关重要。虽然传统的二叉树数据结构查询数据的效率高，但是很容易造成磁盘 `I/O`操作次数过多的情况，影响索引使用的效率。因此在构造索引的时候我们更倾向于采用“矮胖”的数据结构。

B数和B+树都可以作为索引的数据结构，在`MySql`中采用的是B+树，B+树在查找性能上更稳定，在磁盘页大小相同的情况下，B+树的构造更加矮胖，所需要的磁盘 `I/O`次数更少，更适合进行关键字的范围查询。

































