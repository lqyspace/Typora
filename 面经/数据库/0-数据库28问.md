# B树与B+树的区别，为什么MySQL使用B+树？

B树的特点：

- 节点排序
- 一个节点可以存多个元素，多个元素也被排序了

B+树的特点：

- 继承了B树的特点
- 叶子节点之间有指针
- 非叶子节点上的元素在叶子节点上有冗余，也就是叶子结点存储了所有的元素，并且排好了顺序。
- MySQL里面，B+树的非叶子节点其实都是提前存到内存里面，所以真正的就是进行了一次磁盘I/O

MySQL索引使用的是B+树，使用B+树对数据进行排序可以提高查询速度，又因为一个页通常可以存很多的元素，因此一颗B+树的高度并不会太高。在MySQL中一个Innodb也就是一颗B+树，一个Innodb页默认的大小是16kb，所以一般情况下一颗三层的B+树可以存储2000万行数据，然后通过利用B+树叶子结点存储了所有数据并且进行了排序，并且叶子节点之间有指针，可以很好的进行全表扫描，范围查询等。

![image-20230917101524893](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202309171015039.png)

![image-20230917082145109](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202309170821309.png)

## MYISAM存储引擎索引实现

![image-20230917083412791](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202309170834962.png)

myISAM存储是以三种文件格式存储的，分别是 `.frm` 文件，`.MYD` 文件，`.MYI` 文件：

- frm文件存储的是表结构
- myd文件存储的是表的数据
- myi文件存储的是表的索引
- 索引文件和数据文件是分离的

MYISAM是非聚集索引的，区分是否是聚集索引主要看叶节点是否包含了完整的数据记录。由于MYISAM的表索引和记录是分开存储的，因此是非聚集索引。

图中的实例的select语句会根据索引列查找到数据对应的地址，然后再根据地址是myd里面查找数据，这个过程就相当于回表。



## Innodb存储引擎实现方式

![image-20230917085137397](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202309170851609.png)

- 如果查询条件是聚集索引，那么就可以根据索引查询到索引行的全部数据，如果查询条件不是聚集索引，那么就根据非聚集索引查询到对应的索引，然后再去聚集索引里面查询数据，这个过程就是回表的过程。

- 为什么建议使用Innodb表必须建主键：因为Innodb表需要使用B+树来组织整张表的数据，B+树需要使用索引结构来维护整张表的数据。如果表中不建任何主键索引的话，那么B+树就会先找你这张表的第一个唯一索引，把这个唯一索引作为B+树的索引。如果既没有主键索引也没有唯一索引，那么MySQL就会使用隐藏列RowId来建立一个B+树来存储整张表的数据，但是Rowid并不开放，无法使用，没法根据索引查找数据。而且用主键查找效率更高，因此建议Innodb表必须建主键。

- 为什么推荐使用整型的自增主键：使用整型的索引查找效率高，而且整型的存储空间比较小（比UUID小）；

- 为什么自增主键：UUID是字符串，是不自增的；如果不设置自增索引的话，你在插入数据的时候，有可能插入到B+树的中间位置，就可能导致B+分裂，有可能导致B+树层数变高，然后这些操作都是消耗性能的；而使用自增的主键，将数据插入到B+树的时候效率会更高，直接完后插入，就很少会出现分裂的情况。

  ![image-20230917090813549](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202309170908690.png)



## 工作中常使用联合索引

![image-20230917101644263](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202309171016424.png)

联合索引不是主键索引，是二级索引或普通索引。

```MySQL
explain select * from test where name='bilibil' and age=12;
explain select * from test where age=30 and position='dev';
explain select * from test where position='dev';

# 上面三个语句只有第一个语句会走联合索引，有一个最左前缀法则，如果要有联合索引，那就得从第一个索引开始用
# 假设索引是name和position，会走联合索引，但是name会走索引，但是position走不了索引，因此position跳过了age，变成无序的了
```

- 最左前缀原则的原理
  - 这个跟联合索引的B+树的构建有关，B+树在构建时，会先排序第一个索引，第一个索引相同时，再排序第二个索引，以此类推。
  - 假设不走第一个索引，当age=30是，那么就无法连续的遍历age=30的节点，因为age=30的节点都被分开了
  - 在name有序的前提下，age是有序的，这样才能高效的利用索引。如果不能排好序，那么就不能高效地利用索引。
- 数据库底层表关联的底层原理
  - 大厂里面一般禁止多表关联，因为多表关联性能是不好优化的。他们一般的做法是拆成多个SQL语句执行，然后把数据在java里面进行封装，性能是比较好优化的。

# MySQL锁有哪些，如何理解？

按粒度分类：

- 行锁：锁某行数据，锁粒度最小，并发度最高
- 表锁：锁整张表，锁粒度最大，并发度低
- 间隙锁：锁的是一个区间

还可以分为：

- 共享锁：也就是读锁，一个事务给某行数据加了锁，其他事务可以读，但是不能写
- 排它锁：也就是写锁，一个事务给某行加了锁，其他事物不能读，也不能写

还可以分为：

- 乐观锁：并不会真正的去锁某行记录，而是通过一个版本号来实现的
- 悲观锁：例如行锁，表锁都是悲观锁

在事务的隔离级别中就需要锁来解决幻读



# MySQL慢查询该如何优化

- 检查是否走了索引，如果没有则优化SQL利用索引
- 检查所利用的索引，是否是最优索引
- 检查所查字段是否都是必须的，是否查询了过多数据，查处了多余的数据
- 检查表中数据是否过多，是否应该进行分库分表
- 检查数据库实例所在机器的性能配置，是否太低，是否可以适当增加资源



# 索引的基本原理

所引用来快速的寻找那些具有特定值的记录，如果没有索引，一般来说执行查询时需要遍历整张表。

索引的原理：把无序的数据变成有序的查询

- 把创建了索引的列的内容进行排序
- 对排序结果生成倒排表
- 在倒排内容上拼上数据地址链
- 在查询的时候，先拿出倒排表内容，再取出数据地址链，从而拿到具体数据。





# 索引覆盖是什么

索引覆盖就是一个SQL语句在执行时，可以利用索引实现快速的查找，并且此SQL所要查询的字段在当前索引对应的字段中都包含了，那么就表示此SQL语句执行完就不用回表了，所需要的字段都在当前索引的叶子节点上，可以直接作为结果返回。





# 最左前缀原则是什么

当一个SQL想要利用索引时，就一定要提供该索引所对应的字段中最左边的的字段，也就是最前面的字段，比如针对a，b，c三个字段建立联合索引，那么在写SQL语句时就一定要提供a字段的条件，这样才能用到联合索引，这是由于在建立联合索引时，底层的B+树是按照a，b，c三个字段从左到右去比较大小进行排序的，所以要想利用B+树进行快速的查找也得使用这个规则。



# Innodb是如何实现事务的

Innodb是通过Buffer Pool，LogBuffer，Redo Log，Undo Log来实现事务的，以一个update语句为例：

1、Innodb收到一个update的语句后，会先根据条件找到数据所在的页，并将该页缓存在Buffer Pool中

2、执行update语句，修改Buffer Pool中的数据，也就是内存中的数据

3、指针update语句生成一个Redo Log对象，并存入LogBuffer中

4、针对update语句生成undolog日志，用于事务回滚

5、如果事务提交，那么则把RedoLog对象进行持久化，后续还有其他的机制将Buffer Pool中所修改的数据页持久化到磁盘中

6、如果事务回滚，则利用undolog日志进行回滚



# 雪花算法的原理

SnowFlake是Twitter公司采用的一种算法，目的是在分布式系统中产生全局唯一且趋势递增的ID。

![image-20230917114447651](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202309171144714.png)

第一位符号位固定为0, 41位时间戳，10位workid，12位序列号，位数可以有不同的实现。

优点：每个毫秒值包含的ID很多，不够可以变动位数来增加，性能佳（依赖workid的实现）。时间戳值在高位，中间是固定的机器码，自增的序列在低位，整个ID是趋势递增的，能够根据业务场景数据库节点布置灵活调整bit位划分，灵活度高

缺点：强依赖与机器时钟，如果时钟回拨，会导致重复的ID生成，所以一般基于此的算法发现时钟回拨，都会抛出异常处理，阻止ID生成，这可能导致服务不可用。

java的具体实现：

```java
public class SnowflakeIdWorker {
    /**
     * 开始时间截 (2015-01-01)
     */
    private final long twepoch = 1420041600000L;
    /**
     * 机器id所占的位数
     */
    private final long workerIdBits = 5L;
    /**
     * 数据标识id所占的位数
     */
    private final long datacenterIdBits = 5L;
    /**
     * 支持的最大机器id，结果是31 (这个移位算法可以很快的计算出几位二进制数所能表示的最大十进制数)
     */
    private final long maxWorkerId = -1L ^ (-1L << workerIdBits);
    /**
     * 支持的最大数据标识id，结果是31
     */
    private final long maxDatacenterId = -1L ^ (-1L << datacenterIdBits);
    /**
     * 序列在id中占的位数
     */
    private final long sequenceBits = 12L;
    /**
     * 机器ID向左移12位
     */
    private final long workerIdShift = sequenceBits;
    /**
     * 数据标识id向左移17位(12+5)
     */
    private final long datacenterIdShift = sequenceBits + workerIdBits;
    /**
     * 时间截向左移22位(5+5+12)
     */
    private final long timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits;
    /**
     * 生成序列的掩码，这里为4095 (0b111111111111=0xfff=4095)
     */
    private final long sequenceMask = -1L ^ (-1L << sequenceBits);
    /**
     * 工作机器ID(0~31)
     */
    private long workerId;
    /**
     * 数据中心ID(0~31)
     */
    private long datacenterId;
    /**
     * 毫秒内序列(0~4095)
     */
    private long sequence = 0L;
    /**
     * 上次生成ID的时间截
     */
    private long lastTimestamp = -1L;
    /**
     * 构造函数
     * @param workerId     工作ID (0~31)
     * @param datacenterId 数据中心ID (0~31)
     */
    public SnowflakeIdWorker(long workerId, long datacenterId) {
        if (workerId > maxWorkerId || workerId < 0) {
            throw new IllegalArgumentException(String.format("worker Id can't be greater than %d or less than 0", maxWorkerId));
        }
        if (datacenterId > maxDatacenterId || datacenterId < 0) {
            throw new IllegalArgumentException(String.format("datacenter Id can't be greater than %d or less than 0", maxDatacenterId));
        }
        this.workerId = workerId;
        this.datacenterId = datacenterId;
    }
    /**
     * 获得下一个ID (该方法是线程安全的)
     * @return SnowflakeId
     */
    public synchronized long nextId() {
        long timestamp = timeGen();
        // 如果当前时间小于上一次ID生成的时间戳，说明系统时钟回退过这个时候应当抛出异常
        if (timestamp < lastTimestamp) {
            throw new RuntimeException(
                    String.format("Clock moved backwards.  Refusing to generate id for %d milliseconds", lastTimestamp - timestamp));
        }
        // 如果是同一时间生成的，则进行毫秒内序列
        if (lastTimestamp == timestamp) {
            sequence = (sequence + 1) & sequenceMask;
            // 毫秒内序列溢出
            if (sequence == 0) {
                //阻塞到下一个毫秒,获得新的时间戳
                timestamp = tilNextMillis(lastTimestamp);
            }
        }
        // 时间戳改变，毫秒内序列重置
        else {
            sequence = 0L;
        }
        // 上次生成ID的时间截
        lastTimestamp = timestamp;
        // 移位并通过或运算拼到一起组成64位的ID
        return ((timestamp - twepoch) << timestampLeftShift) //
                | (datacenterId << datacenterIdShift) //
                | (workerId << workerIdShift) //
                | sequence;
    }
    /**
     * 阻塞到下一个毫秒，直到获得新的时间戳
     * @param lastTimestamp 上次生成ID的时间截
     * @return 当前时间戳
     */
    protected long tilNextMillis(long lastTimestamp) {
        long timestamp = timeGen();
        while (timestamp <= lastTimestamp) {
            timestamp = timeGen();
        }
        return timestamp;
    }
    /**
     * 返回以毫秒为单位的当前时间
     * @return 当前时间(毫秒)
     */
    protected long timeGen() {
        return System.currentTimeMillis();
    }

    public static void main(String[] args) throws InterruptedException {
        SnowflakeIdWorker idWorker = new SnowflakeIdWorker(0, 0);
        for (int i = 0; i < 10; i++) {
            long id = idWorker.nextId();
            Thread.sleep(1);
            System.out.println(id);
        }
    }
}
```



# 什么是MVCC

MVCC（Multi-Version Concurrency Control，多版本并发控制）指的就是在使用read committed，repeatable read这两种隔离级别的事务在执行普通的select操作时，访问记录的版本链的过程，可以使用不同事务的读写，写读操作并发执行，从而提升系统的性能。read committed，repeatable read这两个隔离级别的一个很大不同就是：生成readview的时机不同，read committed在每一次进行普通select操作前都会生成一个readview，而repeatable read只在第一次进行普通select操作前生成一个readview，之后的查询操作重复使用这个readview就好。





# 简述MyISAM和Innodb的区别

MyISAM：

- 支持事务，但是每次查询都是原子的
- 支持表级锁，即每次操作都是对整个表进行加锁
- 存储表的总行数
- 一个MYISAM表有三个文件：索引文件，表结构文件，数据文件
- 采用非聚集索引，索引文件的数据域存储指向数据文件的指针。辅索引与主索引基本一致，但是辅索引不用保证唯一性

Innodb：

- 支持ACID的事务，支持事务的四种隔离级别
- 支持行级锁以及外键约束；因此可以支持写并发；
- 不存储总行数
- 一个Innodb引擎存储在一个文件空间（共享表空间，表大小不受操作系统控制，一个表可能分布在多个文件里），也有可能为多个（设置为独立表空，表大小受操作系统文件大小限制，一般为2G），受操作系统文件大小的限制；
- 主键索引采用聚集索引（索引的数据域存储数据文件本身），辅索引的数据域存储主键的值；因此从辅索引查找数据，需要先通过辅索引找到主键值，再访问主索引；最好使用自增索引，防止插入数据时，为维持B+树结构而产生的性能开销。





# 事务的基本特性和隔离级别

事务的基本特性ACID：

- 原子性
- 一致性
- 隔离性
- 持久性

4个隔离级别：

- read uncommitted：会产生脏读，不可重复读，幻读
- read committed：解决脏读，会产生不可重复读，幻读
- repeatable read：解决脏读，不可重复读，会产生幻读
- serializable：序列化，解决所有问题



# explain语句结果中各个字段分别代表什么

![image-20230917141133607](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202309171411687.png)



