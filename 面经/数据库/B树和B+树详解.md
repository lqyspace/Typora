# B树

## 前言

最近在学习数据库索引调优的相关知识，数据库系统普遍采用B树/B+树作为索引结构（例如`MySQL`的`InnoDB`引擎使用的B+树），理解不透B树，则无法理解数据库的索引机制

另外，B-树，即为B树。因为B树的原因文名称为B-tree，而国内很多人喜欢把B-tree翻译为B-树，其实，这是一个非常不好的直译，很容易让人产生误解。比如很多人会误以为B-树是一种树，而B树又是另外一种树。事实上，B-tree就是指B树，英文为 Balance-Tree

B树的出现是为了弥合不同的存储级别之间的访问速度上的巨大差异，实现高效的 `I/O`。平衡二叉树的查找效率是非常高的，并可以通过降低树的深度来提高查找的效率。但是当数据量非常大时，树的存储的元素数量是有限的，这样会导致二叉查找树结构由于树的深度过大而造成磁盘 `I/O`读写过于频繁，进而导致查询效率低下。另外数据量过大也会导致内存空间不够容纳平衡二叉树所有节点的情况。因此，B树是解决这个问题的很好的结构



## 概念

首先，B树不要和二叉树混淆，在[计算机科学中](https://en.wikipedia.org/wiki/Computer_science)，**B树**是一种自平衡[树数据结构](https://en.wikipedia.org/wiki/Tree_data_structure)，它维护**有序数据**并允许以[对数时间](https://en.wikipedia.org/wiki/Logarithmic_time)进行搜索，顺序访问，插入和删除。B树是[二叉搜索树](https://en.wikipedia.org/wiki/Binary_search_tree)的一般化，因为节点可以有两个以上的子节点。[[1\]](https://en.wikipedia.org/wiki/B-tree#cite_note-Comer-1)与其他[自平衡二进制搜索树不同](https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree)，B树非常适合读取和写入相对较大的数据块（如光盘）的存储系统。它通常用于[数据库](https://en.wikipedia.org/wiki/Database)和[文件系统](https://en.wikipedia.org/wiki/File_system)。



------

最优搜索二叉树与B+树的区别：

- OBST查找过程：将一个节点读进内存，通过与目标值进行比较从而确定查左子树或右子树；B+树的查询过程：将一个节点读进内存，节点中存储索引和指向索引的指针，通过与节点中的索引比较，获取相应的索引的指针，从而确定下一个节点的位置。
- OBST是二叉搜索树，B+树是多路搜索树，对于同数据量的情况下，OBST瘦高，B+树矮胖，因此OBST访存次数更多。
- OBST维护的是平均查找期望最小的树，B+树维护有序数据并以对数时间进行搜索，并没有考虑单词出现的概率。
- OBST适用于：查找的关键字具有一定的概率，有的关键字可能经常被搜索，而有的很少被搜索，而且搜索的关键字可能不存在，为此需要根据关键字出现的概率构建一个二叉树。比如中文输入法字库中各词条（单字、词组等）的先验概率，针对用户习惯可以自动调整词频——所谓动态调频、高频先现原则，以减少用户翻查次数，使得经常用的词汇被放置在前面，这样就能有效地加快查找速度。这就是最优二叉树所要解决的问题。
- B+树适用于百万数据量的情况，不考虑单词出现的概率，数据都是按照顺序进行排序，目前主要用于 MySQL数据库的索引机制。



我的考虑：将查词的任务交给OBST，每个单词所依赖的信息用Mysql保存。这样能节省内存开销。

---





## 定义

B树是一种平衡的多叉树，通常我们说m阶的B树，它必须满足如下条件：

- 每个节点最多只有m个子节点
- 每个非叶子节点（除根节点）具有至少 m/2 子节点（向上取整：比自己大的最小整数）
- 如果根不是叶节点，则根至少有两个子节点
- 具有k个子节点的非叶节点包含 `k-1` 个键
- 所有叶节点必须处于同一级别



## 什么是B树的阶？

B树中一个节点的子节点数目的最大值，用m表示，即为B树的阶，假如最大值为4，则为4阶。如图：

![img](https://github.com/wardseptember/notes/raw/master/imgs/20200926202114.png)

所有节点中，节点[13, 16, 19] 拥有的子节点数目最多，四个子节点（灰色节点）所以可以定义上面的图片为4阶B树

### 什么是根节点？

节点[10] 即为根节点，特征：根节点拥有的子节点的数量上限和内部节点相同，如果根节点不是树中唯一节点的话，至少有两个子节点（不然就变成单支了）。在m阶B树中（根节点非树中唯一节点），那么有关系式：$2<=M<=m$ ，$M$为子节点数量；包含元素的数量，也就是关键字的数量$1<=K<=m-1$，$K$为元素数量。

### 什么是内部节点？

节点[13, 16, 19]、[3, 6]都为内部节点，特征：**内部节点是除叶子节点和根节点之外的所有节点**，拥有父节点和子节点。假定m阶B树的内部节点的子节点数量为M，则一定要符合$(m/2)<=M<=m$关系式，包含元素数量M-1；包含的元素数量K符合$(m/2-1)<=K<=m-1$，$m/2$向上取整。

### 什么是叶子节点？

节点【1,2】、节点【11,12】等最后一层都为叶子节点，叶子节点对元素的数量有相同的限制，但是没有子节点，也没有指向子节点的指针。特征：在m阶B树中叶子节点的元素符合$（m/2）-1<= K <=m-1$。

## 插入

针对m阶高度h的B树，插入一个元素时，首先检查在B树中是否存在，如果不存在，即在叶子节点处结束，然后在叶子结点中插入该新的元素。

- 若该节点元素个数小于m-1，直接插入；
- 若该节点元素个数等于m-1，引起节点分裂：以该节点中间元素为分界，取中间元素（偶数个数，中间两个随机选取）插入到父节点中；
- 重复上面动作，直到所有节点符合B树的规则；最坏的情况一直分裂到根节点，生成新的根节点，高度增加1；

上面三段话为插入动作的核心，接下来以5阶B树为例，详细讲解插入的动作；

5阶B树关键点:

- 2<=根节点子节点个数<=5
- 3<=内节点子节点个数<=5
- 1<=根节点元素个数<=4
- 2<=非根节点元素个数<=4

![](https://github.com/wardseptember/notes/raw/master/imgs/20200926202239.png)

![img](https://github.com/wardseptember/notes/raw/master/imgs/20200926202335.png)

插入8 

图（1）插入元素【8】后变为图（2），此时根节点元素个数为5，不符合 1<=根节点元素个数<=4，进行分裂（真实情况是先分裂，然后插入元素，这里是为了直观而先插入元素，下面的操作都一样，不再赘述），取节点中间元素【7】，加入到父节点，左右分裂为2个节点，如图（3）

![img](https://raw.githubusercontent.com/wardseptember/notes/master/imgs/20201030151640.png)

接着插入元素【5】，【11】，【17】时，不需要任何分裂操作，如图（4）

![img](https://github.com/wardseptember/notes/raw/master/imgs/20200926202722.png)

插入元素【13】

![img](https://github.com/wardseptember/notes/raw/master/imgs/20200926202810.png)

节点元素超出最大数量，进行分裂，提取中间元素【13】，插入到父节点当中，如图（6）

![img](https://github.com/wardseptember/notes/raw/master/imgs/20200926202839.png)

接着插入元素【6】，【12】，【20】，【23】时，不需要任何分裂操作，如图（7）

![img](https://github.com/wardseptember/notes/raw/master/imgs/20200926202910.png)

插入【26】时，最右的叶子结点空间满了，需要进行分裂操作，中间元素【20】上移到父节点中，注意通过上移中间元素，树最终还是保持平衡，分裂结果的结点存在2个关键字元素。

![img](https://github.com/wardseptember/notes/raw/master/imgs/20200926202928.png)

插入【4】时，导致最左边的叶子结点被分裂，【4】恰好也是中间元素，上移到父节点中，然后元素【16】,【18】,【24】,【25】陆续插入不需要任何分裂操作

![img](https://github.com/wardseptember/notes/raw/master/imgs/20200926202952.png)

最后，当插入【19】时，含有【14】,【16】,【17】,【18】的结点需要分裂，把中间元素【17】上移到父节点中，但是情况来了，父节点中空间已经满了，所以也要进行分裂，将父节点中的中间元素【13】上移到新形成的根结点中，这样具体插入操作的完成。

![img](https://github.com/wardseptember/notes/raw/master/imgs/20200926203022.png)



## 删除

首先查找B树中需删除的元素，如果该元素在B树中存在，则将该元素在其结点中进行删除；删除该元素后，首先判断该元素是否有左右孩子结点，如果有，则上移孩子结点中的某相近元素(“左孩子最右边的节点”或“右孩子最左边的节点”)到父节点中，然后是移动之后的情况；如果没有，直接删除。

- 某结点中元素数目小于（m/2）-1,(m/2)向上取整，则需要看其某相邻兄弟结点是否丰满；
- 如果丰满（结点中元素个数大于(m/2)-1），则向父节点借一个元素来满足条件；
- 如果其相邻兄弟都不丰满，即其结点数目等于(m/2)-1，则该结点与其相邻的某一兄弟结点进行“合并”成一个结点；

接下来还以5阶B树为例，详细讲解删除的动作；

- 关键要领，元素个数小于 2（m/2 -1）就合并，大于4（m-1）就分裂

如图依次删除【8】,【20】,【18】,【5】

![img](https://github.com/wardseptember/notes/raw/master/imgs/20200926203135.png)

首先删除元素【8】，当然首先查找【8】，【8】在一个叶子结点中，删除后该叶子结点元素个数为2，符合B树规则，操作很简单，咱们只需要移动【11】至原来【8】的位置，移动【12】至【11】的位置（也就是结点中删除元素后面的元素向前移动）

![img](https://github.com/wardseptember/notes/raw/master/imgs/20200926203202.png)

下一步，删除【20】,因为【20】没有在叶子结点中，而是在中间结点中找到，咱们发现他的继承者【23】(字母升序的下个元素)，将【23】上移到【20】的位置，然后将孩子结点中的【23】进行删除，这里恰好删除后，该孩子结点中元素个数大于2，无需进行合并操作。（这个地方移动【23】比较合适，因为如果移动【19】的话会导致【18】号为的节点元素数量小于2）

![img](https://github.com/wardseptember/notes/raw/master/imgs/20200926203219.png)

下一步删除【18】，【18】在叶子结点中,但是该结点中元素数目为2，删除导致只有1个元素，已经小于最小元素数目2,而由前面我们已经知道：如果其某个相邻兄弟结点中比较丰满（元素个数大于ceil(5/2)-1=2），则**可以向父结点借一个元素，然后将最丰满的相邻兄弟结点中上移最后或最前一个元素到父节点中**，在这个实例中，右相邻兄弟结点中比较丰满（3个元素大于2），所以先向父节点借一个元素【23】下移到该叶子结点中，代替原来【19】的位置，【19】前移；然【24】在相邻右兄弟结点中上移到父结点中，最后在相邻右兄弟结点中删除【24】，后面元素前移。

![img](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306101446793.png)



最后一步删除【5】， 删除后会导致很多问题，因为【5】所在的结点数目刚好达标，刚好满足最小元素个数（ceil(5/2)-1=2）,而相邻的兄弟结点也是同样的情况，删除一个元素都不能满足条件，所以需要该节点与某相邻兄弟结点进行合并操作；首先移动父结点中的元素（该元素在两个需要合并的两个结点元素之间）下移到其子结点中，然后将这两个结点进行合并成一个结点。所以在该实例中，咱们首先将父节点中的元素【4】下移到已经删除【5】而只有【6】的结点中，然后将含有【4】和【6】的结点和含有【1】,【3】的相邻兄弟结点进行合并成一个结点。 （在选择父节点的元素，可以按照从左到右的原则进行可）

![img](https://github.com/wardseptember/notes/raw/master/imgs/20200926203302.png)

也许你认为这样删除操作已经结束了，其实不然，在看看上图，对于这种特殊情况，你立即会发现父节点只包含一个元素【7】，没达标（因为非根节点包括叶子结点的元素K必须满足于2=<K<=4，而此处的K=1），这是不能够接受的。如果这个问题结点的相邻兄弟比较丰满，则可以向父结点借一个元素。而此时兄弟节点元素刚好为2，刚刚满足，只能进行合并，而根结点中的唯一元素【13】下移到子结点，这样，树的高度减少一层。 

![img](https://github.com/wardseptember/notes/raw/master/imgs/20200926203320.png)

看完插入，删除，想必也把B树的特征掌握了。



## 磁盘IO和预读

计算机存储设备一般分为两种：内存储器(main memory)和外存储器(external memory)。

内存储器为内存，内存存取速度快，但容量小，价格昂贵，而且不能长期保存数据(在不通电情况下数据会消失)。

外存储器即为磁盘读取，磁盘读取数据靠的是机械运动，每次读取数据花费的时间可以分为寻道时间、旋转延迟、传输时间三个部分，寻道时间指的是磁臂移动到指定磁道所需要的时间，主流磁盘一般在5ms以下；旋转延迟就是我们经常听说的磁盘转速，比如一个磁盘7200转，表示每分钟能转7200次，也就是说1秒钟能转120次，旋转延迟就是1/120/2 = 4.17ms；传输时间指的是从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒，相对于前两个时间可以忽略不计。那么访问一次磁盘的时间，即一次磁盘IO的时间约等于5+4.17 = 9ms左右，听起来还挺不错的，但要知道一台500 -MIPS的机器每秒可以执行5亿条指令，因为指令依靠的是电的性质，换句话说执行一次IO的时间可以执行450万条指令，数据库动辄十万百万乃至千万级数据，每次9毫秒的时间，显然是个灾难。下图是计算机硬件延迟的对比图，供大家参考：

![img](https://github.com/wardseptember/notes/raw/master/imgs/20200926210045.png)

考虑到磁盘IO是非常高昂的操作，计算机操作系统做了一些优化，当一次IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内，因为局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。每一次IO读取的数据我们称之为一页(page)。具体一页有多大数据跟操作系统有关，一般为4k或8k，**也就是我们读取一页内的数据时候，实际上才发生了一次IO**，这个理论对于索引的数据结构设计非常有帮助。

事实1 ： 不同容量的存储器，访问速度差异悬殊。

- 磁盘(ms级别) << 内存(ns级别)， 100000倍
- 若内存访问需要1s，则一次外存访问需要一天
- 为了避免1次外存访问，宁愿访问内存100次...所以将`最常用`的数据存储在最快的存储器中

事实2 ： 从磁盘中读 1 B，与读写 1KB 的时间成本几乎一样

从以上数据可以总结出一个道理，索引查询的数据主要受限于硬盘的 `I/O`速度，查询 `I/O`次数越少，速度越快，所以B树的结构才应需求而生；B树的每一个节点的元素可以视为一次 `I/O`读取，树的高度表示最多的 `I/O`次数，在相同数量的总元素个数下，每个节点的元素个数越多，高度越低，查询所需要的 `I/O`次数越少；假设一个磁盘一次`I/O`数据为8K，索引用int(4字节)类型数据建立，理论上一个结点最多可以存储2K个元素。如果读取80亿（200\*200\*200）条数据的话，仅需要3次 `I/O`即可。可想而知，B树的查询效率有多高。



## B树的高度

![img](https://github.com/wardseptember/notes/raw/master/imgs/20200926210134.png)



## B树的应用

B树用于索引数据并提供对存储在磁盘上的实际数据的快速访问，因为存储在磁盘上的大型数据库中存储的值的访问是非常耗时的过程。
在最坏的情况下，搜索包含`n`个键值的未索引和未排序的数据库需要`O(n)`运行时间。 但是，如果使用B树来索引此数据库，则在最坏的情况下将在`O(log n)`时间内搜索它。 //更多请阅读：https://www.yiibai.com/data_structure/b-tree.html 





# B+树

B+树是应文件系统需要而生的B树的变形树。

**B+树的特征 ：**

- 有m个子树的中间节点包含有m个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引；
- 所有的叶子节点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身以关键字的大小自小而大的顺序链接。（而B树叶子结点并没有包括全部需要查找的信息）
- 所有的非终节点可以看成是索引部分，节点中仅包含其子树根节点中最大（或最小）关键字。（而B树的非终节点也包含需要查找的有效信息）；



**为什么说B+树比B树更适合数据索引呢？**

1. B+树的磁盘读写代价更低

   B+树内部结构并没有指向关键字具体信息的指针。因此其内部点相对B树更小。如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量更多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数就降低了。

2. B+树查询效率更稳定

   B+树由于非终节点并不是最终指向文件内容的节点，而只是叶子节点中关键字的索引。所以任何关键字的查找必须从根节点走到叶子节点。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。

3. B+树便于范围查询（最重要的原因是，范围查询是数据库的常态）

   B树在提高IO性能的同时并没有解决元素遍历的效率低下的问题，正是为了解决这个问题。B+是应运而生，B+树只需要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围查询是非常频繁的，而B树不支持这样的操作或者说效率太低了；不懂可以看看这篇解读-》[范围查找](https://zhuanlan.zhihu.com/p/54102723)

   补充：B树的范围查找用的是中序遍历，而B+树用的是链表上的遍历；

B+树如下：

![img](https://github.com/wardseptember/notes/raw/master/imgs/20200926212656.png)

![img](https://github.com/wardseptember/notes/raw/master/imgs/20200926212831.png)

![img](https://github.com/wardseptember/notes/raw/master/imgs/20200926213019.png)

补充：

在数据库的聚集索引（Clustered Index）中，叶子节点直接包含卫星数据（Satellite Information）。在非聚集索引（NonClustered Index）中，叶子节点带有指向卫星数据（Satellite Information）的指针。

所谓卫星数据，就是索引元素所指向的数据记录，比如数据库中的某一行。在B-树中，无论中间节点还是叶子节点都带有卫星数据。





# 总结

B-树的卫星数据

![img](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306101825226.jpeg)

B+树的卫星数据

![img](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306101825476.webp)

![img](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306101827286.jpeg)

![img](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306101827078.jpeg)

![img](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306101827617.jpeg)

第一次磁盘IO：

![img](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306101828761.webp)

第二次磁盘IO：

![img](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306101828123.webp)

第三次磁盘IO：

![img](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306101828942.jpeg)

![img](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306101829434.jpeg)

![img](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306101829129.webp)

![img](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306101829789.jpeg)

![img](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306101829477.jpeg)

![img](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306101829668.jpeg)

![img](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306101830839.jpeg)

**B-树的范围查找过程**

自顶向下，查找到范围的下限（3）：

![img](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306101830351.jpeg)

中序遍历到元素6：

![img](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306101831422.jpeg)

中序遍历到元素8：

![img](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306101831009.jpeg)

中序遍历到元素9：

![img](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306101832029.jpeg)

中序遍历到元素11，遍历结束：

![img](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306101832229.jpeg)

![img](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306101832067.jpeg)

**B+树的范围查找过程**

自顶向下，查找到范围的下限（3）：

![img](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306101833360.jpeg)

通过链表指针，遍历到元素6, 8：

![img](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306101833347.jpeg)

通过链表指针，遍历到元素9, 11，遍历结束：

![img](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306101833222.jpeg)

![img](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306101833575.webp)

![img](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306101833349.jpeg)

**B+树的特征：**

1.有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。



2.所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。



3.所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。





**B+树的优势：**

1.单一节点存储更多的元素，使得查询的IO次数更少。



2.所有查询都要查找到叶子节点，查询性能稳定。



3.所有叶子节点形成有序链表，便于范围查询。





















