[TOC]

# 十进制与其他进制的相互转换

## 1. 使用内置函数进行进制转换

### 1.1 十进制转其他进制

在`java`函数中，Integer类中已经有相应函数可以进行十进制 与 二进制，八进制和十六进制的转换。

```java
// 十进制转二进制
Integer.toBinaryString(int i);
// 十进制转八进制
Integer.toOctalString(int i);
// 十进制转十六进制
Integer.toHexString(int i);
```

### 1.2 其他进制转十进制

```java
// 二进制转十进制
Integer.valueOf("1011", 2).toString();
// 八进制转十进制
Integer.valueOf("177", 8).toString();
// 十六进制转十进制
Integer.valueOf("ABC", 16).toString();
```

使用`java`提供的函数我们只能进行二进制，八进制，十六进制和十进制之间的转换，这可能还不能满足我们的需求。



## 2. 模运算

可以使用离散数学中的模运算来进行进制的转换。

### 2.1 十进制到任意进制的转换

```java
public static String dec2Other(int n, int k){
    // 存放取模的栈
    Stack<Integer> stk = new Stack<>();
    // 存储结果串
    StringBuffer res = new StringBuffer("");
    // 对十进制进制取模运算,余数压栈
    while(n!=0){
        int mod = n%k;
        if(mod>=10){
            stk.push(String.valueOf((char)(n%k - 10 + 'A')));
        }else{
            stk.push(String.valueOf(n%k));
        }
        stk.push(n%k);        
    }
    // 取结果
    while(!stk.isEmpty()){
        res.append(stk.pop());
    }
    return res.toString();
}
```



### 2.2 任意进制转为十进制

```java
public static int other2Dec(String num, int k){
    // 最终产生的结果
    int res = 0;
    // 用来记录个位，十位，百位，千位
    int flag = 0;
    // 从末尾一直遍历整个字符串，也就是从个位开始
    for(int i=num.length()-1; i>=0; i--){
        // 记录该位置上的值
        int value = num.charAt(i);
        // 记录此位置的单位大小
        int unit = (int)Math.pow(k, flag++);
        if(value >= 'A'){
            res += (value - 'A' + 10) * unit;
        }else{
            res += (value - '0') * unit;
        }
    }
    return res;
}
```



## 3 位运算

下面是`java`中的进行禁止转换的位运算源码。

我们首先来看看十进制转换为其他进制：

```java
public static String toBinaryString(int i){
    return toUnsignedString0(i, 1);
}
public static String toOctalString(int i){
    return toUnsignedString0(i, 3);
}
public static String toHexString(int i){
    return toUnsignedString0(i, 4);
}
```

我们再来看看内部 `toUnsignedString0(i, shift);` 调用的源码：

```java
private static String toUnsignedString0(int val, int shift){
    // assert shift>0 && shift <= 5 : "Illegal shift value";// 确保shift在1-5之间
    // Integer.SIZE: 32
    // numberOfLeadingZeros(val) 返回 val的最高位的前面有多少个0
    int mag = Integer.SIZE - Integer.numberOfLeadingZeros(val);
    // 返回val的最长长度
    int chars = Math.max(1, (mag + (shift - 1)) / shift);
    // 定义一个数组用于接收相应格式的字符
    char[] buf = new char[chars];
    
    formatUnsignedInt(val, shift, buf, 0, chars);
    
    return new String(buf, true); // 将字符变为字符串   
}
```

其中，`numberOfLeadingZeros(val)`的源码如下，以17这个数字为例，17对应的二进制为：00000000  00000000  00000000  00010001。

```java
public static int numberOfLeadingZeros(int i){
    if(i==0) return 32; // 如果i为0，那么最高位前面就有32个0
    int n = 1;// 如果不为0，那么i至少也有一位的数
    
    /*
    	首先将值无符号右移16位，数字17右移16位后：00000000 00000000 00000000 00000000
    	由此可知这个if语句是成立的，执行里面的代码后变为：00000000 00010001 00000000 00000000
    */
    if(i >>> 16 == 0){ n+=16; i <<= 16;}
    
    // 接下来将新的值无符号右移24位，右移后：00000000 00000000 00000000 00000000
    // 条件成立，n变为25，i有符号左移变为：00010001 00000000 00000000 00000000
    if(i >>> 24 == 0){n+=8; i <<= 8;}
    
    // 将新的值无符号右移28位，右移后：00000000 00000000 00000000 00000001
    // 条件不满足
    if(i >>> 28 == 0){n+=4; i <<= 4;}
    
    // 将新的值右移30位，右移30位后：00000000 00000000 00000000 00000000
    // 由此可知这个if语句条件成立，执行if里面的代码后 n=27 i有符号左移后
    // 01000100 00000000 00000000 00000000
    if(i >>> 30 == 0){n += 2; i <<= 2;}
    
    // 下面这个判断用于判断最高位是不是1，如果是1，则减1，只有负数的最高位才是1
    n -= i>>>31 ;
    // 最后这里返回n=27
    return n;    
}
```

`Integer.numberOfLeadingZeros(int val)`就分析完了，就是通过不断的移位运算来判断最高位前面有多少个零，看到这里的时候，我有个疑问，负数还有必要调用这个方法吗，因为最高位永远都是1，这个方法返回的总是0。不知道这样想是否有问题。



我们再来看看这个函数 `formatUnsignedInt(int val, int shift, char[] buf, int offset, int len)`：

```java
int charPos = len;
int radix = 1 << shift; // radix进制
int mask = radix - 1;// 进制下的最大的数
do{
    buf[offset + --charPos] = Integer.digits[val & mask];
}
```

