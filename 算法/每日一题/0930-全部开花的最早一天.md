# 2136-全部开花的最早一天

[2136-全部开花的最早一天](https://leetcode.cn/problems/earliest-possible-day-of-full-bloom/solutions/1202113/quan-bu-kai-hua-de-zui-zao-yi-tian-by-le-ocxg/)，难度困难，与[1665-完成所有任务的最少初始能量](https://leetcode.cn/problems/minimum-initial-energy-to-finish-tasks/) 类似

![image-20230930205949220](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202309302059367.png)

题解：贪心及其证明

为了方便叙述，我们将数组`plantTime`和`growTime`简写为`p`和`g`。

首先，我们可以发现，一定存在一种播种方法，是每次完整播种完一颗种子再接着播种下一颗种子的。

**需要交替播种吗？**

假设有两枚种子要播种，1号种子要播种3天，2号种子要播种2天。

- 如果播种顺序为11122，即先播种完1号种子，再播种2号种子，那么1号种子在第3天播种完毕，2号种子第5天播种完毕，完成播种共需要5天。
- 如果交替播种，比如12112，那么2号种子完成播种的时间是不变的，但是1号种子却推迟一天播种完成，这就导致1号种子花开的时间推迟了一天。

这就说明了如果要交替播种，至少有一枚种子的播种完成时间会被推迟，并且所有种子的完成播种的时间是不变的。也就是说，交替播种不仅没有得到任何帮助，反而会拖慢一些种子的播种进度，从而导致种子花开的最晚时间有可能被推迟。

所以说，不应该交替播种，应当种完一颗种子以后再去种另一颗。

**谁先播种？**

对于两枚种子，设其播种所需天数为`p1`，`p2`，生长所需天数为`g1`，`g2`；

不妨假设`g1>=g2`，我们来比较哪种播种顺序更优。

- 先播种1再播种2的最晚花开时间：

  $max\{p_1+g_1, p_1+p_2+g_2\}$

- 先2后1的最晚花开时间：

  $max\{ p_1+p_2+g_1, p_2+g_2 \}$

  由于$g_1>+g_2$ 且 $p_1>0$ ，所以 $p_1+p_2+g_1 > p_2+g_2$，上式可以化简为：$p_1+p_2+g_1$

  由于$p_1+g_1 < p_1+p_2+g_1$ 且 $p_1+p_2+g_2 <= p_1+p_2+g_1$，因此：$max\{ p_1+g_1, p_1+p_2+g_2 \} <= p_1+p_2+g_1 = max\{ p_1+p_2+g_1, p_2+g_2 \}$

上式表明，按照先1后2的顺序播种，最晚开花时间不会晚于先2后1的播种顺序的最晚开花时间。

这就意味着**按照生长天数从大到小排序**后，交换任意两枚种子的播种顺序，不会让最晚开花时间提前。

假设存在其他更优的种子排列，我们可以交换【生长天数小且排在前面的种子】与【生长天数大且排在后面，的种子】，从而得到更早的最晚开花时间，因此假设不成立，按照生长天数从大到小排列播种是最优的。

对于两枚生长天数相同的种子，由于无论按照何种顺序播种，这两枚种子的最晚开花时见都是相同的，因为整体的播种完成的时间是固定的。因此无需考虑生长天数相同的种子的播种顺序，在排序时，仅需按照生长天数从大到小排序即可。

```java
class Solution {
    public int earliestFullBloom(int[] plantTime, int[] growTime) {
        int n = plantTime.length;
        Integer[] idx = IntStream.range(0, n).boxed().toArray(Integer[]::new);
        Arrays.sort(idx, (i, j)->growTime[j] - growTime[i]);
        int prev = 0, ans = 0;
        for(int i: idx){
            ans = Math.max(ans, prev + plantTime[i] + growTime[i]);
            prev += plantTime[i];
        }
        retu
    }
}
```

