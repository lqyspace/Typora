# 318-最大单词长度乘积

[318-最大单词长度乘积](https://leetcode.cn/problems/maximum-product-of-word-lengths/?envType=daily-question&envId=2023-11-06)，难度中等

![image-20231106153028457](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202311061530532.png)

题解：**位运算**

为了得到最大单词长度的乘积，最朴素的做法就是，遍历字符串数组的每一对单词，判断这一对单词是否有公共单词，如果没有公共字母，则用这一对单词的长度乘积更新最大单词长度。

用$n$表示数组$words$的长度，用$l_i$表示单词$words[i]$的长度，其中$0<=i<=n$，则上述做法需要遍历字符串数组$words$中的每一对单词，对于下标为$i$和$i$的单词，其中$i<j$，需要$O(l_i \times l_j)$的时间判断是否有公共字母和计算长度乘积。因此上述做法的时间复杂度为$O(\sum_{0<=i<j<n}l_i \times l_j)$，该时间复杂度比$O(n^2)$高。

如果可以将判断两个单词是否有公共字母的时间复杂度降低到$O(1)$，则可以将总时间复杂度降到$O(n^2)$。可以使用位运算处理每个单词，通过位运算判断两个单词是否有公共字母。由于单词只包含小写字母，共有26个小写字母，因此可以使用位掩码的最低26位分别表示每个字母是否在这个单词中出现过。将$a$到$z$分别记为第0个字母到第25个字母，则位掩码的从低到高的第$i$位是1当且仅当这个字母在这个单词中，其中$0<=i<=25$。

用数组$masks$记录每个单词的位掩码表示。计算数组$masks$之后，判断第$i$个单词和第$j$个单词是否有公共字母而可以通过判断$masks[i]\& masks[j]$是否等于0实现，当且仅当$masks[i] \& masks[j] == 0$时第$i$个单词和第$j$个单词不会出现公共字母，此时使用两个单词的长度来更新最大单词乘积。

```java
class Solution {
    public int maxProduct(String[] words) {
        int n = words.length;
        int[] masks = new int[n];
        for(int i=0; i<n; i++){
            String word = words[i];
            for(int j=0; j<word.length(); j++){
                masks[i] |= (1<<(word.charAt(j)-'a'));
            }
        }

        int max = 0;
        for(int i=0; i<n; i++){
            for(int j=i+1; j<n; j++){
                if((masks[i]&masks[j])==0){
                    max = Math.max(max, words[i].length() * words[j].length());
                }
            }
        }
        return max;
    }
}
```

> 时间复杂度：$O(L + n^2)$，其中$L$是所有单词的长度和，$n$是数组的长度。
>
> 空间复杂度：$O(n)$



题解2：**位运算优化**

![image-20231106185802428](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202311061858490.png)

```java
class Solution {
    public int maxProduct(String[] words) {
        int n = words.length;
        Map<Integer, Integer> map = new HashMap<>();
        for(int i=0; i<n; i++){
            int mask = 0;
            String word = words[i];
            for(int j=0; j<word.length(); j++){
                mask |= (1<<(word.charAt(j)-'a'));
            }
            // if (wordLength > map.getOrDefault(mask, 0)) {
            //    map.put(mask, wordLength);
            // }// 此方法也可以
            if(map.containsKey(mask)){
                if(map.get(mask) < word.length()){
                    map.put(mask, word.length());
                }
            }else{
                map.put(mask, word.length());
            }
        }

        int max = 0;
        for(int mask1: map.keySet()){
            for(int mask2: map.keySet()){
                if(( mask1 & mask2 )==0){
                    max = Math.max(max, map.get(mask1) * map.get(mask2));
                }
            }
        }
        return max;
    }
}
```

