# 746-使用最小费用爬楼梯

[746-使用最小费用爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/description/?envType=daily-question&envId=2023-12-17)，难度简单

![image-20231217115047441](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202312171150820.png)

题解：**动态规划**

```java
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int n = cost.length;
        int[] dp = new int[n];// 表示到cost[i]为止的最小花费
        dp[0] = cost[0];
        dp[1] = Math.min(dp[0], 0)+cost[1];
        for(int i=2; i<n; i++){
            dp[i] = Math.min(dp[i-1], dp[i-2])+cost[i];
        }
        return Math.min(dp[n-1], dp[n-2]);
    }
}
```

```java
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int n = cost.length;
        int[] dp = new int[n];// 表示从cost[i]开始的最小花费
        dp[n-1] = cost[n-1]; 
        dp[n-2] = Math.min(dp[n-1]+cost[n-2], cost[n-2]);
        for(int i=n-3; i>=0; i--){
            dp[i] = Math.min(dp[i+1], dp[i+2])+cost[i];
        }
        return Math.min(dp[0], dp[1]);
    }
}
```

题解：**递归+备忘录**

```java
class Solution {
    int[] memo;
    public int minCostClimbingStairs(int[] cost) {
        int n = cost.length;
        memo = new int[n];
        Arrays.fill(memo, -1);
        return Math.min(dp(cost, 0), dp(cost, 1));
    }
    public int dp(int[] nums, int s){
        // if(s==nums.length-1) return nums[nums.length-1];
        // if(s==nums.length-2) return Math.min(dp(nums, s+1)+nums[nums.length-2], nums[nums.length-2]);
        if(s>=nums.length) return 0;
        if(memo[s]!=-1)
            return memo[s];
        memo[s] = Math.min(dp(nums, s+1), dp(nums, s+2))+nums[s];
        return memo[s];
    }
}
```

```java
class Solution {
    int[] memo;
    public int minCostClimbingStairs(int[] cost) {
        int n = cost.length;
        memo = new int[n];
        Arrays.fill(memo, -1);
        return Math.min(dp(cost, 0), dp(cost, 1));
    }
    public int dp(int[] nums, int s){
        if(s==nums.length-1) return nums[nums.length-1];
        if(s==nums.length-2) return Math.min(dp(nums, s+1)+nums[nums.length-2], nums[nums.length-2]);
        // if(s>=nums.length) return 0;
        if(memo[s]!=-1)
            return memo[s];
        memo[s] = Math.min(dp(nums, s+1), dp(nums, s+2))+nums[s];
        return memo[s];
    }
}
```

