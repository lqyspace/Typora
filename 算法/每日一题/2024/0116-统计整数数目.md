## 2719-统计整数数目

[2719-统计整数数目](https://leetcode.cn/problems/count-of-integers/description/?envType=daily-question&envId=2024-01-16)，难度困难

![image-20240116220229517](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401162202669.png)

题解：**数位DP**

题目的要求求解数值范围在$num1$到$num2$之间，并且数位和在$min_sum$和$max_sum$之间的两个整数，其中$num1$和$num2$以字符串的形式给出。

我们可以定一个函数$get(num)$，用于求解1到$num$范围内有多少个整数数位和介于$min_sum$和$max_sum$之间的，那么原问题就转换为求解$get(num2)-get(num1)$。因此我们将着重讨论求解$get(num)$。

假设$num$共有n位，我们把数字最高位记作第0位，个位记作第n-1位。

现在我们的目的是从第0位开始，从左往右添加数字，使之成为一个n位的多位数字，同时满足介于$min_sum$和$max_sum$之间。假设我们现在聚焦在第$i$位，前面的第$0$位到第$i-1$位的数位和为$sum$。现在我们要考虑第$i$需要填什么数字$x$，通常$x$是可以取0到9的任意一个数字，但当第0位到第$i-1$位放置的数字都与$num$一样时，$x$的取值范围缩小至$0 \sim num[i]$。

在代码中我们使用$limit$这个布尔值表示前面已经填充的数字是否和$num$一样，如果一样$limit$为`true`，否则为`false`。

当$limit$为`false`时，$x$的取值范围可以是$0 \sim 9$，那么后续的数字填充时都可以是$0 \sim 9$。这样一来，子问题就与$num$的值无关。我们定一个二维数组$dp[i][j]$表示当从左到右填充到第$i$位数时，而已填充的数字之和为$j$的情况下，符合条件的数字个数有多少个。

由于在求解子问题时，子问题变得和$n$无关，也与$num$无关，那么当$limit$为`false`我们可以使用或更新$dp[i][j]$。

当$limit$为`true`时，子问题的个数只有一个，因此我们将答案进行记忆化存储就毫无意义。又因为每次重新调用$get(num)$函数时都需要重新计算所有状态的答案，得不偿失。因此我们可以在$limit$为`false`时，使用和更新$dp[i][j]$，避免重复计算。

如果想看更详细的解释，可以前往：

[两种数位DP模板，附题单](https://leetcode.cn/problems/count-of-integers/solutions/2296043/shu-wei-dp-tong-yong-mo-ban-pythonjavacg-9tuc/?envType=daily-question&envId=2024-01-16)

```java
class Solution {
    private static final int MOD = 1000000007;

    public int count(String num1, String num2, int min_sum, int max_sum) {
        int ans = (calc(num2, min_sum, max_sum) - calc(num1, min_sum, max_sum) + MOD)%MOD;
        int c = 0;
        for(int i=0; i<num1.length(); i++){
            c += num1.charAt(i)-'0';
        }
        if(c>=min_sum && c<=max_sum)
            ans++;
        return ans;
    }

    private int calc(String num, int min_sum, int max_sum){
        int n = num.length();
        // 表示当填入到第i位数时的数位和是sum
        int[][] memo = new int[n][Math.min(n*9, max_sum)+1];
        for(int[] row: memo){
            Arrays.fill(row, -1);
        }
        return dfs(0, 0, true, num.toCharArray(), min_sum, max_sum, memo);
    }

    private int dfs(int i, int sum, boolean isLimit, char[] s, int min_sum, int max_sum, int[][] memo){
        if(sum > max_sum)
            return 0;
        if(i==s.length)
            return sum>=min_sum? 1: 0;
        if(!isLimit && memo[i][sum]!=-1)
            return memo[i][sum];
        // 上限
        int up = isLimit? s[i]-'0':9;
        int res = 0;
        for(int d = 0; d<=up; d++){
            // 枚举当前数位 填d
            res = (res + dfs(i+1, sum+d, isLimit&&d==up, s, min_sum, max_sum, memo))%MOD;
        }
        if(!isLimit){
            // 因为isLimit 为 true时，子问题只出现一次，将isLimit为true的情况放入memo中没有意义
            // 因此这里只将!isLimit的情况放入memo
            memo[i][sum] = res;
        }
        return res;
    }
}
```



题解：**数位DP v2.0**

v2.0版本在v1.0的基础上做了改进，只需要一次记忆化搜索就能算出答案，效率更高。

[v2.0 模板视频讲解](https://www.bilibili.com/video/BV1Fg4y1Q7wv/?t=31m28s&vd_source=33b123287920c827422faa0a5373f980)

仿照$isLimit$，再添加一个参数$limitLow$，表示是否受到下届$num1$的限制。为了让代码更加清晰，原来的参数名$isLimit$改名为$limitHigh$。此外，$d$的最大值$up$改名为$hi$，即$high$的前两个字母。

为了方便计算，在$num1$的前面添加前导零，使其长度和$num1$相等。

$limitLow$的用法和$limitHigh$类似，如果$limitLow=true$，那么$d$只能从$num1[i]$开始枚举，否则可以从0开始枚举，这个值即为$lo$，即$low$的前两个字母。如果$limitLow=true$并且$d=lo$，那么往下递归时，传入的$limitLow$仍然为$true$，否则为$false$。

```java
class Solution {
    private static final int MOD = 1000000007;
    public int count(String num1, String num2, int min_sum, int max_sum) {
        int n = num2.length();
        num1 = "0".repeat(n-num1.length())+num1;
        int[][] memo = new int[n][Math.min(9*n, max_sum)+1];
        for(int[] r: memo){
            Arrays.fill(r, -1);
        }
        return dfs(0, 0, true, true, num1.toCharArray(), num2.toCharArray(), min_sum, max_sum, memo);
    }
    private int dfs(int i, int sum, boolean limitLow, boolean limitHigh, char[] num1, char[] num2, int min_sum, int max_sum, int[][] memo){
        if(sum>max_sum)
            return 0;
        if(i==num2.length)
            return sum>=min_sum? 1: 0;
        if(!limitLow && !limitHigh && memo[i][sum]!=-1)
            return memo[i][sum];
        int lo = limitLow? num1[i]-'0': 0;
        int hi = limitHigh? num2[i]-'0': 9;
        int res = 0;
        for(int d=lo; d<=hi; d++){
            res = (res + dfs(i+1, sum+d, limitLow && d==lo, limitHigh && d==hi, num1, num2, min_sum, max_sum, memo))%MOD;
        }
        if(!limitLow && !limitHigh)
            memo[i][sum] = res;
        return res;
    }
}
```

