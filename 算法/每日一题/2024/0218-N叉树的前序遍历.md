# 589-N叉树的前序遍历

[589-N叉树的前序遍历](https://leetcode.cn/problems/n-ary-tree-preorder-traversal/description/)，难度简单

![image-20240218175301596](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202402181753663.png)

![image-20240218175313936](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202402181753955.png)

题解：**递归**

递归法就不多说了

```java
/*
// Definition for a Node.
class Node {
    public int val;
    public List<Node> children;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, List<Node> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
    
    public List<Integer> preorder(Node root) {
        List<Integer> res = new ArrayList<>();
        if(root==null) return res;
        res.add(root.val);
        for(Node child: root.children){
            res.addAll(preorder(child));
        }
        return res;
    }
}
```

题解：**迭代**

这道题的思路是模拟前序遍历的过程，**使用的数据结构是栈**，具体思路如下：

- 我们不断遍历每个节点的第一个子节点，同时用一个哈希表记录遍历了当前节点的第几个子节点
- 我们获取 **遍历到当前节点的第几个子节点** 的信息后，继续从该子节点遍历，记录每个节点的第一个子节点

```java
/*
// Definition for a Node.
class Node {
    public int val;
    public List<Node> children;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, List<Node> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
    public List<Integer> preorder(Node root) {
        List<Integer> res = new ArrayList<>();
        if(root==null) return res;
        Stack<Node> stk = new Stack<>();
        Map<Node, Integer> map = new HashMap<>();
        Node node = root;
        while(!stk.isEmpty() || node!=null){
            while(node!=null){
                // 把每一个前序遍历的节点都入栈
                res.add(node.val);
                stk.push(node);
                List<Node> children = node.children;
                if(children!=null && children.size()>0){
                    // 遍历当前节点的第一个子节点
                    map.put(node, 0);
                    node = children.get(0);
                }else{
                    // 当前节点为null，退出while循环
                    node=null;
                }
            }
            node = stk.peek();
            int index = map.getOrDefault(node, -1)+1;
            List<Node> children = node.children;
            if(children!=null && children.size()>index){
                // 遍历到当前节点的第index个子节点
                map.put(node, index);
                // 开始遍历第index个子节点
                node = children.get(index);
            }else{
                // 说明当前子节点已经遍历完
                // 删除
                stk.pop();
                map.remove(node);
                node=null;
            }
        }
        return res;
    }
}
```

题解：**迭代优化**

这个思路是对迭代的优化，具体思路如下：

- 使用栈记录每个节点的从右到左的子节点，方便出栈时是从左到右
- 当该节点的子节点全部入栈以后，我们可以对该节点记录并进行出栈

```java
/*
// Definition for a Node.
class Node {
    public int val;
    public List<Node> children;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, List<Node> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
    public List<Integer> preorder(Node root) {
        List<Integer> res = new ArrayList<>();
        if(root==null) return res;
        Stack<Node> stk = new Stack<>();
        stk.push(root);
        while(!stk.isEmpty()){
            Node cur = stk.pop();
            res.add(cur.val);
            if(cur.children.size()>0){
                for(int i=cur.children.size()-1; i>=0; i--){
                    stk.push(cur.children.get(i));
                }
            }
        }
        return res;
    }
}
```

