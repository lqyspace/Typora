# 993-二叉树的堂兄弟节点

[993-二叉树的堂兄弟节点](https://leetcode.cn/problems/cousins-in-binary-tree/description/?envType=daily-question&envId=2024-02-08)，难度简单

![image-20240208203405836](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202402082034967.png)

![image-20240208203429358](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202402082034379.png)

题解：**DFS**

全局参数：

- `depth`深度
- 位于`depth`深度的节点的父节点

dfs传入三个参数

- 当前节点`node`
- `node`的父节点`fa`
- `node`的深度`d`，为了方便判断，根节点的深度为1

如果`node`的节点值等于`x`或者`y`：

- 如果之前没有找到`x`也没有找到`y`，那么记录`node`的深度到变量`depth`中，记录`node`的父节点到变量`father`中
- 如果之前找到`x`，`y`其中的一个，说明现在`x`和`y`都找到了。如果`depth=d`且`father!=fa`，说明`x`和`y`是堂兄弟节点

第一个写法：

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    private int depth;
    private TreeNode father;
    public boolean isCousins(TreeNode root, int x, int y) {
        return dfs(root, null, 1, x, y);
    }

    private boolean dfs(TreeNode node, TreeNode fa, int d, int x, int y){
        if(node==null)
            return false;
        if(node.val==x || node.val==y){// 说明找到了其中的x或y
            if(depth>0){// 说明找到了一个x或y
                return depth==d && father!=fa;
            }
            depth = d;// 说明之前没有找到，现在是找到的第一个
            father = fa;
        }
        return dfs(node.left, node, d+1, x, y)||dfs(node.right, node, d+1, x, y);
    }
}
```

第二个写法：对第一个写法的优化，其中当同时找到`x`和`y`时，如果它两不是堂兄弟，仍然会继续递归，所以没必要继续往下遍历；因此在记录答案时，只要同时找到了`x`和`y`，那就把递归返回`true`，即可停止继续遍历。（因为使用的是逻辑或||）

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    private int depth;
    private TreeNode father;
    private boolean ans;
    public boolean isCousins(TreeNode root, int x, int y) {
        dfs(root, null, 1, x, y);
        return ans;
    }

    private boolean dfs(TreeNode node, TreeNode fa, int d, int x, int y){
        if(node==null)
            return false;
        if(node.val==x || node.val==y){// 说明找到了其中的x或y
            if(depth>0){// 说明找到了一个x或y
                ans = depth==d && father!=fa;
                return true;
            }
            depth = d;// 说明之前没有找到，现在是找到的第一个
            father = fa;
        }
        return dfs(node.left, node, d+1, x, y)||dfs(node.right, node, d+1, x, y);
    }
}
```

第三个写法：当我们遍历到`depth>0`深度时，我们没必要继续往下遍历，因此超过`depth`的部分我们可以直接返回`false`。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    private int depth;
    private TreeNode father;
    private boolean ans;
    public boolean isCousins(TreeNode root, int x, int y) {
        dfs(root, null, 1, x, y);
        return ans;
    }

    private boolean dfs(TreeNode node, TreeNode fa, int d, int x, int y){
        if(node==null || depth>0 && depth<d)
            return false;
        if(node.val==x || node.val==y){// 说明找到了其中的x或y
            if(depth>0){// 说明找到了一个x或y
                ans = depth==d && father!=fa;
                return true;
            }
            depth = d;// 说明之前没有找到，现在是找到的第一个
            father = fa;
        }
        return dfs(node.left, node, d+1, x, y)||dfs(node.right, node, d+1, x, y);
    }
}
```



题解：**层序遍历**，这个解法也是我自己想出来的解法。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isCousins(TreeNode root, int x, int y) {
        Deque<TreeNode> deq = new ArrayDeque<>();
        Map<Integer, Integer> map = new HashMap<>();
        Set<Integer> set = new HashSet<>();
        deq.add(root); map.put(root.val, -1);
        while(!deq.isEmpty()){
            int sz = deq.size();
            if(set.contains(x) && set.contains(y) && x!=y && map.get(x)!=map.get(y))
                return true;
            set.clear();
            for(int i=0; i<sz; i++){
                TreeNode curX = deq.poll();
                if(curX.left!=null){
                    deq.offer(curX.left);
                    set.add(curX.left.val);
                    map.putIfAbsent(curX.left.val, curX.val);
                }
                if(curX.right!=null){
                    deq.offer(curX.right);
                    set.add(curX.right.val);
                    map.putIfAbsent(curX.right.val, curX.val);
                }
            }
        }
        return false;
    }
}
```

