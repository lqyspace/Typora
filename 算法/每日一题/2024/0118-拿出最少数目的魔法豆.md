# 2171-拿出最少数目的魔法豆

[2171-拿出最少数目的魔法豆](https://leetcode.cn/problems/removing-minimum-number-of-magic-beans/description/?envType=daily-question&envId=2024-01-18)，难度中等

![image-20240118192529022](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401181925120.png)

![image-20240118192549358](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401181925401.png)

题解：**一次遍历求面积**

实话实说，这道题求得可真是太巧妙了

首先将`beans`从小到大排序，枚举最终非空袋子中的魔法豆的数目`v`，将小于`v`的魔法豆全部清空，大于`v`的魔法豆减少至`v`，这样所有非空袋子中的魔法豆的个数就一样了。

![image-20240118193621129](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401181936174.png)

如上图所示，可以保留蓝色矩形区域的魔法豆。设`beans`的长度为`n`，以`n-i`为矩形底边长，`v=beans[i]`为矩形高，则矩形面积为$(n-i)*v$

则$\sum_i^n{beans[i]}$减去矩形面积的最大值，即为拿出魔法豆的最小值。

```java
class Solution {
    public long minimumRemoval(int[] beans) {
        Arrays.sort(beans);
        int n = beans.length;
        long sum = 0, mx = 0;
        for(int i=0; i<n; i++){
            sum += beans[i];
            mx = Math.max(mx, (long)(n-i)*beans[i]);
        }
        return sum - mx;
    }
}
```

