# 94-二叉树的中序遍历

[94-二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/description/)，难度简单

![image-20240210150321831](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202402101503861.png)

解法：**递归**

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if(root==null) return res;
        res.addAll(inorderTraversal(root.left));
        res.add(root.val);
        res.addAll(inorderTraversal(root.right));
        return res;
    }
}
```

进阶解法：**迭代**

递归调用的过程就是不断往左边走，当左边走不了就打印节点，并转而向右走，然后在右边持续这个过程。

时间复杂度O(n)，空间复杂度O(h)，h是树的高度。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        Stack<TreeNode> stk = new Stack<>();
        while(stk.size()>0 || root!= null){
            if(root!=null){
                stk.add(root);
                root = root.left;
            }else{
                TreeNode tmp = stk.pop();
                res.add(tmp.val);
                root = tmp.right;
            }
        }
        return res;
    }
}
```

题解：**莫里斯遍历**

用递归和遍历的方式都使用了辅助的空间，而莫里斯遍历的优点就是没有是任何额外的辅助空间。

缺点就是改变了整个树的结构，强行把一颗二叉树改成了一个链表结构。

![image-20240210153527451](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202402101535487.png)

我们把黄色区域部分节点挂到节点5的右子树上，接着再把2和5这两个节点挂到4的右节点上，这样基本上一棵二叉树就被变成了链表。之后不断往右遍历即可。

![image-20240210153734454](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202402101537478.png)

时间复杂度：找到每个前驱节点的复杂度是$O(n)$，因为n个节点的二叉树有n-1条边，每条边只可能使用两次（一次是定位节点，一次是找到前驱节点），故时间复杂度是$O(n)$

空间复杂度：$O(1)$

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if(root==null) return res;
        while(root!=null){
            if(root.left!=null){// 左节点不为空，说明还有前驱，我们需要把右节点全部挂到左节点的最右子树上
                TreeNode pre = root.left;
                while(pre.right!=null){
                    pre = pre.right;
                }
                pre.right = root;
                // 更新新的root节点
                TreeNode tmp = root;
                root = root.left;
                tmp.left = null;
            }else{
                res.add(root.val);
                root = root.right;
            }
        }
        return res;
    }
}
```

