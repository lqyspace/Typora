# 156-上下翻转二叉树

[156-上下翻转二叉树](https://leetcode.cn/problems/binary-tree-upside-down/description/?envType=weekly-question&envId=2024-01-01)，难度中等

![image-20240121215404725](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401212154808.png)

![image-20240121215628269](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401212156443.png)

首先说：**迭代解法**，这个解法确实之前没怎么见过，不过确实精辟，还可以这样考虑，只能说自己对这个上下翻转的原理理解的还不够透彻。

![image-20240121222948625](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401212229682.png)

```java
class Solution {
    public TreeNode upsideDownBinaryTree(TreeNode root) {
        if (root == null || root.left == null && root.right == null) {
            return root;
        }
        Deque<TreeNode> stack = new ArrayDeque<TreeNode>();
        TreeNode temp = root;
        while (temp != null) {
            stack.push(temp);
            temp = temp.left;
        }
        TreeNode newRoot = stack.pop();
        while (!stack.isEmpty()) {
            TreeNode node = stack.pop();
            TreeNode prevLeft = node.left, prevRight = node.right;
            prevLeft.left = prevRight;
            prevLeft.right = node;
            // 下面这个对这道题来说影响不大。
            if (prevRight != null) {
                prevRight.left = null;
                prevRight.right = null;
            }
            node.left = null;
            node.right = null;
        }
        return newRoot;
    }
}
```

**递归：**

```java
class Solution {
    public TreeNode upsideDownBinaryTree(TreeNode root) {
        if (root == null || root.left == null) {
            return root;
        }
        TreeNode left = root.left, right = root.right;
        TreeNode ret = upsideDownBinaryTree(left);
        left.left = right;
        left.right = root;
        root.left = root.right = null;
        return ret;
    }
}
```

