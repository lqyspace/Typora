# 938-二叉搜索树的范围和

[938-二叉搜索树的范围和](https://leetcode.cn/problems/range-sum-of-bst/description/)，难度简单

![image-20240226110148658](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202402261101697.png)

![image-20240226110157011](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202402261101034.png)

题解：**递归**

我自己写的：

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {

    public int rangeSumBST(TreeNode root, int low, int high) {
        if(root==null) return 0;
        int left = rangeSumBST(root.left, low, high);
        int right = rangeSumBST(root.right, low, high);
        if(root.val >= low && root.val <= high)
            return root.val + left + right;
        return left + right;
    }
}
```

官方的：

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {

    public int rangeSumBST(TreeNode root, int low, int high) {
        if(root==null) return 0;
        int x = root.val;
        if(x>high)//说明右子树没有节点
            return rangeSumBST(root.left, low, high);
        if(x<low)// 说明左子树没有节点
            return rangeSumBST(root.right, low, high);
        return x + rangeSumBST(root.left, low, high) + rangeSumBST(root.right, low, high);
    }
}
```

两段代码对比，很明显我的代码没有里有好二叉搜索树的性质。