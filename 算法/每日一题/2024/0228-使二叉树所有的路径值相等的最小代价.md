# 2673-使二叉树所有路径值相等的最小代价

[2673-使二叉树所有路径值相等的最小代价](https://leetcode.cn/problems/make-costs-of-paths-equal-in-a-binary-tree/description/)，难度中等

![image-20240228151830590](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202402281518700.png)

![image-20240228151857947](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202402281518972.png)

视频讲解请看[周赛344](https://www.bilibili.com/video/BV1YL41187Rx/?vd_source=33b123287920c827422faa0a5373f980)第四题

**提示1：**

考虑根到两个互为兄弟节点的（父节点相同）的叶子节点的两条路径。

由于这两条路径除了叶子节点不一样，其余节点都一样，所以为了让这两条路径相同，必须修改这两个叶子节点的值。

设叶子节点的值分别为`x`和`y`，假设`x<=y`，是否需要同时增加`x`和`y`的值呢？

答案是不需要的，把`x`增加到`y-x`即可，因为我们可以增加它的祖先节点的值，使得它们两路径和相等，这样可以节省操作次数；



**提示2：**

对于不是叶子节点的兄弟节点，和上面的分析一样，**从根到当前节点的路径**，除了这两个兄弟节点不一样，其余节点都一样，所以把路径和从叶子往上传，这样就可以按照提示1那样比较了。

示例1如下图所示，把节点2的路径和视作`x+5+3=x+8`，节点3的路径和视作`x+2+3=x+5`（其中`x`是在节点2，3之上的路径和），这样可以知道需要把节点3的值增加（x+8）-（x+5）=8-5=3。

![lc2673.png](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202402281528354.png)

在代码实现上，可以直接在`cost`上累加路径和。由于`cost`数组的下标是从0开始的，所以节点编号转成下标需要减一。

```java
class Solution {
    public int minIncrements(int n, int[] cost) {
        int ans = 0;
        for (int i = n / 2; i > 0; i--) { // 从最后一个非叶节点开始算
            ans += Math.abs(cost[i * 2 - 1] - cost[i * 2]); // 两个子节点变成一样的
            cost[i - 1] += Math.max(cost[i * 2 - 1], cost[i * 2]); // 累加路径和
        }
        return ans;
    }
}
```

