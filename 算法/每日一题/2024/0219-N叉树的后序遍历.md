# 590-N叉树的后序遍历

[590-N叉树的后序遍历](https://leetcode.cn/problems/n-ary-tree-postorder-traversal/description/)，难度简单

![image-20240219105919949](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202402191059002.png)

![image-20240219105929364](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202402191059384.png)

题解：**递归**

```java
/*
// Definition for a Node.
class Node {
    public int val;
    public List<Node> children;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, List<Node> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
    public List<Integer> postorder(Node root) {
        List<Integer> res = new ArrayList<>();
        if(root==null) return res;
        for(Node node: root.children){
            res.addAll(postorder(node));
        }
        res.add(root.val);
        return res;
    }
}
```

题解：**迭代**

- 使用的数据结构是栈，利用栈的特点，从左到右遍历子节点入栈，那么出栈是就是从右到左
- 最后将结果反转一下

```java
/*
// Definition for a Node.
class Node {
    public int val;
    public List<Node> children;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, List<Node> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
    public List<Integer> postorder(Node root) {
        List<Integer> res = new ArrayList<>();
        if(root==null) return res;
        Stack<Node> stk = new Stack<>();
        stk.push(root);
        while(!stk.isEmpty()){
            Node cur = stk.pop();
            res.add(cur.val);
            if(cur.children!=null && cur.children.size()>0)
                for(int i=0; i<=cur.children.size()-1; i++){
                    stk.push(cur.children.get(i));
                }
        }
        Collections.reverse(res);
        return res;
    }
}
```

题解：**迭代**

- 遍历子节点时是从右到左入栈，并且不断遍历每个节点的子节点
- 使用哈希表记录遍历到当前节点的第几个子节点

```java
/*
// Definition for a Node.
class Node {
    public int val;
    public List<Node> children;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, List<Node> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
    public List<Integer> postorder(Node root) {
        List<Integer> res = new ArrayList<>();
        if(root==null) return res;
        Stack<Node> stk = new Stack<>();
        Map<Node, Integer> map = new HashMap<>();
        Node node = root;
        while(!stk.isEmpty() || node!=null){
            while(node!=null){
                res.add(node.val);
                stk.push(node);
                List<Node> children = node.children;
                if(children!=null && children.size()>0){
                    map.put(node, children.size()-1);
                    node = children.get(children.size()-1);
                }else{
                    node=null;
                }
            }
            node = stk.peek();
            int index = map.getOrDefault(node, -1)-1;
            List<Node> children = node.children;
            if(children!=null && index>=0){
                map.put(node, index);
                node = children.get(index);
            }else{
                stk.pop();
                map.remove(node);
                node=null;
            }
        }
        Collections.reverse(res);
        return res;
    }
}
```