# 2867-统计树中的合法路径数目

[2867-统计树中合法的路径数目](https://leetcode.cn/problems/count-valid-paths-in-a-tree/description/)，难度困难

![image-20240227214140075](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202402272141182.png)

![image-20240227214203811](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202402272142846.png)

题解：[视频讲解第四题](https://www.bilibili.com/video/BV1yu4y1z7sE/)

![w364D-2-c.png](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202402272142279.png)

在实现代码时，为避免反复DFS同一个非质数连通块，可以把每个非质数所处的连通块的大小记录下来（类似记忆化搜索）。如果之前计算过，就无需再次计算。

```java
class Solution {
    private final static int MX = (int) 1e5;
    private final static boolean[] np = new boolean[MX+1]; // 质数=false，非质数=true

    static{
        np[1] = true;
        for(int i=2; i*i<=MX; i++){
            if(!np[i]){// 如果i为质数
                for(int j=i*i; j<=MX; j+=i){
                    np[j] = true; // 那么i的倍数就不是质数
                }
            }
        }
    }
    public long countPaths(int n, int[][] edges) {
        List<Integer>[] g = new ArrayList[n+1];
        Arrays.setAll(g, e->new ArrayList<>());
        for(int[] e: edges){
            int x = e[0], y = e[1];
            g[x].add(y);
            g[y].add(x);
        }

        long ans = 0;
        int[] size = new int[n+1];
        List<Integer> nodes = new ArrayList<>();
        for(int x=1; x<=n; x++){
            if(np[x]) continue; // 跳过非质数, x是质数
            int sum = 0;
            for(int y: g[x]){
                if(!np[y]) continue; // 跳过质数, y是非质数
                if(size[y]==0){
                    // 尚未计算
                    nodes.clear();
                    dfs(y, -1, g, nodes);// 遍历y所在的连通块，在不经过质数的前提下，统计有多少个非质数
                    for(int z: nodes){
                        size[z] = nodes.size();
                    }
                }
                // 这个size[y]个非质数与之前遍历的sum个非质数，两两之间的路径只包含质数x
                ans += (long) size[y] * sum;
                sum += size[y];
            }
            ans += sum;
        }
        return ans;
    }

    private void dfs(int x, int fa, List<Integer>[] g, List<Integer> nodes){
        nodes.add(x);
        for(int y: g[x]){
            if(y!=fa && np[y]){
                // 如果y不等于fa并且y不等于质数
                dfs(y, x, g, nodes);
            }
        }
    }
}
```

