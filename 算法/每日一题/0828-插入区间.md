# 57-插入区间

[57-插入区间](https://leetcode.cn/problems/insert-interval/)，难度中等

![image-20230828150716705](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308281507777.png)

题解：

- 先把新区间融入到原始的数组中
- 再求不重叠区间

```java
class Solution {
    public int[][] insert(int[][] intervals, int[] newInterval) {
        ArrayList<int[]> res = new ArrayList<>();
        List<int[]> inters = new LinkedList<>();
        for(int[] r: intervals){
            inters.add(r);
        }
        inters.add(newInterval);
        Collections.sort(inters, new Comparator<int[]>(){
            public int compare(int[] a, int[] b){
                return a[0] - b[0];
            }
        });
        
        for(int[] row: inters){
            if(res.isEmpty() || res.get(res.size()-1)[1]<row[0])
                res.add(row);
            else
                res.get(res.size()-1)[1] = Math.max(res.get(res.size()-1)[1], row[1]);
        }
        
        int[][] ans = new int[res.size()][2];
        for(int i=0; i<res.size(); i++){
            ans[i][0] = res.get(i)[0];
            ans[i][1] = res.get(i)[1];
        }
        return ans;
    }
}
```

---

官方给的解释：

**前言**：

对于区间$S_1=[l_1, r_1]$和 $S_2=[l_2, r_2]$，如果它们之间没有重叠（没有交集）。说明要么$S_1$在$S_2$的左侧，此时有$r_1<l_2$；要么$S_1$ 在$S_2$的右侧，此时有 $l_1>r_2$。

如果$r_1<l_2$或者$l_1>r_2$都不满足，说明$S_1$和$S_2$必定有交集，他们的交集为：

$\{{max(l_1, l_2), min(r_1, r_2)}\}$

并集为：$\{ min(l_1, l_2), max(r_1, r_2) \}$

**思路与算法：**

在给定的区间集合 $X$互不重叠的前提下，当我们需要充入一个新的区间 $S=[left, right]$时，我们只需要：

- 找出所有与区间 $S$重叠的区间集合 $X^`$；
- 将 $X^`$ 中的所有区间连同区间$S$合并成一个大区间；
- 最终的答案即为不与 $X^`$重叠的区间以及合并后的大区间

![fig1](https://assets.leetcode-cn.com/solution-static/57/1.png)

这样做的正确性在于，给定的区间集合中任意两个区间都是没有交集的，因此所有需要合并的区间，就是所有与$S$重叠的区间。

并且在给定的区间集合已经**按照左端点排序**的前提下，所有与$S$重叠的区间在数组$intervals$中下标范围是连续的，因此我们可以对所有区间进行一次遍历，就可以找到连续的下标范围。

当我们遍历到区间$[l_i, r_i]$时：

- 如果$r_i<left$，说明$[l_i, r_i]$与$S$不重叠并且在$S$的左侧，我们可以直接将$[l_i, r_i]$加入答案；
- 如果$right<l_i$，说明$[l_i, r_i]$与$S$不重叠并且在$S$的右侧，我们可以直接将$[l_i, r_i]$加入答案；
- 如果上面两种情况均不满足，说明$[l_i, r_i]$ 与 $S$重叠，我们无需将$[l_i, r_i]$加入答案，此时，我们需要将$S$与$[l_i, r_i]$合并，即更新为其与$[l_i, r_i]$的并集。

那么我们应当在什么时候将区间$S$加入答案呢？由于我们需要保证答案也是按照做左端点排序的，因此当我们遇到第一个满足 $right<l_i$时，说明以后的区间肯定不与$S$重合，因此可以直接将$S$加入集合。特别的，如果不存在这样的区间，我们需要在遍历结束后，将$S$加入答案。

```java
class Solution {
    public int[][] insert(int[][] intervals, int[] newInterval) {
        int left = newInterval[0], right = newInterval[1];
        boolean place = false;
        
        List<int[]> res = new ArrayList<>();
        for(int[] interval: intervals){
            if(right < interval[0]){
                if(!place){
                    res.add(new int[]{left, right});
                    place = true;
                }
                res.add(interval);
            } else if (left > interval[1]){
                res.add(interval);
            } else {
                left = Math.min(left, interval[0]);
                right = Math.max(right, interval[1]);
            }
        }
        if(!place){
            res.add(new int[]{left, right});
        }
        
        int[][] ans = new int[res.size()][2];
        for(int i=0; i<res.size(); i++){
            ans[i][0] = res.get(i)[0];
            ans[i][1] = res.get(i)[1];
        }
        return ans;
    }
}
```

时间复杂度：$O(n)$

空间复杂度：$O(1)$