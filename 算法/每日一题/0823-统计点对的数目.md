# 1782-统计点对的数目

[1782-统计点对的数目](https://leetcode.cn/problems/count-pairs-of-nodes/description/)，难度困难

![image-20230828104353980](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308281044057.png)

对官方题解的进一步解读：

这道题果真是看了老半天才看明白题意，对题目进行以下分析：

首先，一定要看明白题目让我们求的是什么？题目说的是点对的数目，那满足什么条件的点对呢？有两个条件，第一，是 `a<b`，第二，`cnt`的值要严格大于 `queries[i]`。你要明白所谓的点对，并不是指边相连的点对，而是所有的点可能组成的组合，如果有4个点的话，那么点对数就是6个，如果7个点的话，那么点对数就是21个。

其次，官方给的题解里，假设给定点a，则点对的另一个点b应该满足如下的条件：$degree(a) + degree(b) - cnt(a,b) > queries[i]$，对这个公式进行转换：$degree(a) - cnt(a,b)>queries[i]-degree(b)$，其中 $cnt(a,b) >= 0$，则说明，如果我们要求符合条件的点对的数量的话，那么点a的度一定就得大于 $queries[i]-degree(b)$。

那么为什么是二分查找呢？

我们找点对的过程肯定是不能存在重复的，举个例子：有一个点数组 $[1,2,3,4]$，那么能组成的点对分别是：$(1,2), (1,3), (1,4), (2,3), (2,4), (3,4)$，也就是说，如果我想找点对的组合的话，我确定了一个点a的位置，那么我只需要在点a的后面位置确定一个点b就行，并且保证 $degree(a)+degree(b)-cnt(a,b)>queries[i]$ 即可。

这也是官方题解里面说，要对每个点的度进行排序的方法，对每个点的度进行排序，是为了更好的进行二分搜索，因为二分搜索适用于有序数组里面的。

在进行二分搜索的时候其实求的是右边界，即最大值，因为如果我确定了一个点a，我为了求点b的位置，一定要满足点b位置的值刚好大于 $queries[i] - degree(a)$ 才行，因此需要使用二分搜索求目标值$queries[i] - degree(a)$ 的右边界，具体的代码如果如下：

```java
class Solution {
    public int[] countPairs(int n, int[][] edges, int[] queries) {
		// 求每个点的度
        int[] degree = new int[n];
        // 求点对（a，b）的边数
        Map<Integer, Integer> cnt = new HashMap<>();
        
        for(int[] row: edges){
            int x = row[0]-1, y = row[1]-1;
            degree[x]++; degree[y]++;
            if(y>x){
                int tmp = x;
                x = y;
                y = tmp;
            }
            cnt.put(x*n+y, cnt.getOrDefault(x*n+y, 0)+1);
        }
        
        int[] arr = Arrays.copyOf(degree, n);
        int[] ans = new int[queries.length];
        Arrays.sort(arr);// 不要忘记排序
        for(int k=0; k<queries.length; k++){
            int bound = queries[k], total = 0;
            for(int i=0; i<n; i++){
                int j = binarySearch(arr, i+1, n-1, bound - arr[i]);
                total += n-j;
            }
            
            for(Map.Entry<Integer, Integer> entry: cnt.entrySet()){
                int val = entry.getKey(), freq = entry.getValue();
                int x = val/n, y = val % n;
                if(degree[x] + degree[y] > bound && degree[x]+degree[y]-freq<=bound){
                    total--;
                }
            }
            ans[k] = total;
        }
        return ans;
    }
    
    public int binarySearch(int[] arr, int left, int right, int target){
        int ans = right+1;
        while(left<=right){
            int mid = left + (right - left)/2;
            if(arr[mid] <= target){
                left = mid+1;
            }else {
                right = mid-1;
                ans = mid;// 因为arr[mid]>target
            }
        }
        return ans;
    }
    
}
```

时间复杂度：$O(q\times (nlogn+m))$，其中q表示数组queries的长度，n表示给定节点的个数，m表示边edges的长度。对数组进行拷贝的时间复杂度是$O(n)$，对所有的点的度数进行排序的时间复杂度为$O(nlogn)$，每次进行二分搜索的找到符合要求的点对时，并同时遍历所有的边，需要的时间复杂度为 $O(nlongn + m)$，由于进行q次，所以是$O(q\times (nlogn + m))$，因此总共的是件复杂为$O(m+n+nlogn+q\times (nlogn+m))$。

空间复杂度：$O(n+m)$，如果结果的数组不算的话，所需要的空间复杂度就是存储每个点的度数，外加每条边出现的次数。



**双指针优化上面的代码：**

方法二的解法思路跟方法一基本一致，唯一需要特殊处理的是找满足 $degree[a]+degree[b]>bound$的点对时可以利用双指针来处理：

假设当前从小到大第 $i$ 节点 $a$ 的度为 $degree[a]$，我们从后往前找到第一个满足小于等于 $bound−degree[a]$的节点索引为 $j$，则此时 $b∈[j+1,n−1]$ 均满足 $degree[a]+degree[b]>queries[i]$，则此时与 $a$  构成满足要求的节点的数目位 $n−1−j$，为了防止重复计算，此时只取大于 $i$ 且大于 $j$ 的索引，则此时 $b∈[max⁡(i+1,j+1),n−1]$ 区间内的索引即可；

```java
class Solution {
    public int[] countPairs(int n, int[][] edges, int[] queries) {
		int[] degree = new int[n];
        Map<Integer, Integer> cnt = new HashMap<>();
        int[] ans = new int[queries.length];
        
        for(int[] row: edges){
            int x = row[0]-1, y = row[1]-1;
            degree[x]++; degree[y]++;
            if(y>x){
                int tmp = x;
                x = y;
                y = tmp;
            }
            cnt.put(x*n+y, cnt.getOrDefault(x*n+y, 0)+1);
        }
        
        int[] arr = Arrays.copyOf(degree, n);
        Arrays.sort(arr);
        for(int k=0; k<queries.length; k++){
            int bound = queries[k], total = 0;
            for(int i=0, j=n-1; i<n; i++){
                while(j>i && arr[i]+arr[j]>bound)
                    j--;
                total += n-1-Math.max(i, j);
            }
            
            for(Map.Entry<Integer, Integer> entry: cnt.entrySet()){
                int val = entry.getKey(), freq = entry.getValue();
                int x = val/n, y = val%n;
                if(degree[x] + degree[y] > bound && degree[x] + degree[y] - freq <= bound)
                    total--;
            }
            ans[k] = total;
        }
        return ans;
    }
}
```