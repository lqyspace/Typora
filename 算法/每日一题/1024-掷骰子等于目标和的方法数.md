# 1155-掷骰子等于目标和的方法数

[1155-掷骰子等于目标和的方法数](https://leetcode.cn/problems/number-of-dice-rolls-with-target-sum/description/?envType=daily-question&envId=2023-10-24)，难度中等

![image-20231025144050095](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310251440375.png)

题解：**动态规划**

我们使用 `dp[i][j]` 来表示`i`个骰子得到目标和为`j`的方法数，为了计算这个值，我们可以枚举最后一个骰子的数字，它的范围为`[1, k]`，那么的他的状态转移方程就是：$dp[i][j] = \sum_{x=1}^{k} dp[i-1][j-x]$。

动态规划的边界为：`dp[0][0]=1`，即我们还没有投骰子的时候目标和为0的方法数只有一种。

同时我们也能知道，如果`j<i`的话，那么方法数也是0，即：`dp[i][j]=0  if  j<i`。

所以最终的答案就是：`dp[n][target]`。

注意：这个题有一点需要注意的是，需要对结果进行取模，最开始我的思路是计算出最终的结果，然后再取模，但是既然可以计算出最终结果的话，那取模就失去了意义，因此从题目的解读来看，取模的意义在于：可能中间结果的值也很多，因此需要取模。

不过这也不是绝对的，有的时候需要根据提议进行分析。

```java
class Solution{
    static final int MOD = 1000000007;
    
    public int numRollsToTarget(int n, int k, int target) {
        int[][] dp = new int[n+1][target+1];
        dp[0][0] = 1;
        for(int i=1; i<=n; i++)
            for(int j=i; j<=target; j++){
                for(int x=1; x<=k; x++)
                    if(j-x>=0)// 在这个地方，dp[i][j]的吗，默认初始值为0
                		dp[i][j] = (dp[i][j] + dp[i-1][j-x])%MOD;
            }
        return dp[n][target];
    }
}
```

改进：`dp[i][j]`的转移是会和上一层的`dp[i-1][j-x]`有关，因此我们可以存储当前行（第i行）和上一行（第i-1行）的值，即可以使用两个一维数组代替上面的二维数组。

```java
class Solution{
    static final int MOD = 1000000007;
    
    public int numRollsToTarget(int n, int k, int target) {
        int[] dp = new int[target+1];
        dp[0] = 1;
        for(int i=1; i<=n; i++){
            int[] g = new int[target+1];
            for(int j=i; j<=target; j++){
                for(int x=1; x<=k; x++)
                    if(j-x>=0)
                		g[j] = (g[j] + dp[j-x])%MOD;
            }
            dp = g;
        }
        return dp[target];
    }
}
```

改进：我们发现`dp[i][j]`严格是从上一行的`dp[i-1][j-x]`转移而来，因此我们可以倒序遍历第二维的`j`，这样的话我们就可以使用一个一维数组进行改进，这样也就保证了一维数组中下标大于`j`的位置都是`dp[i][...]`，下标小于`j`的位置都是`dp[i-1][...]`，这样就保证了迭代的正确性

```java
class Solution{
    static final int MOD = 1000000007;
    
    public int numRollsToTarget(int n, int k, int target) {
        int[] dp = new int[target+1];
        dp[0] = 1;
        for(int i=1; i<=n; i++){
            for(int j=target; j>=1; j--){
                // 在原始的地方：dp[i][j]的默认初始值为0
                dp[j] = 0;
                for(int x=1; x<=k; x++)
                    if(j-x>=0)
                		dp[j] = (dp[j] + dp[j-x])%MOD;
            }
        }
        return dp[target];
    }
}
```

这道题可以改成**递归**：

```java
class Solution {
    int k;
    int[][] memo;
    int MOD = 1000000007;
    public int numRollsToTarget(int n, int k, int target) {
        this.k = k;
        memo = new int[n+1][target+1];
        for(int[] row: memo)
            Arrays.fill(row, -1);
        return dfs(n, target);
    }

    public int dfs(int i, int j){
        if(j<i || i<0 || j<0) return 0;
        if(i==0 && j==0) return 1;
        if(memo[i][j]!=-1)
            return memo[i][j];
        int sum = 0;
        for(int x=1; x<=k; x++){
            sum = (sum + dfs(i-1, j-x))%MOD;
        }
        memo[i][j] = sum;
        return memo[i][j];
    }
}
```

