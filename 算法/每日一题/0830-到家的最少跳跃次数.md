# 1654-到家的最少跳跃次数

[1654-到家的最少跳跃次数](https://leetcode.cn/problems/minimum-jumps-to-reach-home/description/)，难度中等

![image-20230830182750118](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308301827201.png)

官方题解：

**广度优先搜索遍历**

求最短路径一般需要用广度优先搜索遍历，但是此题中的图是一个无限图，如果不限制搜索范围的话，无法处理无解的情况。因此，解决此题的关键是找出搜索的范围，并且下线已经由题目给出，不能跳到负整数的位置，我们还需要找出搜索上限，下面分类讨论：

1. a==b。此时为了次数最少，跳蚤没有必要先后跳，只需要一直往前跳。当它超过x却没有遇到x时，表示它再也跳不到x了，此时的上限可以设置为x。
2. a>b。题目规定，跳蚤不能连续向后跳两次，因此这只跳蚤的运动轨迹中，任意的连续两次跳跃，总的形成一定是在前进的，前进了a-b的距离。即使它某一步是在后退，这一步的前一步和后一步（如果有的话）一定是在前进。此时跳蚤运动的上限为x+b，在这个上限的情况下，跳蚤往回跳一步就可以到达x。在大于这个上限的情况下，即使跳蚤往回跳一步，所处的位置也大于x，而且跳蚤接下来前进的次数必然会大于等于后退的次数，再也无法到达x。因此这情况下，上限为x+b。
3. a<b。在这种情况下，上限为 $max(max(forbidden)+a+b, x)$。接下来证明这一点。为了方便，记 $max(forbidden)=f$。首先，将数轴上大于等于0的位置分为三个区域：
   - [0, f]，禁止区。所有的forbidden中的位置都在这个区域。
   - (f, max(f+a+b, x))，安全区，它的右边界是a<b的情况下我们想要证明的广度优先搜索的上限。
   - (max(f+a+b, x), +无穷大)，界外区

这三个区域合起来组成数轴上的大于等于0的所有区域，注意x可能位于禁止区或者安全区，但不会是forbidden中的元素。假设某个步数最少的路径中，点C是第一个进入节外区（前进进入）的点，而点H是第一个离开界外区的点（后退离开）。因为点x只可能存在禁止区和安全区，因此如果这条路径存在点C的话，那必然存在点H。如下图，横坐标为步数，纵坐标为与原点的距离。箭头朝右表示前进，箭头朝下表示后退。

![fig1](https://assets.leetcode-cn.com/solution-static/1654/1.png)

![image-20230830184314075](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308301843167.png)

![image-20230830184351493](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308301843550.png)

```java
class Solution {
    public int minimumJumps(int[] forbidden, int a, int b, int x) {
        Queue<int[]> q = new ArrayDeque<>();
        Set<Integer> visited = new HashSet<>();
        q.offer(new int[]{0, 1, 0});// 第一个值表示位置，第二个值表示方向，第三个值表示步数
        visited.add(0);// 表示0位置访问过了
        int lower = 0, upper = Math.max(Arrays.stream(forbidden).max().getAsInt()+a, x) + b;
        Set<Integer> forbiddenSet = new HashSet<>();
        for(int num: forbidden){
            forbiddenSet.add(num);
        }
        
        while(!q.isEmpty()){
            int[] cur = q.poll();
            int position = cur[0], direction = cur[1], steps = cur[2];
            if(position == x)
                return steps;
            
            int nextPosition = position + a;
            int nextDirection = 1;
            // 不管当前的位置是前进得来的还是后退得来的，下一步都可以前进
            if(lower<=nextPosition && nextPosition <= upper && !visited.contains(nextPosition * nextDirection) && !forbiddenSet.contains(nextPosition)){
                visited.add(nextPosition*nextDirection);// 之所以相乘，是因为一个位置可能是前进得来的，也可能是后退得来的，为了避免无限重复跳跃到某个点，因此这两种情况都需要加入到集合中去
                q.offer(new int[]{nextPosition, nextDirection, steps+1});
            }
            
            // 只有当当前这步是前进得来的时候，才能进行后退操作
            if(direction == 1){
                nextPosition = position - b;
                nextDirection = -1;
                if(lower<=nextPosition && nextPosition<=upper && !visited.contains(nextPosition*nextDirection) && !forbiddenSet.contains(nextPosition)){
                    visited.add(nextPosition*nextDirection);
                    q.offer(new int[]{nextPosition, nextDirection, steps+1});
                }
            }
        }
        return -1;
    }
}
```













