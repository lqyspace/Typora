# 823-带因子的二叉树

[823-带因子的二叉树](https://leetcode.cn/problems/binary-trees-with-factors/description/)，难度中等

![image-20230829125538779](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308291255839.png)

我是真没想到呀，这题还能用动态规划。

解题的时候一定要从特殊找一般，简单到复杂，不要想着一开始就写着很高深的代码。

官方题解：

因为每个整数`arr[i]`均大于1，因此每个非叶子结点的值都大于它的子节点的值。考虑以 `arr[i]`为根节点的带因子二叉树，那么它的所有子节点的值都小于 `arr[i]`。我们将arr从小到大进行排序，那么对于以 `arr[i]`为根的带因子二叉树，他的子孙节点的值的下标只能在区间 `[0, i-1]`中。使用 `dp[i]`保存以 `arr[i]`为根节点的带因子二叉树的数目。我们从区间 `[0,i-1]`内枚举 `arr[i]`的子节点，假设存在 `0<=left<=right<i`使 `arr[i]=arr[left] x arr[right]`成立，那么 `arr[left]`和 `arr[right]`可以作为 `arr[i]`的子节点。同时 `arr[left]`和 `arr[right]`为根节点的带因子二叉树分别为 `dp[left]`和 `dp[right]`，不难推导出 `arr[left]`和 `arr[right]`作为 `arr[i]`的子节点时，带因子二叉树数目s为：

- $left = right$时，$s=dp[left] \times dp[right]$
- $left \neq right$时，$s=dp[left] \times dp[right] \times 2$，因为两个因子的位置可以交换
- 当`arr[i]`没有子节点时，对应1个带因子二叉树。因此，状态转移方程为：

$dp[i]=1+\sum_{(left, right)\in U}{dp[left] \times dp[right] \times (1+f(left, right))}$

其中$(left, right)\in U$表示所有满足 $0<=left<=right<i$且$arr[left] \times arr[right] = arr[i]$的下标对 $(left, right)$，而$f(left, right)$的取值为当$left==right$时，值为0，否则值为1(因为$left \neq right$时，两个子节点的位置可以交换)

```java
class Solution {
    public int numFactoredBinaryTrees(int[] arr) {
		Arrays.sort(arr);
        long[] dp = new long[arr.length];
        Arrays.fill(dp, 1);
        HashMap<Integer, Integer> set = new HashMap<>();
        long res = 0;
        long mod = 1000000007;
        for(int i=0; i<arr.length; i++){
            set.put(arr[i], i);
            for(int j=0; arr[j]*arr[j]<=arr[i] && j<=i; j++){
                // 预防arr[i]/arr[j]不能被整除
                if(arr[i]%arr[j]==0 && set.containsKey(arr[i]/arr[j])){
                    if(j!=set.get(arr[i]/arr[j]))
                		dp[i] = dp[i] + dp[j] * dp[set.get(arr[i]/arr[j])] * 2;
                    else 
                        dp[i] = dp[i] + dp[j] * dp[set.get(arr[i]/arr[j])];
                }
            }
            res = (res + dp[i])%mod;
        }
        return (int)res;
    }
}
```

官方给的代码：

```java
class Solution {
    public int numFactoredBinaryTrees(int[] arr) {
		Arrays.sort(arr);
        long[] dp = new long[arr.length];
        Arrays.fill(dp, 1);
        long res = 0;
        long mod = 1000000007;
        for(int i=0; i<arr.length; i++){
            for(int left=0, right = i-1; left<=right; left++){
                // 此处加long，避免相乘的结果溢出
                while(right>=left && (long)arr[left]*arr[right] > arr[i]){
                    right--;
                }
                if(right>=left && (long)arr[left] * arr[right] == arr[i]){
                    if(left!=right)
                        dp[i] = (dp[i] + dp[left] * dp[right] *2 )%mod;
                    else 
                        dp[i] = (dp[i] + dp[left] * dp[right] )%mod;
                }
            }
            res = (res + dp[i])%mod;
        }
        return (int)res;
    }
}
```

