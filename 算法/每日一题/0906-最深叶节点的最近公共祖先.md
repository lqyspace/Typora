# 1123-最深叶节点的最近公共祖先

[1123-最深叶节点的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-deepest-leaves/description/?envType=daily-question&envId=2023-09-06)，难度中等

![image-20230907002159458](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202309070021986.png)

题解：

判断左右子树的深度：

- 如果左子树的深度大于右子树，说明最近公共祖先在左子树里面
- 如果右子树的深度大于左子树，说明最近公共祖先在右子树里面
- 如果左右子树的深度一样，那说明当前节点就是最近公共祖先

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int maxDepth = Integer.MIN_VALUE;
    TreeNode rootDepth;
    public TreeNode lcaDeepestLeaves(TreeNode root) {
        rootDepth = root;
        dfs(root, 0);
        return rootDepth;
    }

    public int dfs(TreeNode root, int d){
        if(root==null) return d-1;
        //if(root.left==null && root.right==null){
        //    if(d<maxDepth){
        //        maxDepth = d;
        //        rootDepth = root;
        //    }
        //    return d;// 返不返回d都可以
        //}// 你最开始写的时候有这一句，这个地方是错误的，d>maxDepth才对；但是这一句闲的没必要，因为有下面的判断就可以了
        
        int left = dfs(root.left, d+1);
        int right = dfs(root.right, d+1);
        if(left==right && maxDepth<=right){
            // 注意，这里是更新最大值，只有左右子树的深度比最大深度大时，才有更新的必要，此时可以更新公共祖先节点
            rootDepth = root;
            maxDepth = left;
        }
        return left>right? left: right; 
    }
}
```