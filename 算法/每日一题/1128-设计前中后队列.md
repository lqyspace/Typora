# 1670-设计前中后队列

[1670-设计前中后队列](https://leetcode.cn/problems/design-front-middle-back-queue/description/?envType=daily-question&envId=2023-11-28)，难度中等

![image-20231128220830692](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed202311282208805.png)

![image-20231128220924034](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed202311282209068.png)

题解：**双端队列**

我自己的代码

```java
class FrontMiddleBackQueue {
    List<Integer> dq;
    int mid = -1;
    public FrontMiddleBackQueue() {
        dq = new ArrayList<>();
    }
    
    public void pushFront(int val) {
        dq.add(0, val);
    }
    
    public void pushMiddle(int val) {
        int n = dq.size();
        dq.add(n/2, val);
    }
    
    public void pushBack(int val) {
        dq.add(val);
    }
    
    public int popFront() {
        return dq.isEmpty()? -1: dq.remove(0);
    }
    
    public int popMiddle() {
        return dq.isEmpty()? -1: dq.remove((dq.size()-1)/2);
    }
    
    public int popBack() {
        return dq.isEmpty()? -1: dq.remove(dq.size()-1);
    }
}

/**
 * Your FrontMiddleBackQueue object will be instantiated and called as such:
 * FrontMiddleBackQueue obj = new FrontMiddleBackQueue();
 * obj.pushFront(val);
 * obj.pushMiddle(val);
 * obj.pushBack(val);
 * int param_4 = obj.popFront();
 * int param_5 = obj.popMiddle();
 * int param_6 = obj.popBack();
 */
```

官解：**两个双端队列**

如果只在前后位置添加元素，用一个双端队列就够了。

![image-20231129002836888](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed202311290028920.png)

但是要支持在**正中间**添加删除元素，可以分裂成左右两个双端队列。分别记作**left**和**right**。

![image-20231129002958049](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed202311290029072.png)

它们的长度大致相同，也可以规定**left**至多比**right**要多一个长度，并且**left**尾部与**right**的头部相接。

这样一来，我们对中间的操作就可转换为对左边尾部或者对右边头部的操作，时间复杂度都为**O(1)**。

由于左右两个部分都需要支持头部，尾部的插入和删除，因此使用双端队列这一数据结构。

在整个过程中，我们保持**left**和**right**大致相同，或者**left**的长度比**right**的长度刚好多1，即$right.length<=left.length<=right.length+1$（当然也可以反过来，让**left**的长度与**right**的长度相等或者**right**的长度比**left**的长度大1），这样做是为了方便对中部进行添加和删除操作。

在以下的六个操作中，我们需要一些调整来保持两个双端队列的平衡：

- 头部插入`pushFont`，在**left**的头部插入，如果插入之后**left**的长度比**right**大2，需要将**left**的尾部元素移动到**right**的头部。
- 中部插入`pushMiddle`，在**left**的尾部插入，若插入前**left**的长度比**right**大1，需要先将**left**的尾部移动到**right**的首部，然后再插入新元素。
- 尾部插入`pushBack`，在**right**的尾部插入，若插入后**right**的长度比**left**的长度大1，那么将**right**的首部元素移动到**left**的尾部。
- 头部删除`popFont`，若**left**为空则直接返回-1（因为当队列中有元素时，**left**总是不为空，以下同理），否则删除**left**的首部元素，若删除之后，**right**的长度比**left**大1，则需要将**right**的首部元素移动到**left**的尾部。
- 中部删除`popMiddle`，若**left**为空则返回-1，否则则删除**left**的尾部元素，若删除后**right**比**left**的长度大1，则将**right**的首部元素移动到**left**的尾部
- 尾部删除`popBack`，若**left**为空则返回-1，否则需要看**right**的长度：
  - 若**right**为空（此时队列中只有一个元素），删除**left**的尾部元素
  - 若**right**不为空，删除**right**的尾部元素，若删除后**left**的长度比**right**的长度大2，需要将**left**的尾部元素移动到**right**的首部

```java
class FrontMiddleBackQueue {
    Deque<Integer> left;
    Deque<Integer> right;
    public FrontMiddleBackQueue() {
        left = new ArrayDeque<>();
        right = new ArrayDeque<>();
    }
    
    public void pushFront(int val) {
        left.offerFirst(val);
        if(left.size()==right.size()+2)
            right.offerFirst(left.pollLast());
    }
    
    public void pushMiddle(int val) {
        if(left.size()==right.size()+1)
            right.offerFirst(left.pollLast());
        left.offerLast(val);
    }
    
    public void pushBack(int val) {
        right.offerLast(val);
        if(right.size()==left.size()+1)
            left.offerLast(right.pollFirst());
    }
    
    public int popFront() {
        if(left.isEmpty())
            return -1;
        int val = left.pollFirst();
        if(right.size()==left.size()+1)
            left.offerLast(right.pollFirst());
        return val;
    }
    
    public int popMiddle() {
        if(left.isEmpty())
            return -1;
        int val = left.pollLast();
        if(right.size()==left.size()+1)
            left.offerLast(right.pollFirst());
        return val;
    }
    
    public int popBack() {
        if(left.isEmpty())
            return -1;
        if(right.isEmpty())
            return left.pollLast();
        int val = right.pollLast();
        if(left.size()==right.size()+2)
            right.offerFirst(left.pollLast());
        return val;
    }
}

/**
 * Your FrontMiddleBackQueue object will be instantiated and called as such:
 * FrontMiddleBackQueue obj = new FrontMiddleBackQueue();
 * obj.pushFront(val);
 * obj.pushMiddle(val);
 * obj.pushBack(val);
 * int param_4 = obj.popFront();
 * int param_5 = obj.popMiddle();
 * int param_6 = obj.popBack();
 */
```