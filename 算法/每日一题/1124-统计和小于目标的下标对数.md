# 2824-统计和小于目标的下标对数目

[2824-统计和小于目标的下标对数目](https://leetcode.cn/problems/count-pairs-whose-sum-is-less-than-target/description/?envType=daily-question&envId=2023-11-24)，难度简单

![image-20231125205938050](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202311252059131.png)

题解：**二分搜索**

这里我们就不使用传统的暴力搜索了，使用一些有技巧的方法。

先排序，然后挨个遍历每一个值，再使用二分，具体看代码

```java
class Solution {
    public int countPairs(List<Integer> nums, int target) {
        //先排序
        Collections.sort(nums);
        int n = nums.size();
        int res = 0;
        for(int i=1; i<n; i++){
            int k = binarySearch(nums, 0, i-1, target - nums.get(i));
            res += k;
        }
        return res;
    }
    public int binarySearch(List<Integer> nums, int low, int high, int target){
        int res = high + 1;
        while(low <= high){
            int mid = low + (high - low)/2;
            if(nums.get(mid) >= target){
                res = mid;
                high = mid - 1;
            }else {
                low = mid + 1;
            }
        }
        return res;
    }
}
```



题解：**双指针**

先排序，然后固定一个`i`值，在`[i+1, n-1]`区间内寻找合理的`j`，最终满足题意的个数`j-i`。

```java
class Solution {
    public int countPairs(List<Integer> nums, int target) {
        Collections.sort(nums);
        int n = nums.size();
        int left = 0, right = n-1;
        int res = 0;
        while(left < right){
            while(left < right && nums.get(left) + nums.get(right)>=target){
                right--;
            }
            res += (right - left);
            left++;
            right = n-1;
        }
        return res;
    }
}
```

