# 1657-确定两个字符串是否接近

[1657-确定两个字符串是否接近](https://leetcode.cn/problems/determine-if-two-strings-are-close/description/?envType=daily-question&envId=2023-11-30)，难度中等

![image-20231201134620602](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202312011346786.png)

![image-20231201134636446](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202312011346528.png)

题解：**理解本质**

为了方便描述，我们把word1记作s，把word2记作t。

**操作1的本质：字符可以任意排列**

统计s和t中字符出现的次数，如果字符及其出现次数都一样，只用操作1就可以把s变换为t。

如果字符一样但是出现的操作次数不一样，那么只能用操作2了。

**操作2的本质：出现次数是可以交换的**

以实例3为例，统计s=cabbba的字符出现的次数：

- a出现2次
- b出现3次
- c出现1次

我们可以把a都变成b，同时把b都变成a。

这相当于把a和b的出现次数进行了交换，得到：

- a出现3次
- b出现2次
- c出现1次

然后交换a和c的出现次数，得到：

- a出现1次
- b出现2次
- c出现3次

这样便出现了字符t的情况，t=abbccc

所以出现次数也是像操作1那样，是可以任意排列的。

如果s和t的字符一样，并且出现次数集合是相同的（比如上面的例子中是{1,2,3}），那么操作1和操作2是可以把s变成t的。



**算法**

- 判断s和t的长度是否一样，如果不一样直接返回false。
- 判断s和t的字符集合是否一样，如果不一样直接返回false。
- 判断s的字符出现次数的集合和t的字符的出现次数的集合是否相等，相等则返回true，否则返回false。**注意集合可以有相同出现次数的元素，比如aabbbccc对应的集合为{2,3,3}。**

**实现细节**

判断字符集是否一样可以用位运算实现，也就是用二进制数（从低位到高位）第i位存储是否有第i个小写英文字母，这样只需要判断两个二进制数是否一样即可。具体请看 [从集合论到位运算，常见位运算技巧分类总结！](https://leetcode.cn/circle/discuss/CaOJ45/)

判断字符出现次数的集合是否一样，可以用两个长为26的数组统计s和t中每个字母的出现次数，分别记作sCnt和tCnt。如果这两个数组排序后是一样的，就说明s的字符出现次数的集合，等于t的字符出现次数的集合。

```java
class Solution {
    public boolean closeStrings(String word1, String word2) {
        int n1 = word1.length(), n2 = word2.length();
        if(n1!=n2)
            return false;
        int sMask = 0, tMask = 0;
        int[] sCnt = new int[26], tCnt = new int[26];
        for(byte b: word1.getBytes()){// 比 toCharArray 更快
            sMask |= 1<<(b-'a');
            sCnt[b-'a']++;
        }
        for(byte b: word2.getBytes()){
            tMask |= 1<<(b-'a');
            tCnt[b-'a']++;
        }
        Arrays.sort(sCnt);
        Arrays.sort(tCnt);
        return sMask==tMask && Arrays.equals(sCnt, tCnt);
    }
}
```

不用**位运算**：

```java
class Solution {
    public boolean closeStrings(String word1, String word2) {
        int n1 = word1.length(), n2 = word2.length();
        if(n1!=n2)
            return false;
        int[] sCnt = new int[26], tCnt = new int[26];
        for(byte b: word1.getBytes()){
            sCnt[b-'a']++;
        }
        for(byte b: word2.getBytes()){
            tCnt[b-'a']++;
        }
        for(int i=0; i<26; i++){
            if((sCnt[i]==0) != (tCnt[i]==0))
                return false;
        }
        Arrays.sort(sCnt);
        Arrays.sort(tCnt);
        return Arrays.equals(sCnt, tCnt);
    }
}
```

