# 274-指数

[274-指数](https://leetcode.cn/problems/h-index/description/?envType=daily-question&envId=2023-10-29)，难度中等，还有一道题：[275-指数II](https://leetcode.cn/problems/h-index-ii/description/?envType=daily-question&envId=2023-10-30)，解题方法类似

![image-20231029133436247](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310291334392.png)

题解：**滑动窗口**

这个方法的思路是我自己想出来的，主要思路如下：

首先对这个数组进行排序，然后维护一个滑动窗口，使滑动窗口内的数值都不小于窗口的大小，由于已经对其进行了排序，所以我得到的窗口内的元素一定是连续的；**如果在扩大窗口过程中，发现不满足要求，那就需要直接缩小窗口。**

```java
class Solution {
    public int hIndex(int[] citations) {
        // 先升序
        Arrays.sort(citations);
        int left = 0, right = 0;
        int n = citations.length;
        int window = 0;// 维护一个窗口
        int res = 0; // 返回的结果
        while(right < n){
            // 如果元素的值为0，直接不满足条件
            if(citations[right]==0){
                right++; left++;
                continue;
            }
            if(citations[right]>=window+1){
                window++;
                right++;
            }else{
                left++;
                window--;
            }
            while(citations[left]<window){
                left++;
                window--;
            }
            res = Math.max(res, window);
        }
        return res;
    }
}
```



官解：**排序**

首先我们将初始的`H`指数`h`设为0，然后将引用次数排序，并对排序后的数组从大到小遍历。

根据H指数的定义，如果当前`H`指数为`h`并且在遍历的过程中找到当前值`citations[i]>h`，则说明我们找到了一篇被引用了至少`h+1`次的论文，所以将现有的`h`值加1.继续遍历直到h无法增大。最后返回h作为最终的答案。

```java
class Solution {
    public int hIndex(int[] citations) {
        Arrays.sort(citations);
        int h = 0;
        int i = citations.length-1;
        while(i>=0 &&  citations[i]>h){
            h++;
            i--;
        }
        return h;
    }
}
```

> 时间复杂度：O(nlogn)，为排序的时间复杂度
>
> 空间复杂度：O(logn)，为排序的空间复杂度



官解：**计数排序**

根据上述的算法我们发现，最终的时间复杂度与排序算法的时间复杂度有关，所以我们可以使用计数排序算法，新建并维护一个数组`counter`用来记录当前引用次数的论文有几篇。

根据定义我们可以发现H指数不可能大于总的论文的发表数，所以对于引用次数超过论文发表数的情况，我们可以按照总的发表数来计算即可。这样我们可以限制参与排序的数的大小为`[0, n]`（其中`n`为总的论文发表数），使得计数排序的时间复杂度降低到`O(n)`。

最后我们可以从后往前遍历数组`counter`，对于每一个`0<=i<=n`，在数组`counter`中得到大于或等于当前引用次数`i`的总论文数。当我们找到一个H指数时，立马返回结果。

解释一下为什么在`counter`中找到一个大于或等于当前引用次数`i`的总论文数就可以直接返回结果？

是因为：当这个条件满足的时候，我们就可以知道满足引用次数大于`i`的论文有多少篇，因此我们可以直接这些论文中选择`i`篇论文即可，这`i`篇论文中一定都满足引用次数大于等于`i`。

```java
class Solution {
    public int hIndex(int[] citations) {
        int n = citations.length;
        int[] counter = new int[n+1];
        for(int i=0; i<n; i++){
            if(citations[i]>=n)
                counter[n]++;
            else
                counter[citations[i]]++;
        }
        int tol = 0;// 总的论文数
        for(int i=n; i>=0; i--){
            tol += counter[i];
            if(tol >= i)// 等于不能丢失，理由：寻找最大值
                return i;
        }
        return 0;
    }
}
```

> 时间复杂度：O(n)
>
> 空间复杂度：O(n)



题解：**二分搜索**

设查找范围的左边界`left`为0，初始右边界`right`为n。每次在查找范围内取中点`mid`，同时扫描整个数组，判断是否至少有`mid`个数大于`mid`。如果有，说明要寻找的`h`在搜索区间的右边，反之则在左边。

```java
class Solution {
    public int hIndex(int[] citations) {
        int n = citations.length;
        int left = 0, right = n;
        int mid = 0, cnt = 0;
        while(left < right){
            // +1 防止死循环
            mid = left + (right - left+1)/2;
            cnt = 0;
            for(int i=0; i<n; i++){
                if(citations[i]>=mid)
                    cnt++;
            }
            if(cnt>=mid){
                // 要找的答案在[mid, right]区间内,由于求的是个数，所以右区间是可取的
                left = mid;
            }else{
                // 由于cnt>=mid不满足，因此要找的答案在[0, mid)区间内
                // 要找的答案在[0, mid)区间内
                right = mid-1;
            }
        }
        return left;
    }
}
```

> 时间复杂度：O(nlogn)，其中n是数组citations的长度。需要进行logn次二分搜索，每次二分搜索需要遍历citations一次。
>
> 空间复杂度：O(1)，需要常量个变量来进行二分搜索

上面的代码还有另外一种写法：

```java
class Solution {
    public int hIndex(int[] citations) {
        int n = citations.length;
        int left = 0, right = n;
        int mid = 0;
        while(left < right){
            // +1 防止死循环
            mid = left + (right - left + 1)/2;
            if(check(citations, mid)){
                // 要找的答案在[mid, right]区间内,由于求的是个数，所以右区间是可取的
                left = mid;
            }else{
                // 由于cnt>=mid不满足，因此要找的答案在[0, mid)区间内
                // 要找的答案在[0, mid)区间内
                right = mid-1;
            }
        }
        return right;// 求右边界
    }
    public boolean check(int[] nums, int mid){
        int ans = 0;
        for(int i=0; i<nums.length; i++){
            if(nums[i]>=mid)
                ans++;
        }
        return ans>=mid;
    }
}
```

