# 2415-反转二叉树的奇数层

[2415-反转二叉树的奇数层](https://leetcode.cn/problems/reverse-odd-levels-of-binary-tree/description/?envType=daily-question&envId=2023-12-15)，难度中等

![image-20231216202416286](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed202312162024210.png)

![image-20231216202450318](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed202312162024337.png)

题解：**BFS**

我的代码：就是一个 简单的对栈和队列的考察

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode reverseOddLevels(TreeNode root) {
        int h = 0;
        Deque<TreeNode> dq = new ArrayDeque<>();
        dq.offer(root);
        while(!dq.isEmpty()){
            int sz = dq.size();
            if(h%2==1){
                Stack<Integer> stk = new Stack<>();
                Deque<TreeNode> dq1 = new ArrayDeque<>(dq);
                for(int i=0; i<sz; i++){
                    TreeNode tn = dq1.poll();
                    stk.push(tn.val);
                }
                for(int i=0; i<sz; i++){
                    TreeNode cur = dq.poll();
                    cur.val = stk.pop();
                    if(cur.left!=null){
                        dq.offer(cur.left);
                        dq.offer(cur.right);
                    }
                }
            }else{
                for(int i=0; i<sz; i++){
                    TreeNode cur = dq.poll();
                    if(cur.left!=null){
                        dq.offer(cur.left);
                        dq.offer(cur.right);
                    }
                }
            }
            h++;
        }
        return root;
    }
}
```

题解：**BFS**

官方：

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode reverseOddLevels(TreeNode root) {
        boolean isOod = false;
        Deque<TreeNode> dq = new ArrayDeque<>();
        dq.offer(root);
        while(!dq.isEmpty()){
            int sz = dq.size();
            List<TreeNode> arr = new ArrayList<>();
            for(int i=0; i<sz; i++){
                TreeNode cur = dq.poll();
                if(isOod)
                    arr.add(cur);
                if(cur.left!=null){
                    dq.offer(cur.left);
                    dq.offer(cur.right);
                }
            }
            if(isOod){
                for(int l=0, r=sz-1; l<r; l++, r--){
                    int tmp = arr.get(r).val;
                    arr.get(r).val = arr.get(l).val;
                    arr.get(l).val = tmp;
                }
            }
            isOod ^= true;
        }
        return root;
    }
}
```

题解：**DFS**

![image-20231216204738379](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed202312162047415.png)

![image-20231216204818623](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed202312162048169.png)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode reverseOddLevels(TreeNode root) {
        dfs(root.left, root.right, true);
        return root;
    }
    public void dfs(TreeNode left, TreeNode right, boolean isSwap){
        if(left==null) return;
        if(isSwap){
            int tmp = left.val;
            left.val = right.val;
            right.val = tmp;
        }
        dfs(left.left, right.right, !isSwap);
        dfs(left.right, right.left, !isSwap);
    }
}
```

