# 2731-移动机器人

[2731-移动机器人](https://leetcode.cn/problems/movement-of-robots/description/?envType=daily-question&envId=2023-10-10)，难度中等

![image-20231011100847548](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310111008650.png)

先说说自己的思路，最开始的时候，先创建一个有序集合，集合里面的元素是数组，每一个数组包含每个机器人的==索引，位置，方向== 三个信息，然后通过for循环模拟在`d`时间内机器人的**位置移动**以及**方向的改变**情况，但是在模拟的过程中不好处理每相邻两个机器人之间的位置和方向关系，容易导致一个机器人同时被多次处理（也就是位置和方向可能会被多次改变），之所以会被这样改变，是因为没有考虑到相邻两个机器人之间的关系。

下面是题解的思路，上面提到我有一个关键的思路没有考虑到，那就是题目中说==“两个机器人相撞后，两个机器人的位置视为相同的坐标对，也就是说，两个机器人无差别”==，这句话十分的关键，如果没有看到这一点信息，特别容易被题目迷惑。看清了这一点，解题就十分容易了。

既然两个机器人视为无差别，那么我们完全不用考虑机器人相撞后改变方向的问题，==就相当于机器人在相撞时穿过了对方==，直接让机器人在`d`时间内行进就行。

因此就有了下面的代码。

```java
class Solution {
    int MOD = 1000000007;
    public int sumDistance(int[] nums, String s, int d) {
        // 无视相撞
        int n = nums.length;
        long[] pos = new long[n];
        for(int i=0; i<n; i++){
            if(s.charAt(i)=='L'){
                pos[i] = (long)nums[i] - d;
            }else{
                pos[i] = (long)nums[i] + d;
            }
        }
        Arrays.sort(pos);
        long res = 0l, sum = 0l;
        for(int i=0; i<n; i++){
            res = (res + pos[i]*i - sum)%MOD;
            sum += pos[i];
        }
        return (int)res;        
    }
}
```

这段代码有三个提示需要注意：

- 提示1：题目最后要求机器人之间的距离，此时把任意两个机器人的位置交换，并不会对答案产生影响。

  - 假设机器人的位置数组为[1,2,3]，那么交换后成[2,1,3]，所有机器人之间的两两距离之和保持不变
  - 既然如此，那么可以把机器人都堪称是**完全一样的，无法区分。**

- 提示2：相撞等价于**机器人互相穿过对方**，因为我们**无法区分机器人**。

  - 类似思路在 **1503-所有蚂蚁掉下前的最后一刻** 中出现过
  - 所以无视规则，把每个机器人都看成是独立运动

- 提示3：设`d`秒后机器人的位置数组为`a`，根据提示1，可以把数组`a`从大到小排序，再计算所有机器人之间的两两距离之和。从小到大枚举`a[i]`，此时左边有`i`个数都不超过`a[i]`，那么`a[i]`与其左侧机器人的距离之和为

  $(a[i]-a[0])+(a[i]-a[1])+...+(a[i]-a[i-1])=i*a[i] - (a[0]+a[1]+...+a[i-1])$

  其中$a[0]+a[1]+...+a[i-1]$可以一边遍历`a`，一边计算出来。

- 在计算$i*a[i]$的时候，不能对其取模，因为可能导致数值的大小被改变，导致出错

