# 2603-收集树中的金币

[2603-收集树中的金币](https://leetcode.cn/problems/collect-coins-in-a-tree/description/?envType=daily-question&envId=2023-09-21)，难度困难

![image-20230921162712720](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202309211627709.png)

题解：根据官方题解的意思，这种方法叫做两次拓扑排序。

不过，我对比了一下我的思路和官方题解的思路，解题的方法大同小异，因此下面我将介绍我自己的思路。

首先，我们观察题目中的树，与其说是一棵树，倒不如说是一幅图，在这幅图中每个节点都有至少为1的度。其次，这棵树是一颗合法的树，说明是不存在环的，题解中也说明了n个定点有n-1条边，这个信息很重要。

如题意，如果我们想要求解经过的最少的边数，则一定要将起始点选择距离有金币的点的距离为2或2以上的点的位置。具体过程如下：

- 树中的没有金币的叶子节点对我们来说是无用的，因此可以删除
- 此时树中的叶子节点就全是有金币的点
- 因为我们可以从距离为2的位置出收集金币，所以我们需要收集距离为2或2以上的节点的个数有多少个，如果能够求得出个数，那么我们就可以求得出边数，因此也就是确定经过的边数为$2\times (n^, -1)$
- 求解的过程中使用了两边对列，具体代码如下：
- 解题技巧，注意：==度，图，对列== 结合

```java
class Solution {
    public int collectTheCoins(int[] coins, int[][] edges) {
        int n = coins.length;
        int[] indegree = new int[n];
        List<Integer>[] graph = new ArrayList[n];
        for(int i=0; i<n; i++){
            graph[i] = new ArrayList<>();
        }
        for(int[] edge: edges){
            indegree[edge[0]]++;
            indegree[edge[1]]++;
            graph[edge[0]].add(edge[1]);
            graph[edge[1]].add(edge[0]);
        }

        // 记录入度
        Deque<Integer> dq = new ArrayDeque<>();
        for(int i=0; i<n; i++){
            if(indegree[i]==1 && coins[i]!=1){
                dq.add(i);
            }
        }
        // 删除初始时入度为1的点
        while(!dq.isEmpty()){
            int cur =dq.poll();
            // 将该节点的入度-1
            indegree[cur]--;
            for(int num: graph[cur]){
                // 入度-1
                indegree[num]--;
                graph[num].remove(Integer.valueOf(cur));
                if(indegree[num]==1 && coins[num]!=1)
                    dq.add(num);
            }
            graph[cur].clear();
        }

        // 度为1的节点
        for(int i=0; i<n; i++){
            if(indegree[i]==1 && coins[i]==1){
                dq.add(i);
            }
        }
        int flag = 0;
        while(!dq.isEmpty()){
            int sz = dq.size();
            if(flag>1) break;
            for(int i=0; i<sz; i++){
                int cur = dq.poll();
                indegree[cur]--;
                for(int nn: graph[cur]){
                    indegree[nn]--;
                    graph[nn].remove(Integer.valueOf(cur));
                    if(indegree[nn]==1)
                        dq.add(nn);
                }
                graph[cur].clear();
            }
            flag++;
        }
        // 看看还有多少个点
        int cnt = 0;
        for(int i=0; i<n; i++){
            if(graph[i].size()!=0){
                cnt++;
            }
        }
        return 2*(cnt-1)<0? 0: 2*(cnt-1);
    }
}
```