# 1726-同积元祖

[1726-同积元祖](https://leetcode.cn/problems/tuple-with-same-product/description/?envType=daily-question&envId=2023-10-19)，难度中等

![image-20231019103445054](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310191034133.png)

题解：这道题需要仔细分析一下题意，先来说说我自己的思路：我首先看到这道题，我首先想到的就是使用 **递归+备忘录** 进行枚举，因为这是最快也是最熟悉的方案。代码如下：

```java
class Solution {
    int res = 0;
    public int tupleSameProduct(int[] nums) {
        Arrays.sort(nums);
        List<Integer> path = new ArrayList<>();
        dfs(nums, path, 0);
        return 8*res;
    }
    public void dfs(int[] nums, List<Integer> path, int i){
        if(path.size()>4) return;
        if(path.size()==4){
            if(path.get(0)*path.get(3)==path.get(1)*path.get(2)){
                res++;
            }
            return;
        }
        if(i>=nums.length) return;
        // 第i个节点算进去
        path.add(nums[i]);
        dfs(nums, path, i+1);
        path.remove(path.size()-1);

        // 第i个节点不算
        dfs(nums, path, i+1);
    }
}
```

其实这个代码没什么大问题，但是如果数据量太大的话，时间复杂度就会比较高。因此这个方法并没有A掉所有用例，因此这个方法不太好。

接下来就需要好好分析一下题意了。

首先题目给的数组中的元素都是不相同，如果存在两对数据对(a, b)的乘积相等，那么这四个数一定都不是相等的，因此我们可以转换一下思路，我们可以统计得到同一个乘积的有多少个数据对，最后在数据对中枚举两个数据对即可满足条件，有了这个思路，因此我们就可以使用上**哈希表**。

```java
class Solution {
    public int tupleSameProduct(int[] nums) {
        HashMap<Integer, Integer> hm = new HashMap<>();
        for(int i=0; i<nums.length; i++){
            for(int j=i+1; j<nums.length; j++){
                hm.put(nums[i]*nums[j], hm.getOrDefault(nums[i]*nums[j], 0)+1);
            }
        }   
        int res = 0;
        for(Map.Entry<Integer, Integer> entry: hm.entrySet()){
            res += (entry.getValue() * (entry.getValue()-1))/2;
        }
        return res*8;
    }
}
```