# 1222-可以攻击国王的皇后

[1222-可以攻击国王的皇后](https://leetcode.cn/problems/queens-that-can-attack-the-king/?envType=daily-question&envId=2023-09-14)，难度中等

![image-20230914140620988](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202309141406874.png)

题解：从国王的角度出发，寻找国王周边的皇后

```java
class Solution {
    public List<List<Integer>> queensAttacktheKing(int[][] queens, int[] king) {
        // 统计黑皇后
        Set<Integer> queSet = new HashSet<>();
        for(int[] qus: queens){
            queSet.add(qus[0]*8 + que[1]);
        }
        List<List<Integer>> res = new ArrayList<>();
        int kx = king[0], ky = king[1];
        // 八个方向
        for(int i=-1; i<=1; i++){
            for(int j=-1; j<=1; j++){
                if(i==0 && j==0) continue;
                int x = kx + i, y = ky + j;
                while(x<8 && x>=0 && y<8 && y>=0){
                    if(queSet.contains(x*8+y)){
                        List<Integer> tmp = new ArrayList<>();
                        tmp.add(x);
                        tmp.add(y);
                        res.add(tmp);
                        break;
                    }
                    x += i; y += j;
                }
            }
        }
        return res;
    }
}
```

题解：从皇后的角度出发，判断是否在国王的八个方向上，如果是，说明皇后可以攻击到国王。

```java
class Solution {
    public List<List<Integer>> queensAttacktheKing(int[][] queens, int[] king) {
        int kx = king[0], ky = king[1];
        Map<Integer, int[]> candidates = new HashMap<>();

        for(int[] queen: queens){
            int qx = queen[0], qy = queen[1];
            int x = qx - kx, y = qy - ky;
            if(x==0 || y==0 || Math.abs(x)==Math.abs(y)){
                // 方向
                int dx = sign(x), dy = sign(y);
                int direction = dx*10 + dy;
                if(!candidates.containsKey(direction) || candidates.get(direction)[2] > Math.abs(x) + Math.abs(y)){
                    candidates.put(direction, new int[]{qx, qy, Math.abs(x) + Math.abs(y)});
                }
            }
        }
        List<List<Integer>> res = new ArrayList<>();
        for(Map.Entry<Integer, int[]> entry: candidates.entrySet()){
            int[] val = entry.getValue();
            List<Integer> tmp = new ArrayList<>();
            tmp.add(val[0]);
            tmp.add(val[1]);
            res.add(tmp);
        }
        return res;
    }
    
    public int sign(int x){
        return x>0? 1: (x==0? 0: -1);
    }
}
```

