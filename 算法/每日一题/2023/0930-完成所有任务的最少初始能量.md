# 1665-完成所有任务的最少初始能量

[1665-完成所有任务的最少初始能量](https://leetcode.cn/problems/minimum-initial-energy-to-finish-tasks/)，难度困难，与 [2136-全部开花的最早一天](https://leetcode.cn/problems/earliest-possible-day-of-full-bloom/solutions/1202113/quan-bu-kai-hua-de-zui-zao-yi-tian-by-le-ocxg/) 类似

![image-20230930231347811](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202309302313907.png)

题解：

![image-20230930231521343](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202309302315438.png)

![image-20230930231542967](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202309302315046.png)

代码：我自己写的代码：

```java
class Solution {
    public int minimumEffort(int[][] tasks) {
        // 计算能量差
        int n = tasks.length;
        int[] cha = new int[n];
        for(int i=0; i<n; i++){
            cha[i] = tasks[i][1] - tasks[i][0];
        }
        Integer[] idx = IntStream.range(0, n).boxed().toArray(Integer[]::new);
        Arrays.sort(idx, (i, j)->cha[j]-cha[i]);
        // 倒着计算
        int power = 0;
        for(int i=n-1; i>=0; i--){
            power = Math.max(power+tasks[idx[i]][0], tasks[idx[i]][1]);
        }
        return power;
    }
}
```

官解：

```java
class Solution {
    public int minimumEffort(int[][] tasks) {
        int minEnergy = 0;
        Arrays.sort(tasks, (a, b) -> (b[1] - b[0]) - (a[1] - a[0]));
        for (int i = tasks.length - 1; i >= 0; i--) {
            int[] task = tasks[i];
            minEnergy = Math.max(minEnergy + task[0], task[1]);
        }
        return minEnergy;
    }
}
```

