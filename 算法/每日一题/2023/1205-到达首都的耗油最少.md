# 2477-到达首都的耗油最少

[2477-到达首都的耗油最少](https://leetcode.cn/problems/minimum-fuel-cost-to-report-to-the-capital/description/?envType=daily-question&envId=2023-12-05)，难度中等

![image-20231206211325555](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202312062114613.png)

![image-20231206211608690](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202312062116752.png)

![image-20231206211625668](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202312062116213.png)

题解：**贪心+深度优先搜索**

题目等价于给出了一颗以节点0作为根节点的树，并且初始树上的每一个节点上都有一个人，现在所有人都需要通过车子向节点0移动。

对于某一个节点`x`，`x`不等于0，其父节点为`y`，因为以节点`x`为根节点的子树上的人都需要通过边$x \to y$向0节点移动，所以为了使这条边上的车子利用率最高，我们贪心的让`x`的全部子节点上的人到了节点`x`后再一起坐车向上移动，我们不妨设以节点`x`为根节点的子树大小为$cnt_x$，那么我们至少需要车子的数量为$(cnt_x)/seats$，其中seats为一辆车的给定的座位数。

那么我们可以通过从根节点0往下进行深度优先搜索，每一条边上车子的数目即为该条边上汽油的开销，统计全部边上汽油的开销即为最终的答案。

```java
class Solution {
    long res = 0l;
    public long minimumFuelCost(int[][] roads, int seats) {
        int n = roads.length+1;
        List<Integer>[] g = new ArrayList[n];
        Arrays.setAll(g, e->new ArrayList<>());
        for(int[] road: roads){
            int x = road[0], y = road[1];
            g[x].add(y); g[y].add(x);
        }
        dfs(0, -1, g, seats);
        return res;
    }
    public int dfs(int x, int fa, List<Integer>[] g, int seats){
        int size = 1;
        for(int y: g[x]){
            if(y!=fa){
                size += dfs(y, x, g, seats);
            }
        }
        if(x>0)
            res += ((size + seats - 1)/seats);
        return size;
    }
}
```