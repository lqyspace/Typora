# 1761-一个图中联通三元组的最小度数

[1761-一个图中连通三元组的最小度数](https://leetcode.cn/problems/minimum-degree-of-a-connected-trio-in-a-graph/description/)，难度困难

![image-20230831170132015](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308311701242.png)

**官方题解**：

方法一：暴力枚举

![image-20230831170247040](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308311702120.png)

```java
class Solution {
    public int minTrioDegree(int n, int[][] edges) {
		// 预处理一个节点的度
        int[] degree = new int[n];
        // 邻接矩阵
        int[][] matrix = new int[n][n];
        for(int[] edge: edges){
            degree[edge[0]-1]++;
            degree[edge[1]-1]++;
            matrix[edge[0]-1][edge[1]-1] = 1;
            matrix[edge[1]-1][edge[0]-1] = 1;
        }
        // 剪枝
        HashSet<Integer> hs = new HashSet<>();
        for(int i=0; i<n; i++){
            if(degree[i]==1)
                hs.add(i);
        }
        
        int res =Integer.MAX_VALUE;
        // 三重循环
        for(int i=0; i<n; i++){
            if(hs.contains(i)) continue;
            for(int j=i+1; j<n; j++){
                if(hs.contains(j)) continue;
                for(int k=j+1; k<n; k++){
                    if(hs.contains(k)){
                        continue;
                    }
                    if(matrix[i][j]!=1 || matrix[i][k]!=1 || matrix[j][k]!=1)continue;
                    res = Math.min(res, degree[i]+degree[j]+degree[k]-6);
                }
            }
        }
        return res==Integer.MAX_VALUE? -1: res;
    }
}
```

时间复杂度：$O(n^3)$

空间复杂度：$O(n^2)$



![image-20230831171847681](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308311718773.png)

好好看看证明过程，一定要注意，提前规定了**小度数的节点指向了大度数的节点，度数相同的话编号小的指向编号大的**。我自己就是因为没有注意到这个前提条件，所以证明过程愣是没有看懂。

```java
class Solution {
    public int minTrioDegree(int n, int[][] edges) {
		// 提前处理度数
        int[] degree = new int[n];
        // 定向图
        List<Integer>[] graph = new LinkedList[n];
        // 原图
        Set<Integer>[] set = new Set[n];
        
        for(int i=0; i<n; i++){
            graph[i] = new LinkedList<>();
            set[i] = new HashSet<>();
        }
        
        for(int[] edge: edges){
            int x = edge[0]-1, y = edge[1]-1;
            degree[x]++;
            degree[y]++;
            set[x].add(y);
            set[y].add(x);
        }
        
        for(int[] edge: edges){
            int x = edge[0]-1, y = edge[1]-1;
            if(degree[x] > degree[y]){
                graph[y].add(x);
            } else if(degree[x] < degree[y]){
                graph[x].add(y);
            } else {
                if(x<y) graph[x].add(y);
                else graph[y].add(x);
            }
        }
        int res = Integer.MAX_VALUE;
        // 枚举
        for(int i=0; i<n; i++){
            for(int j: graph[i]){
                for(int k: graph[j]){
                    if(set[i].contains(k)){
                        res = Math.min(res, degree[i]+degree[j]+degree[k]-6);
                    }
                }
            }
        }
        return res==Integer.MAX_VALUE? -1: res;
    }
}
```





















