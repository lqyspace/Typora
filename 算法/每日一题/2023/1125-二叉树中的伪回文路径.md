# 1457-二叉树中的伪回文路径

[1457-二叉树中的伪回文路径](https://leetcode.cn/problems/pseudo-palindromic-paths-in-a-binary-tree/description/?envType=daily-question&envId=2023-11-25)，难度中等

![image-20231125195250994](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202311251952360.png)

题解：**深度优先搜索**

根据题意，我们想要知道 **从根节点到叶子节点的路径中的节点是否可以组成伪回文路径**，那么我就需要遍历每一条路径，因此使用的方法就是**深度优先搜索遍历**。

我们来分析一下伪回文路径的数字的特点，如果可以组成伪回文路径，那么数字的个数的特点就是：个数为偶数的元素可以有多个，比如有偶数个2，偶数个3等；但是我们知道，如果个数为奇数的元素，该元素最多只能有一个。

换句话说，如果序列的个数为偶数个，那么序列中的每个元素**肯定都是偶数个**，如果不满足的话，那么一定不是伪回文路径；如果序列的个数为奇数个，**那么除了中间的那个位置，其他的位置的元素的个数一定都是偶数个，也就是说有一个元素的个数是奇数个**。总的来说，**这个路径序列中最多只有一个元素的个数为奇数**。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int res = 0;
    public int pseudoPalindromicPaths (TreeNode root) {
        // if(root==null) return 0;
        // if(root.left==null && root.right==null) return 1;
        int[] cnt = new int[10];
        dfs(root, cnt);
        return res;
    }
    public void dfs(TreeNode root, int[] cnt){
        if(root==null) return;
        cnt[root.val]++;
        if(root.left==null && root.right==null){
            int ans = 0;
            for(int i=0; i<10; i++){
                if(cnt[i]%2==1)//奇数的个数只能少于等于一个
                        ans++;
            }
            if(ans<=1)
                res++;
            cnt[root.val]--;
            return;
        }
        dfs(root.left, cnt);
        dfs(root.right, cnt);
        cnt[root.val]--;
    }
}
```

官方：

```java
class Solution {
    public int pseudoPalindromicPaths (TreeNode root) {
        int[] counter = new int[10];
        return dfs(root, counter);
    }

    public int dfs(TreeNode root, int[] counter) {
        if (root == null) {
            return 0;
        }
        counter[root.val]++;
        int res = 0;
        if (root.left == null && root.right == null) {
            if (isPseudoPalindrome(counter)) {
                res = 1;
            }
        } else {
            res = dfs(root.left, counter) + dfs(root.right, counter);
        }
        counter[root.val]--;
        return res;
    }

    public boolean isPseudoPalindrome(int[] counter) {
        int odd = 0;
        for (int value : counter) {
            if (value % 2 == 1) {
                odd++;
            }
        }
        return odd <= 1;
    }
}
```