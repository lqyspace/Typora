# 1488-避免洪水泛滥

[1488-避免洪水泛滥](https://leetcode.cn/problems/avoid-flood-in-the-city/description/?envType=daily-question&envId=2023-10-13)，难度中等

![image-20231013125857304](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310131258526.png)

题解：贪心+二分查找

这道题其实说简单也挺简单，说难也挺难，主要是看能不能想到这个思路。

首先，0是作为将湖泊放水的契机，为了尽可能不发生洪水，所以如果遇到0的话，就一定要放水，这就涉及了贪心的思路。

其次，如果不为0的话，说明这一天要下雨，在下雨的时候，一定要判断是否会发生洪水，如果是第一次下雨，则一定不会发生洪水，如果不是第一次下雨，那就需要考虑是不是有可能发生洪水。

再就是需要考虑如果泄洪的时机一定是早于湖泊长满水的时机的，湖泊一定要是满的放水才有意义，湖泊如果是空的，那么放水就没有意义。

因此在解题的时候使用哈希集合存储天晴的时机，如果需要放水时，则一定需要考虑天晴的时间一定要大于等于洪水满的时机，如果在湖水满了以后没有了天晴的时机，那么就一定会发生洪水。

同时使用了HashMap来存储这个湖泊是不是第一次下雨，第一次下雨的话不用考虑发生洪水的可能，因为最开始的所有湖泊都是空的。如果不是第一次下雨则需要考虑发生洪水的可能，如果没有来得及释放洪水，那么就一定会发生洪水。

因此代码如下：

```java
class Solution{
    public int[] avoidFlood(int[] rains) {
        int n = rains.length;
        TreeSet<Integer> st = new TreeSet<>();
        int[] ans = new int[n];
        Arrays.fill(ans, 1);
        HashMap<Integer, Integer> mp = new HashMap<>();
        for(int i=0; i<n; i++){
            if(rains[i]==0)
                st.add(i);
            else {
                ans[i] = -1;
                if(mp.containsKey(rains[i])){
                    // 说明已经满了, 返回可用的晴天的索引
                    Integer it = st.ceiling(mp.get(rains[i]));
                    if(it==null)
                        return new int[]{};
                    ans[it] = rains[i];// 该索引位置赋值
                    st.remove(it);// 删除该索引
                }
                mp.put(rains[i], i);
            }
        }
        return ans;
    }
}
```

