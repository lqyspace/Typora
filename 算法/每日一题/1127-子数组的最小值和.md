# 907-子数组的最小值之和

[907-子数组的最小值之和](https://leetcode.cn/problems/sum-of-subarray-minimums/description/)，难度中等

![image-20231127233207122](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed202311272333381.png)

题解：**单调栈**

**提示1：计算以$arr[i]$为最小值的子数组的个数**

暴力做法是枚举所有的子数组，算出每个子数组的最小值，但是这个太慢了。

不防换个视角，对每个数，算出它是哪些子数组的最小值。

例如：$arr=[1,4,2,3,1]$，其中`2`是子数组[2], [4,2], [2,3], [4,2,3]的最小值，那么2对答案的贡献就是 2*4=8。

由于以2为最小值的子数组，绝对不能包含比2小的数字，因此我们可以找到2左右两侧比它小的数字的下标，从而确定子数组的边界。2对应的边界为开区间(0, 4)，即闭区间[1, 3]，只要闭区间[1, 3]范围内且包含下标2 的子数组，就是以2为最小值的子数组。

一般的，设$arr[i]$对应的边界的**开区间**$(L, R)$，由于子数组必须包含$arr[i]$：

- 子数组的左端点可以是$L+1$，$L+2$，$\dots$，$i$，共有$i-L$个。
- 子数组的右端点可以是$i$，$i+1$，$i+2$，$\dots$，$R-1$，共有$R-i$个。

因此在$arr$不含有重复元素的前提下，根据乘法原理，我们可以得出如下的结论：

以$arr[i]$为最小值的子数组的个数为$(i-L)*(R-i)$，对答案的贡献为$arr[i]*(i-L)*(R-i)$。

> **注意：**如果左侧没有比$arr[i]$小的元素，则$L=-1$；如果右侧没有比$arr[i]$小的元素，则$R=n$。



**提示2：修改边界定义，避免重复统计子数组**

如果`arr`有重复元素，例如：arr=[1, 2, 4, 2, 3, 1]，其中第一个2和第二个2对应的边界都是开区间(0, 5)，子数组[2, 4, 2, 3]都包含这两个2，这样在计算答案时就会重复统计同一个子数组，算出错误的结果。

为避免重复统计，可以修改边界的定义，把右边界改为**找小于等于arr[i]的元素的下标**，那么：

- 第一个2对应的边界就是(0, 3)，子数组需要在(0, 3)范围内且包含下标1；
- 第二个2对应的边界就是(0, 5)，子数组需要在(0, 5)范围内且包含下标3；

这样第一个2为最小值的子数组，就不会越界包含第二个2了，从而解决了重复统计子数组的问题。

> **注意：**也可以把左边界改为<=，右边界保持不变(仍为 <)。根据对称性，算出来的答案是一样的。



**提示3：高效计算边界**

最后需要解决的问题就是，如何高效计算每个arr[i]对应的左右边界？

以计算左边界为例，从左到右遍历arr，同时用某个合适的数据结构维护遍历过的元素 ，并**及时移除无用的元素**，如下图（arr简写成a）：

![image-20231127235925893](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed202311272359794.png)

移除无用元素后，再把arr[i]加入到这个数据结构中。

由于该优化保证了数据结构中的元素进行成一个递增的序列，因此我们移除的是数据结构中最右端的的若干元素。我们需要一个数据结构，它支持移除最右端的元素，以及在最右端添加元素。故选用**栈**。

移除栈中 $>= arr[i]$的元素后，栈顶的下标就是$arr[i]$的左边界，如果此时栈为空，那么左边界为-1。

> **注意：**在遍历的过程中会维护一个栈，移除的是当前的栈顶元素，遍历到$arr[i]$时，$arr[i]$及其右侧元素尚未入栈。
>
> **注意：**由于栈内元素始终保持单调递增，因此这种数据结构叫做**单调栈**。

右边界的计算是类似的，从右往左遍历arr可以算出，与计算左边界类似。

算出左右边界后 ，根据公式：$\sum_{i}^{n}arr[i]*(i-L)*(R-i)$ 求出答案。



**第一版：三次遍历**

```java
class Solution{
    private static final long MOD = (long)1e9+7;
    public int sumSubarrayMins(int[] arr) {
        int n = arr.length;
        int[] left = new int[n];
        int[] right = new int[n];
        Deque<Integer> stk = new ArrayDeque<>();// 记录索引，单调栈
        stk.push(-1);// 便于赋值
        for(int i=0; i<n; i++){
            while(stk.size()>1 && arr[stk.peek()]>=arr[i]){
                stk.poll();
            }
            left[i] = stk.peek();
            stk.push(i);
        }
        
        stk.clear();
        stk.push(n);
        for(int i=n-1; i>=0; i--){
            while(stk.size()>1 && arr[stk.peek()]>arr[i]){
                stk.poll();
            }
            right[i] = stk.peek();
            stk.push(i);
        }
        
        long ans = 0l;
        for(int i=0; i<n; i++){
            ans += (long)arr[i]*(i-left[i])*(right[i]-i);
        }
        return (int)(ans % MOD);
    }
}
```



**第二版：两次遍历**

注意到在计算left的过程中，如果栈顶元素$>=arr[i]$，那么`i`就是栈顶元素的右边界，因此前两个循环可以合并 。

详解：对于栈顶元素`t`，如果`t`右侧有多个小于等于`t`的元素，那么`t`只会因为右侧第一个小于或等于t的元素而出栈，这恰好符合右边界的定义。

```java
class Solution{
    private static final long MOD = (long)1e9+7;
    public int sumSubarrayMins(int[] arr) {
        int n = arr.length;
        int[] left = new int[n];
        int[] right = new int[n];
        Arrays.fill(right, n);
        Deque<Integer> stk = new ArrayDeque<>();
        stk.push(-1);
        for(int i=0; i<n; i++){
            while(stk.size()>1 && arr[stk.peek()]>=arr[i]){
                right[stk.poll()] = i;
            }
            left[i] = stk.peek();
            stk.push(i);
        }
        
        long ans = 0l;
        for(int i=0; i<n; i++){
            ans += (long)arr[i]*(i-left[i])*(right[i]-i);
        }
        return (int)(ans%MOD);
    }
}
```



**第三版：一次遍历**

进一步的，由于栈顶下面的元素也是栈顶的左边界，所以甚至连left和right都可以省了，直接在出栈的时候进行计算。

为了简化代码逻辑，可以在遍历前，往arr末尾和栈顶分别加一个-1，当作哨兵。

```java
class Solution{
    private static final long MOD = (long)1e9+7;
    public int sumSubarrayMins(int[] arr) {
        int n = arr.length;
        Deque<Integer> stk = new ArrayDeque<>();
        stk.push(-1);
        long ans = 0l;
        for(int i=0; i<=n; i++){
            int x = i<n? arr[i]:-1;
            while(stk.size()>1 && arr[stk.peek()]>=x){
                int j = stk.poll();
                ans += (long)arr[j]*(j-stk.peek())*(i-j);
            }
            stk.push(i);
        }
        return (int)(ans%MOD);
    }
}
```