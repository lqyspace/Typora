# 605-种花问题

[605-种花问题](https://leetcode.cn/problems/can-place-flowers/description/)，难度简单

![image-20230929100342203](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202309291003356.png)

题解：

**方法一：贪心**

判断能否在不打破种植规则的情况下在花坛内种入n朵花，从贪心的角度考虑，应该在不打破种植规则的情况种入尽可能多的花，然后判断可以种入的花的最多数量是否大于或等于n。

假设花坛的下标`i`和下标`j`处都种植了花，其中`j-i>=2`，且在下标`[i+1, j-1]`范围内没有种植花，则只有在`j-i>=4`的情况下才能在下标`i`和下标`j`之间种花，且可以种植花的范围是`[i+2, j-2]`。因此可以确定可以种植花的位置个数是`p=j-i-3`，当`p`是奇数时，最多可以在该范围内种植`(p+1)/2`朵花，当`p`是偶数时，最多可以在该范围内种植`p/2`朵花，因此我们可以推断，无论p是奇数还是偶数，我们都可以在范围内种植`(p+1)/2`朵花，因此最多可以在该范围内种植`(j-i-2)/2`朵花。

上面的情况我们讨论了在两个花坛之间可以种植的最多的花坛的个数，同时我们还需要考虑第一个花坛之前和最后一个花坛之后这两种情况我们可以种植多少多花。假设第一个花坛的下标为`l`，那么第一个花坛之前最多可以种植`(l-2+1)/2`朵花；假设最后一个花坛的下标为`r`，数组的长度为`n`，那么最后一个花坛之后最多可以种植`(n-r-2+1)/2`朵花。

如果花坛中没有种植任何花，那么`n`个位置就可以种植`(n+1)/2`朵花。

根据以上的计算方法，计算出花坛最多可以种植的花的个数，然后判断是否大于或等于`n`即可。具体做法如下：

- 维护`prev`表示上一个已经种植的花的下标位置，初始时`prev=-1`，表示尚未遇到已经种植的花
- 从左到右遍历数组，如果当前位置为1，则计算`prev`与当前位置间最多可以种植多少朵花，然后在当前位置赋值给`prev`
- 遍历数组结束后，根据数组`prev`和长度`m`的值计算最后一个区间内可以种植花的最多的数量。
- 判断种植的数量是否大于等于n

```java
class Solution {
    public boolean canPlaceFlowers(int[] flowerbed, int n) {
        int prev = -1;
        int cnt = 0;
        int m = flowerbed.length;
        for(int i=0; i<m; i++){
            if (flowerbed[i]==1){
                if(prev==-1){
                    cnt += i/2;
                }else{
                    cnt += (i-prev-2)/2;
                }
                prev = i;
            }
        }
        if(prev==-1)
            cnt += (m+1)/2;
        else{
            cnt += (m-prev-1)/2;
        }
        return cnt>=n;
    }
}
```

由于只需要判断能否在不打破规则的情况下可以在花坛内种植n朵花，因此不需要具体知道最多可以种植多少朵花，可以在循环内进行优化，当花朵的数量已经到达了n，则直接返回true，不需要计算剩余的部分。

```java
class Solution {
    public boolean canPlaceFlowers(int[] flowerbed, int n) {
        int prev = -1;
        int cnt = 0;
        int m = flowerbed.length;
        for(int i=0; i<m; i++){
            if (flowerbed[i]==1){
                if(prev==-1){
                    cnt += i/2;
                }else{
                    cnt += (i-prev-2)/2;
                }
                if(cnt>=n) return true;
                prev = i;
            }
        }
        if(prev==-1)
            cnt += (m+1)/2;
        else{
            cnt += (m-prev-1)/2;
        }
        return cnt>=n;
    }
}
```

