# 45-跳跃游戏II

[45-跳跃游戏II](https://leetcode.cn/problems/jump-game-ii/description/?envType=study-plan-v2&envId=top-interview-150)，难度中等

![image-20231030154646812](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310301546875.png)

题解：**动态规划**

首先定义`dp`数组的含义，`dp[i]`表示从数字`nums[i]`开始跳跳到结尾的最小次数。

状态转移方程为：

$dp[i] = min(dp[i], dp[i+j]), 1<=j<=nums[i]$

令`dp[i]`的初始值为n。

```java
class Solution {
    public int jump(int[] nums) {
        int n = nums.length;
        int[] dp = new int[n];// 从i开始跳的最小步数
        Arrays.fill(dp, n);
        dp[n-1] = 0;
        for(int i=n-2; i>=0; i--){
            int k = nums[i];
            for(int j=1; j<=k && i+j<=n-1; j++){
                dp[i] = Math.min(dp[i], dp[i+j]);
            }
            dp[i]++;
        }
        return dp[0];
    }
}
```

或者：

```java
class Solution {
    public int jump(int[] nums) {
        int n = nums.length;
        int[] dp = new int[n];// 从i开始跳的最小步数
        dp[n-1] = 0;
        for(int i=n-2; i>=0; i--){
            int k = nums[i];
            int min = n;
            for(int j=1; j<=k && i+j<=n-1; j++){
                min = Math.min(min, dp[i+j]);
            }
            dp[i] = min + 1;
        }
        return dp[0];
    }
}
```



题解：**贪心**

计算从每个点开始跳，能够跳到的最远距离，使用一个变量`fastest`维护这个最远距离，从起跳点到最远距离的这中间的任何点都可以当做下一个起跳点，如果这个最远距离比n-1大于等于，则说明可以跳到。

```java
class Solution {
    public int jump(int[] nums) {
        int n = nums.length;
        int fastest = 0;
        int steps = 0, end = 0;
        for(int i=0; i<n-1; i++){
            fastest = Math.max(fastest, nums[i]+i);
            if(end ==i){
                steps++;
                end = fastest;
            }
        }
        return steps;
    }
}
```

