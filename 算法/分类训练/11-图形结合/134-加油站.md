# 134-加油站

[134-加油站](https://leetcode.cn/problems/gas-station/description/?envType=study-plan-v2&envId=top-interview-150)，难度中等

![image-20231030210431120](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310302104208.png)

题解：该题可以使用图的思想来进行分析，时间复杂度为O(N)，空间复杂度O(1)。

以测试用例1为例：

```python
gas = [1,2,3,4,5]
cost = [3,4,5,1,2]
```

下图的**黑色折线图**即**总油量剩余量**，若要满足题目的要求：跑完全程再回到起点，**总油量的剩余值**的任意部分都需要在X轴之上，且跑到终点时：**总剩余汽油量>=0**。

为了让**黑色折线图**的任意部分都在X轴之上，我们需要向上移动**黑色折线图**，直到所有点都在X轴或X轴之上，处在X轴即为出发点。即**黑色折线图**的最低值的位置。

![image-20231030211735564](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310302117624.png)

其实我们可以自己随意尝试，无论以哪个点作为出发点，折线图的整体情况都和上图类似，只是在x轴上进行了相应的平移。

由于我们需要保证折线上的任意一点都在X轴及以上的位置，因此我们可以平移最低点，只要保证最低点大于等于0即可，因此最低点的下一个点可以作为出发点。

这是因为在最低点以后的任意点都会比最低点大于等于，也就是说最低点以后的点可能会出现回升的迹象，那么为什么需要保证遍历一遍数组之后要保证gas之和大于等于cost之和呢，以上图为例，也就是保证了点5位置的和大于等于0，这是为什么呢？我们将[0, 3]的这段折线的起点0平移到点5上，那么[0, 3]这段折线能够下降的最低位置也就是我们之前求的最低点，而我们又保证了最低点位于X轴及以上，因此就可以保证折线上的所有点都在X轴及以上。

如果点5位置的和小于0，那么经过平移以后，[0, 3]这段折线能够下降的最低位置就会小于0，此时也就说明了 **无论从哪点出发都不能满足题意。**因此这是一个特殊情况，我们不能遗漏。

```java
class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int sum = 0;
        int min = Integer.MAX_VALUE, minIndex = 0;
        int n = gas.length;
        for(int i=0; i<n; i++){
            sum += (gas[i] - cost[i]);
            if(sum < min){
                min = sum;
                minIndex = i;
            }
        }
        return sum < 0? -1: min>=0? 0: (minIndex+1)%n;// 从最低点的下一个点作为起点，因为该点是回升点
    }
}
```



题解：**一次遍历**

![image-20231030213100952](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310302131092.png)

![image-20231030213111896](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310302131939.png)

```java
class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int n = gas.length;
        int i = 0;
        while(i<n){
            int sumOfGas = 0, sumOfCost = 0;
            int cnt = 0;
            while(cnt<n){
                int j = (i+cnt)%n;
                sumOfGas += gas[j];
                sumOfCost += cost[j];
                if(sumOfCost > sumOfGas)
                    break;
                cnt++;
            }
            if(cnt == n)
                return i;
            else
                i = i+cnt+1;
        }
        return -1;
    }
}
```