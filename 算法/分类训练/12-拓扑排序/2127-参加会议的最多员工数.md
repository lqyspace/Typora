# 2127-参加会议的最多员工数

[2127-参加会议的最多员工数](https://leetcode.cn/problems/maximum-employees-to-be-invited-to-a-meeting/description/?envType=daily-question&envId=2023-11-01)，难度困难

![image-20231102131140395](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202311021311530.png)

![image-20231102131213814](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202311021312880.png)

![image-20231102131335948](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202311021313989.png)

![image-20231102131350120](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202311021313186.png)

![image-20231102131408627](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202311021314711.png)

![image-20231102131430733](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202311021314800.png)

![image-20231102131446211](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202311021314262.png)

```java
class Solution {
    public int maximumInvitations(int[] favorite) {
        int n = favorite.length;
        // 统计入度，便于拓扑排序
        int[] indegree = new int[n];
        for(int i=0; i<n; i++){
            indegree[favorite[i]]++;
        }
        boolean[] used = new boolean[n];
        // f[i]表示到节点i为止的最长的游走路径经过的节点数
        // 那么状态转移方程为：f[i] = max(f[j])+1
        // 初始化：所有节点i到本身节点所经过的路径节点个数为1
        int[] f = new int[n];
        Arrays.fill(f, 1);
        Queue<Integer> queue = new ArrayDeque<>();
        for(int i=0; i<n; i++){
            if(indegree[i]==0)
                queue.offer(i);
        }
        while(!queue.isEmpty()){
            int u = queue.poll();
            // 获取入度为0的节点，并且将起点设为已经访问过
            used[u] = true;
            int v = favorite[u];// 节点u的下一个节点v
            // 状态转移,从 u->v
            f[v] = Math.max(f[v], f[u]+1);
            // 令 v 的入度减一
            --indegree[v];
            if(indegree[v]==0)
                queue.offer(v);
        }
        // 此时图内就只剩下环，环大小大于等于3的环，环大小为2的环
        // ring表示环的大小
        // total 表示所有环大小为2的 基环内向树 上的最长的 双向游走 路径之和
        int ring = 0, total = 0;
        for(int i=0; i<n; i++){
            if(!used[i]){
                int j = favorite[i];
                // favorite[favorite[i]] = i; 说明环的大小为2
                if(favorite[j]==i){
                    total += f[i] + f[j];
                    used[i] = used[j] = true;
                }else{
                    // 否则环的大小为大于等于3，我们需要找出环
                    int u = i, cnt = 0;
                    while(true){
                        ++cnt;
                        u = favorite[u];
                        used[u] = true;
                        if(u==i){
                            break;// 说明转回来了
                        }
                    }
                    ring = Math.max(ring, cnt);
                }
            }
        }
        return Math.max(ring, total);
    }
}
```