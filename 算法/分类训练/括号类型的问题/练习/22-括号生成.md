# 22-括号生成

[22-括号生成](https://leetcode.cn/problems/generate-parentheses/description/)，难度中等

![image-20230922010735496](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202309220107547.png)

题解：

现在有 `2n` 个位置，每个位置可以放置字符 `(` 或者 `)`，组成的所有括号组合中，有多少个是合法的？

这就是典型的回溯算法提醒，暴力穷举就行了。

不过为了减少不必要的穷举，我们要知道合法括号串有以下性质：

**1、一个「合法」括号组合的左括号数量一定等于右括号数量，这个很好理解**。

**2、对于一个「合法」的括号字符串组合 `p`，必然对于任何 `0 <= i < len(p)` 都有：子串 `p[0..i]` 中左括号的数量都大于或等于右括号的数量**。

因为从左往右算的话，肯定是左括号多嘛，到最后左右括号数量相等，说明这个括号组合是合法的。

用 `left` 记录还可以使用多少个左括号，用 `right` 记录还可以使用多少个右括号，就可以直接套用 [回溯算法套路框架](https://labuladong.github.io/article/fname.html?fname=回溯算法详解修订版) 了。

==注意：这道题和全排列有点类似，不过需要进行一定的剪枝。==

```java
class Solution {
    HashSet<String> hs = new HashSet<>();
    public List<String> generateParenthesis(int n) {
        StringBuilder sb = new StringBuilder();
        dfs(sb, n, n);
        return new ArrayList<>(hs);
    }
    
    public void dfs(StringBuilder sb, int left, int right){
        // 若左括号剩的多，说明不合法
        if(left>right) return;
        // 若左右括号都为负数，说明不合法
        if(left<0 || right<0) return;
        // 如果左右括号剩余为0
        if(left==0 && right==0){
            hs.add(new String(sb.toString()));
            return;
        }

        // 尝试添加一个左括号
        sb.append("(");
        dfs(sb, left-1, right);
        sb.deleteCharAt(sb.length()-1);

        // 尝试添加一个右括号
        sb.append(")");
        dfs(sb, left, right-1);
        sb.deleteCharAt(sb.length()-1);
        
    }
}
```

