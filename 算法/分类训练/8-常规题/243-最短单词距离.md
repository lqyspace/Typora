# 243-最短单词距离

[243-最短单词距离](https://leetcode.cn/problems/shortest-word-distance/description/)，难度简单

![image-20231013155050990](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310131550060.png)

题解：一次遍历

首先说说我自己的思路，我的想法是用两个有序集合统计这两个单词word1和word2的索引，然后再使用二层循环遍历这两个有序集合，由于这两个单词不同，所以不用担心单词重复出现。但是这个方法的缺点就是时间复杂度比较高。

再说说官方给的思路，官方给的思路很简洁，就是用一次遍历，而且想法也比较巧妙：使用两个索引`index1`和`index2`记录遍历时的位置，从左到右遍历数组`wordDict`，当遍历到word1时，如果已经遍历的单词中存在word2，为了计算最短距离，应该取最后一个已经遍历到的word2所在的下标，计算和当前的距离。同理，当遍历到word2时，应该取最后一个已经遍历到的word1的所在下标，计算和当前的距离。因此，时间复杂度可以控制在O(n)。

初始时，`index1`和`index2`的初始值为 `-1`。分别表示数组wordDict已经遍历的单词中的最后一个`word1`的下标和`word2`的下标。

如果遇到`word1`，就将`index1`更新为`word1`的下标，同理也可以更新`index2`。

注意：只有`index1`和`index2`都为非负时，则可以计算两个下标的距离。

代码1：我自己的代码

```java
class Solution {
    public int shortestDistance(String[] wordsDict, String word1, String word2) {
        List<Integer> lst1 = new ArrayList<>();
        List<Integer> lst2 = new ArrayList<>();
        for(int i=0; i<wordsDict.length; i++){
            String word = wordsDict[i];
            if(word.equals(word1)){
                lst1.add(i);
            }else if(word.equals(word2)){
                lst2.add(i);
            }
        }
        // 两层遍历
        int res = Integer.MAX_VALUE;
        for(int i=0; i<lst1.size(); i++){
            for(int j=0; j<lst2.size(); j++){
                res = Math.min(res, Math.abs(lst1.get(i) - lst2.get(j)));
            }
        }
        return res;
    }
}
```

代码2：官方的代码

```java
class Solution{
    public int shortestDistance(String[] wordsDict, String word1, String word2) {
        int n = wordsDict.length;
        int index1 = -1, index2 = -1;
        int res = Integer.MAX_VALUE;
        for(int i=0; i<n; i++){
            String word = wordsDict[i];
            if(word.equals(word1)){
                index1 = i;
            }else if(word.equals(word2)) {
                index2 = i;
            }
            if(index1>=0 && index2>=0)
                res = Math.min(res, Math.abs(index1 - index2));
        }
        return res;
    }
}
```

