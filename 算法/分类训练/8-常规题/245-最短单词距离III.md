# 245-最短单词距离III

[245-最短单词距离III](https://leetcode.cn/problems/shortest-word-distance-iii/description/)，难度中等

![image-20231013181346630](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310131813690.png)

题解：

使用两个索引`index1`和`index2`记录遍历时的位置，从左到右遍历数组`wordDict`，当遍历到word1时，如果已经遍历的单词中存在word2，为了计算最短距离，应该取最后一个已经遍历到的word2所在的下标，计算和当前的距离。同理，当遍历到word2时，应该取最后一个已经遍历到的word1的所在下标，计算和当前的距离。因此，时间复杂度可以控制在O(n)。

初始时，`index1`和`index2`的初始值为 `-1`。分别表示数组wordDict已经遍历的单词中的最后一个`word1`的下标和`word2`的下标。

如果遇到`word1`，就将`index1`更新为`word1`的下标，同理也可以更新`index2`。

注意：

- 由于两个单词可能是相同的，因为可以定义个额外的变量控制两个变量不会遍历到同一个索引

- 只有`index1`和`index2`都为非负时，则可以计算两个下标的距离。

```java
class Solution {
    public int shortestWordDistance(String[] wordsDict, String word1, String word2) {
        int n = wordsDict.length;
        int index1 = -1, index2 = -1;
        int res = Integer.MAX_VALUE;
        int flag = 1;// 用于控制如果两个单词相同的话，不会同时遍历到同一个索引
        for(int i=0; i<n; i++){
            String word = wordsDict[i];
            if(word.equals(word1) && flag==1){
                index1 = i;   
                // 用于控制两个相同的单词不会同时遍历到同一个索引
                if(word1.equals(word2))
                    flag *= -1;             
            }else if(word.equals(word2)){
                index2 = i;
                if(word1.equals(word2))
                    flag *= -1;
            }
            if(index1==index2) continue;
            if(index1>=0 && index2>=0) {
                res = Math.min(res, Math.abs(index1 - index2));
            }
        }
        return res;
    }
}
```

