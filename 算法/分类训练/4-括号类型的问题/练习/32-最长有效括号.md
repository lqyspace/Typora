# 32-最长有效括号

[32-最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/)，难度困难

![image-20230922011531011](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202309220115065.png)

题解：使用动态规划，定义`dp`数组，其中定义`dp`数组的含义：表示以s[i-1]结尾的有效括号的最长子串长度，`dp`数组的状态转移方程为：`dp[i] = 有效的子串长度 + dp[上一个以右括号结尾的有效子串的长度]`

为了能够有效找到左右括号的对应关系，这里可以使用`栈`。

```java
class Solution {
    public int longestValidParentheses(String s) {
		int n = s.length();
        Stack<Integer> left = new Stack();
        // dp[i]表示以s[i-1]结尾的合法有效最长子串的长度
        int[] dp = new int[n+1];
        for(int i=0; i<n; i++){
            if(s.charAt(i)=='('){
                left.add(i);
            }else{
                if(!left.isEmpty()){
                    int leftIndex = left.pop();
                    int len = 1+i-leftIndex+dp[leftIndex];
                    dp[i+1] = len;
                }else{
                    /// 为空，说明没有左括号进行匹配
                    dp[i+1] = 0;
                }
            }
        }
        int ans = Integer.MIN_VALUE;
        for(int nu: dp){
            ans = Math.max(ans, nu);
        }
        return ans;
    }
}
```

