# 301-删除无效括号

[301-删除无效括号](https://leetcode.cn/problems/remove-invalid-parentheses/description/)，难度困难

![image-20230922013259431](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202309220132478.png)

使用==回溯算法==以**判断当前的点要不要删除掉**

```java
class Solution {
    HashSet<String> hs = new HashSet<>();
    public List<String> removeInvalidParentheses(String s) {
		StringBuilder path = new StringBuilder();
        backtrace(path, s, 0);
        int maxLen = -1;
        for(String str: hs){
            maxLen = Math.max(maxLen, str.length());
        }
        HashSet<String> res = new Hash<>();
        for(String str: hs){
            if(maxLen==str.length()){
                res.add(str);
            }
        }
        return res;
    }
    
    public void backtrace(StringBuilder sb, String s, int v){// 当前的点是否要添加到路径
        if(v>s.length()) return;
        if(v==s.length()){
            if(isValid(sb.toString())){
                hs.add(new String(sb));
            }
            return;
        }
        if(s.charAt(v)=='(' || s.charAt(v)==')'){
            // 添加
            sb.append(s.charAt(v));
            backtrace(sb, s, v+1);
            sb.deleteCharAt(sb.length()-1);
            
            // 不添加
            backtrace(sb, s, v+1);
        }else{
            sb.append(s.charAt(v));
            backtrace(sb, s, v+1);
        }        
    }

	public boolean isValid(String s){
        int left = 0;// 需要匹配的左括号
        int n = s.length();
        for(int i=0; i<n; i++){
            if(s.charAt(i)=='('){
                left++;
            }else{
                if(s.charAt(i)==')'){
                    left--;
                    if(left==-1){
                        return false;
                    }
                }              
            }
        }
        return left==0;
    }
    
}
```

