# 前中后缀表达式

## 表达式求值

先来看一道力扣上比较简单的， 题目链接 : [150. 逆波兰表达式求值](https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/)

根据 [逆波兰表示法](https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437)，求表达式的值。

有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。

> 说明：
>
> 整数除法只保留整数部分。
> 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。

```java
输入：tokens = ["2","1","+","3","*"]
输出：9
解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9
```


这里简单说下**逆波兰表示式(**也叫**后缀表达式**)， 详细了解点上面链接去百度百科, 来看下面的式子：

```java
(2+2)*(1+1)            // 这是我们平常看的表达式, 这也叫中缀表达式
2 2 + 1 1 + *          // 这个是后缀表达式，可以发现其并没有括号，那么后缀表达式是如何计算的?
```

求解后缀表达式， 我们可以将其转化为表达式树的形式， 即上面的后缀表达式其实是**表达式树**后序遍历的结果。 故我们利用该后缀表达式重新建树得，看下图求解表达式树的过程：

![image-20231026133714698](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310261337798.png)

其实我们发现表达式数的**前序遍历**，**中序遍历**和**后续遍历**结果即为**前缀表达式（前缀记法，波兰式）**、**中缀表达式（中缀记法）**(若不对自加括号)、**后缀表达式**， 这里是根据后缀表达式作为表达式树的后序遍历的结果，我们重建的树如上图所示，可以发现每个子树根节点均为一个运算符， 而对每一个子树的运算结果`result = (左子树) (其父节点根节点运算符["+", "-", " * ", " / " ] ) (右子树)`, 具体见上图的两步变换过程。

但我们有必要针对每一个后缀表达式都进行建树操作然后进行这样的计算吗？ 显然通过上面的运算过程我们发现， 后缀表达式中 `2 2 + 1 1 + *` 从左到右遍历当遇到一个运算符时，其左边的必然有两个操作数， 且这两个操作数与这个运算符的运算结果即为上图左子树或者右子树的部分， 当我们运算完序列就变成了 4 1 1 + * , 当遇到+号时，同样也是取其左边两个操作数进行相加操作，运算后结果为 4 2 * , 然后遇到 * 号， 左边的两个数进行相乘操作， 最后得到结果为8， 我们发现这个过程只涉及在一端的加入和删除操作，这不就符合我们栈的数据的进出结构， 故我们对于后缀表达式，我们的处理步骤为:

1. **若遇到数字直接进行进栈操作**
2. **遇到运算符 `op( +, - , *, /)`，先出栈一个数，记为`n2`, 再出栈一个数记为`n1`, 然后进行运算其结果为`result = n1 op n2`; 然后将`result`结果进栈**
3. **直到将后缀表达式遍历完，此时栈中只有一个元素，即我们的运算结果，若不是一个数，那么这个后缀表示式是错误的。**

代码实现：

```java
import java.util.Stack;

public class Test03 {
    public static void main(String[] args) {
        System.out.println(new Test03().RPN("2 1 + 3 *"));
    }
    public int RPN(String expRPN){// 逆波兰表达式求值
        if(expRPN=="" || expRPN==null) return 0;
        Stack<Integer> stk = new Stack<>();
        for(int i=0; i<expRPN.length(); i++){
            char c = expRPN.charAt(i);
            if(Character.isDigit(c)){
                stk.push(c - '0');
            }else {
                int num2 = stk.pop();
                int num1 = stk.pop();
                if(c=='+') {
                    stk.push(num1 + num2);
                }else if(c=='-') {
                    stk.push(num1 - num2);
                }else if(c=='*') {
                    stk.push(num1 * num2);
                }else if(c=='/') {
                    stk.push(num1 / num2);
                }
            } 
                
        }
        return stk.pop();
    }
}
```

上面的过程是直接使用**逆波兰表达式**求值，比较简单，现在来一个有挑战性的。

接下来看一道由中缀表达式进行求值的题目，题目：[3305. 表达式求值](https://leetcode.cn/link/?target=https://www.***.com/problem/content/description/3305/)

给定一个表达式，其中运算符包括 `+、-、*、/` ，可能包括括号，请你求出表达式的最终只。

注意：数据保证给定的表达式合法。

题目保证符号 `-` 只作为减号出现，不会作为负号出现，例如，`-1+2,(2+2)*(-(1+1)+2)` 之类表达式均不会出现。题目保证表达式中所有数字均为正整数。题目保证表达式在中间计算过程以及结果中，均不超过 `2^31−1`。题目中的整除是指向 0 取整，也就是说对于大于 0 的结果向下取整，例如 5/3=1，对于小于 0 的结果向上取整，例如 5/(1−4)=−1。C++和Java中的整除默认是向零取整；Python中的整除//默认向下取整，因此Python的eval()函数中的整除也是向下取整，在本题中不能直接使用。

```
输入格式
共一行，为给定表达式。
```

```
输出格式
共一行，为表达式的结果。
```

```
数据范围
表达式的长度不超过 105。
```

```
输入样例：
(2+2)*(1+1) # 中缀表达式
输出样例：
8
```

==这里给我们的是我们平常见到的表达式形式，这也叫中缀表达式==, 我们如果对上面的表达式树进行中序遍历的话得到的结果为 `2 + 2 * 1 + 1` , 看起来不太对劲，因为乘法优先级是大于加法，故还要加上括号，故这就是中缀表达式相比后缀麻烦的地方，需要处理输入的括号。 这里对于中缀表达式的求值，分两种思路：

## 中缀转后缀

**1、将中缀转化为后缀表达式，然后利用上一道题的解法**

- 思路
  1. 初始化两个栈：运算符栈`s1`和存储中间结果的栈`s2`
  2. 从左至右扫描中缀表达式
  3. 遇到操作数时，将其压入`s2`
  4. 遇到运算符时，比较其与`s1`栈顶运算符的优先级：
     - 第一步：如果**s1为空**，或 **栈顶运算符为左括号**`(`，或 **高于(严格高于)s1栈顶运算符**的优先级，则将该运算符进`s1`栈
     - 第二步：否则，若该运算符优先级**小于或等于**s1栈顶运算符的优先级，将s1栈顶的运算符弹出并压入到s2中。将当前运算符压入到s1栈中。
     - 再次转到第一步与s1中新的栈顶运算符相比较
  5. 遇到括号时：
     - 第一步：如果是左括号`"("`，则直接压入`s1`。
     - 第二步：如果是右括号`")"`，则依次弹出`s1`栈顶的运算符，并压入`s2`，直到遇到左括号为止，此时将这一对括号舍弃。
  6. 重复步骤2至5，直到表达式的最右边
  7. 将`s1`中剩余的运算符依次弹出并压入`s2`。
  8. 依次弹出`s2`中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式（~~转换为前缀表达式时不用逆序~~）【`s2` 使用ArrayList容器，利用`ArrayList`后进先出特点，直接遍历结果即可，无须逆序】。
  
  **转成后缀表达式的代码如下：**
  
  ```java
  package test;
  
  import java.util.HashMap;
  import java.util.Stack;
  
  public class Test11 {
  
      public static void main(String[] args) {
          String str = "(3 + 4) * 5 - 6";
          System.out.println(new Test11().medium2Prefix(str));
      }
  
      public String medium2Prefix(String expStr){
          Stack<Character> stk1 = new Stack<>();
          Stack<Character> stk2 = new Stack<>();
          HashMap<Character, Integer> prio = new HashMap<>();
          prio.put('-', 3);
          prio.put('!', 5);prio.put('*', 4);
          prio.put('/', 4);prio.put('+', 3);
          for(int i=0; i<expStr.length(); i++){
              char ch = expStr.charAt(i);
              if(ch==' ') continue;
              if(Character.isDigit(ch)){
                  stk2.push(ch);
              }else if(stk1.isEmpty() || stk1.peek()=='(' || ch=='('){
                  stk1.push(ch);
              }else if(ch==')'){
                  while (stk1.peek()!='('){
                      stk2.push(stk1.pop());
                  }
                  stk1.pop();
              }else{
                  while (!stk1.isEmpty() && prio.get(stk1.peek())>=prio.get(ch)){
                      stk2.push(stk1.pop());
                  }
                  stk1.push(ch);
              }
          }
          while (!stk1.isEmpty()){
              stk2.push(stk1.pop());
          }
          StringBuilder sb = new StringBuilder();
          while (!stk2.isEmpty()){
              sb.append(stk2.pop());
          }
          return sb.reverse().toString();// 3 4 + 5 * 6 -
      }
  }
  ```
  
  

**2、找出规律直接进行中缀表达式求值**

首先来看一个简单的例子，`a*b+c`这个表达式的树结构如下图所示：

![image-20231026140858700](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310261408748.png)

对其进行中序遍历的结果如右图所示，观察其遍历过程，对于中序遍历，只有两种情况，向下遍历或者向上遍历，我们发现节点向上一层遍历遇到的都是运算符，但是此时中序遍历遇到的运算符并不能直接将此时局部的结果计算出来，因此此时遇到运算符时，其左子树说明已经遍历完毕，但还没遍历其右子树，故此时我们需要运算符压栈，当我们下次再遇到一个运算符时，且此时运算符的的符号小于栈顶的，==即说明栈顶的运算符的优先级更高，应该先完成运算==，结合上图的例子就是，我们遍历完`a`遇到了`*`，此时并不能运算，因为此时还没有遍历b，故需要先把`*`压栈，然后我们继续遍历`b`，然后遍历完`b`后我们向上遇到了运算符`+`，此时`+`的优先级小于`*`，故此时将运算符栈顶的`*`弹出，数据栈的栈顶两个数字弹出进行运算，运算完了以后将新的运算符入栈字符栈，中间结果入栈数字栈，然后此时继续比较栈顶是还有元素或者栈顶的元素的优先级依旧大于等于当前遍历的运算符，则继续重复操作；==但是如果栈顶的运算符的优先级小于等于当前遍历的运算符的优先级，则将当前遍历的运算符直接入栈字符栈即可==。如果当前遍历的字符是左括号的话，那就直接入栈字符栈，如果当前遍历到的字符是右括号的话，则说明之前的运算符要进行先运算了，故符号栈出栈并运算，直到遇到左括号为止并舍弃这一对括号。代码如下：

```java
package test;

import java.util.HashMap;
import java.util.Stack;

public class Test11 {

    public static void main(String[] args) {
        String str = "(3 + 4) * 5 - 6";
        System.out.println(new Test11().medium2Value(str));
    }
    public int medium2Value(String expStr){
        Stack<Character> stk1 = new Stack<>();
        Stack<Integer> stk2 = new Stack<>();
        HashMap<Character, Integer> prio = new HashMap<>();
        prio.put('(', 6);prio.put('-', 3);
        prio.put('!', 5);prio.put('*', 4);
        prio.put('/', 4);prio.put('+', 3);
        for(int i=0; i<expStr.length(); i++){
            char ch = expStr.charAt(i);
            if(Character.isDigit(ch)){
                stk2.push(ch - '0');
            }else{
                if (ch==' ')
                    continue;
                if(stk1.isEmpty() || stk1.peek()=='(')
                    stk1.push(ch);
                else if(ch==')'){
                    while (stk1.peek()!='('){
                        int num2 = stk2.pop();
                        int num1 = stk2.pop();
                        char op = stk1.pop();
                        if (op=='+')stk2.push(num1+num2);
                        else if(op=='-')stk2.push(num1 - num2);
                        else if(op=='*') stk2.push(num1*num2);
                        else stk2.push(num1/num2);
                    }
                    stk1.pop();// 删除左括号
                }else {
                    while (!stk1.isEmpty() && prio.get(stk1.peek()) > prio.get(ch)){
                        int num2 = stk2.pop();
                        int num1 = stk2.pop();
                        char op = stk1.pop();
                        if (op=='+')stk2.push(num1+num2);
                        else if(op=='-')stk2.push(num1 - num2);
                        else if(op=='*') stk2.push(num1*num2);
                        else stk2.push(num1/num2);
                    }
                    // 当前运算符进栈
                    stk1.push(ch);
                }
            }
        }
        // 遍历完了，进行最后的运算
        while (!stk1.isEmpty()){
            int num2 = stk2.pop();
            int num1 = stk2.pop();
            char op = stk1.pop();
            if (op=='+')stk2.push(num1+num2);
            else if(op=='-')stk2.push(num1 - num2);
            else if(op=='*') stk2.push(num1*num2);
            else stk2.push(num1/num2);
        }
        return stk2.peek();// 29
    }
}
```



## 中缀转前缀

转换的思路为：**遍历中缀表达式的顺序为从右到左，输出的顺序为从右到左：**

1、若当前运算符是右括号，直接进字符栈

2、若当前运算符的优先级大于（严格大于，不含等于）栈顶运算符的优先级，直接进栈

3、若当前运算符的优先级不大于栈顶运算符，输出栈顶运算符，然后再判断此时栈顶运算符和当前运算符的优先级关系，若依旧不大于栈顶运算符的优先级，则继续输出栈顶元素，直到当前运算符的优先级大于栈顶元素的优先级时进栈或者栈为空时。

4、若当前运算符为左括号，输出栈顶元素直到遇到右括号为止，左右括号不参与输出。

5、输出数字直接输出

代码如下：

```java
package test;

import java.util.HashMap;
import java.util.Stack;

public class Test11 {

    public static void main(String[] args) {
        String str = "(3 + 4) * 5 - 6";
        System.out.println(new Test11().medium2Surfix(str));
    }
    public String medium2Surfix(String expStr){
        Stack<Character> stk1 = new Stack<>();
        StringBuilder res = new StringBuilder();
        HashMap<Character, Integer> prio = new HashMap<>();
        prio.put('-', 3);
        prio.put('!', 5);prio.put('*', 4);
        prio.put('/', 4);prio.put('+', 3);
        for(int i=expStr.length()-1; i>=0; i--){
            char ch = expStr.charAt(i);
            if(ch == ' ')continue;
            if(Character.isDigit(ch))
                res.append(ch).append(" ");
            else if(stk1.isEmpty() || stk1.peek()==')' || ch==')')
                stk1.push(ch);
            else if(ch=='('){
                while (stk1.peek()!=')')
                    res.append(stk1.pop()).append(" ");
                stk1.pop();
            }else {
                while (!stk1.isEmpty() && prio.get(stk1.peek()) >= prio.get(ch))
                    res.append(stk1.pop()).append(" ");
                stk1.push(ch);
            }
        }
        while (!stk1.isEmpty())
            res.append(stk1.pop()).append(" ");
        return res.reverse().toString();// - * + 3 4 5 6
    }
}

```



## 后缀转中缀

从左到右扫描后缀表达式，一次一个符号读入表达式。如果符号是操作数，那么就建立一个单节点树并将它推入栈中。如果符号是操作数，那么就从栈中弹出两棵树`T1`和`T2`（`T1`先弹出，位于表达式的右边）并形成一颗新的树，该树的根就是操作符，它的左右儿子分别是`T2`和`T1`.然后将指向这棵新树的指针压入栈中。最后中序遍历这棵树即可。

```java
public ExpTree prefix2Medium(String expStr){// expStr = "1 2 3 + 4 * + 5 -"
    Stack<ExpTree> stk = new Stack<>();
    for(int i=0; i<expStr.length(); i++){
        char ch = expStr.charAt(i);
        if(ch==' ')continue;
        if(Character.isDigit(ch)){
            stk.push(new ExpTree(ch));
        }else {
            ExpTree e1 = stk.pop();
            ExpTree e2 = stk.pop();
            ExpTree root = new ExpTree(ch);
            root.left = e2;
            root.right = e1;
            stk.push(root);
        }
    }
    ExpTree root = stk.pop();
    return root;
}
public String binaryTree2Medium(ExpTree root){
    if(root==null) return null;
    String left = binaryTree2Medium(root.left);
    String right = binaryTree2Medium(root.right);
    if (left==null && right==null)
        return String.valueOf(root.ch);
    return "("+left+root.ch+right+")";
}
```

![image-20231026195420452](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310261954506.png)



## 前缀转中缀

首先创建一个数字栈，从右到左扫描前缀表达式，如果遇到操作数，则入栈。如果遇到操作符，则将栈顶的元素弹出（后扫描的数字位于表达式的前面），并和操作符结合写成表达式，作为中缀表达式。如果遇到的操作符优先级大于已存在表达式的最后执行操作符的优先级，则将已存在的表达式加上`()`。

```java
//  前序变中序
public String surfix2Medium(String expStr){ // expStr = "- + 1 * + 2 3 4 5"
    Stack<String> stk = new Stack<>();
    Stack<Character> stk1 = new Stack<>();
    StringBuilder sb = new StringBuilder();
    HashMap<Character, Integer> prio = new HashMap<>();
    prio.put('-', 3);
    prio.put('!', 5);prio.put('*', 4);
    prio.put('/', 4);prio.put('+', 3);
    for(int i=expStr.length()-1; i>=0; i--){
        char ch = expStr.charAt(i);
        if(ch==' ')continue;
        if(Character.isDigit(ch)){
            stk.push(String.valueOf(ch));
        }else{
            String ch1 = stk.pop();
            String ch2 = stk.pop();
            StringBuilder tmp = new StringBuilder();

            //                if(stk1.isEmpty()){
            //                    stk1.push(ch);
            //                }
            if(!stk1.isEmpty() && prio.get(stk1.peek()) <= prio.get(ch)){
                boolean f = false;
                try {
                    int a = Integer.parseInt(ch1);
                    f = true;
                } catch (Exception e){
                    //                        e.printStackTrace();
                }
                if(!f)
                    ch1 = "(" + ch1 + ")";
            }
            stk1.push(ch);
            tmp.append(ch2+ch+ch1);
            stk.push(tmp.toString());
        }
    }
    return stk.peek();// 5-(4*(3+2)+1)
}
```

参考博客：

[前缀、中缀、后缀表达式转换详解](https://blog.csdn.net/walkerkalr/article/details/22798365)

[前缀/后缀/中缀表达式求值](https://leetcode.cn/circle/discuss/BjxBq2/)

[前缀、中缀、后缀表达式](https://blog.csdn.net/guoqingshuang/article/details/52910720)

