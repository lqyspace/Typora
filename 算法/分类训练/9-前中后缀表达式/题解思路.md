# 前中后缀表达式

## 表达式求值

先来看一道力扣上比较简单的， 题目链接 : [150. 逆波兰表达式求值](https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/)

根据 [逆波兰表示法](https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437)，求表达式的值。

有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。

> 说明：
>
> 整数除法只保留整数部分。
> 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。

```java
输入：tokens = ["2","1","+","3","*"]
输出：9
解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9
```


这里简单说下逆波兰表示式(也叫后缀表达式)， 详细了解点上面链接去百度百科, 来看下面的式子：

```java
(2+2)*(1+1)            // 这是我们平常看的表达式, 这也叫中缀表达式
2 2 + 1 1 + *          // 这个是后缀表达式，可以发现其并没有括号，那么后缀表达式是如何计算的?
```

求解后缀表达式， 我们可以将其转化为表达式树的形式， 即上面的后缀表达式其实是**表达式树**后序遍历的结果。 故我们利用该后缀表达式重新建树得，看下图求解表达式树的过程：

![在这里插入图片描述](https://pic.leetcode-cn.com/1623593987-uBQdBN-file_1623593987032)

其实我们发现表达式数的**前序遍历**，**中序遍历**和**后续遍历**结果即为**前缀表达式**、**中缀表达式**(若不对自加括号)、**后缀表达式**， 这里是根据后缀表达式作为表达式树的后序遍历的结果，我们重建的树如上图所示，可以发现每个子树根节点均为一个运算符， 而对每一个子树的运算结果`result = (左子树) (其父节点根节点运算符["+", "-", " * ", " / " ] ) (右子树)`, 具体见上图的两步变换过程。

但我们有必要针对每一个后缀表达式都进行建树操作然后进行这样的计算吗？ 显然通过上面的运算过程我们发现， 后缀表达式中 `2 2 + 1 1 + *` 从左到右遍历当遇到一个运算符时，其左边的必然有两个操作数， 且这两个操作数与这个运算符的运算结果即为上图左子树或者右子树的部分， 当我们运算完序列就变成了 4 1 1 + * , 当遇到+号时，同样也是取其左边两个操作数进行相加操作，运算后结果为 4 2 * , 然后遇到 * 号， 左边的两个数进行相乘操作， 最后得到结果为8， 我们发现这个过程只涉及在一端的加入和删除操作，这不就符合我们栈的数据的进出结构， 故我们对于后缀表达式，我们的处理步骤为:

1. **若遇到数字直接进行进栈操作**
2. **遇到运算符 `op( +, - , *, /)`，先出栈一个数，记为`n2`, 再出栈一个数记为`n1`, 然后进行运算其结果为`result = n1 op n2`; 然后将`result`结果进栈**
3. **直到将后缀表达式遍历完，此时栈中只有一个元素，即我们的运算结果，若不是一个数，那么这个后缀表示式是错误的。**

代码实现：

```java
import java.util.Stack;

public class Test03 {
    public static void main(String[] args) {
        System.out.println(new Test03().RPN("2 1 + 3 *"));
    }
    public int RPN(String expRPN){// 逆波兰表达式求值
        if(expRPN=="" || expRPN==null) return 0;
        Stack<Integer> stk = new Stack<>();
        for(int i=0; i<expRPN.length(); i++){
            char c = expRPN.charAt(i);
            if(Character.isDigit(c)){
                stk.push(c - '0');
            }else {
                int num2 = stk.pop();
                int num1 = stk.pop();
                if(c=='+') {
                    stk.push(num1 + num2);
                }else if(c=='-') {
                    stk.push(num1 - num2);
                }else if(c=='*') {
                    stk.push(num1 * num2);
                }else if(c=='/') {
                    stk.push(num1 / num2);
                }
            } 
                
        }
        return stk.pop();
    }
}
```

上面的过程是直接使用**逆波兰表达式**求值，比较简单，现在来一个有挑战性的。

接下来看一道由中缀表达式进行求值的题目，题目：[3305. 表达式求值](https://leetcode.cn/link/?target=https://www.***.com/problem/content/description/3305/)

给定一个表达式，其中运算符包括 `+、-、*、/` ，可能包括括号，请你求出表达式的最终只。

注意：数据保证给定的表达式合法。

题目保证符号 `-` 只作为减号出现，不会作为负号出现，例如，`-1+2,(2+2)*(-(1+1)+2)` 之类表达式均不会出现。题目保证表达式中所有数字均为正整数。题目保证表达式在中间计算过程以及结果中，均不超过 `2^31−1`。题目中的整除是指向 0 取整，也就是说对于大于 0 的结果向下取整，例如 5/3=1，对于小于 0 的结果向上取整，例如 5/(1−4)=−1。C++和Java中的整除默认是向零取整；Python中的整除//默认向下取整，因此Python的eval()函数中的整除也是向下取整，在本题中不能直接使用。

```
输入格式
共一行，为给定表达式。
```

```
输出格式
共一行，为表达式的结果。
```

```
数据范围
表达式的长度不超过 105。
```

```
输入样例：
(2+2)*(1+1) # 中缀表达式
输出样例：
8
```

==这里给我们的是我们平常见到的表达式形式，这也叫中缀表达式==, 我们如果对上面的表达式树进行中序遍历的话得到的结果为 `2 + 2 * 1 + 1` , 看起来不太对劲，因为乘法优先级是大于加法，故还要加上括号，故这就是中缀表达式相比后缀麻烦的地方，需要处理输入的括号。 这里对于中缀表达式的求值，分两种思路：

**1、将中缀转化为后缀表达式，然后利用上一道题的解法**

- 思路
  1. 初始化两个栈：运算符栈`s1`和存储中间结果的栈`s2`
  2. 从左至右扫描中缀表达式
  3. 遇到操作数时，将其压入`s2`
  4. 遇到运算符时，比较其与`s1`栈顶运算符的优先级：
     - 第一步：如果**s1为空**，或 **栈顶运算符为左括号**`(`，或 **高于s1栈顶运算符**的优先级，则将该运算符进`s1`栈
     - 第二步：否则，若该运算符优先级小于或等于s1栈顶运算符的优先级，将s1栈顶的运算符弹出并压入到s2中。将当前运算符压入到s1栈中。
     - 再次转到第一步与s1中新的栈顶运算符相比较
  5. 遇到括号时：
     - 第一步：如果是左括号`"("`，则直接压入`s1`。
     - 第二步：如果是右括号`")"`，则依次弹出`s1`栈顶的运算符，并压入`s2`，直到遇到左括号为止，此时将这一对括号舍弃。
  6. 重复步骤2至5，直到表达式的最右边
  7. 将`s1`中剩余的运算符依次弹出并压入`s2`。
  8. 依次弹出`s2`中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式（转换为前缀表达式时不用逆序）【`s2` 使用ArrayList容器，利用`ArrayList`后进先出特点，直接遍历结果即可，无须逆序】。

**2、找出规律直接进行中缀表达式求值**

