# 2251-花期内花的数目

[2251-花期内花的数目](https://leetcode.cn/problems/number-of-flowers-in-full-bloom/description/?envType=daily-question&envId=2023-09-28)，难度困难

![image-20230929163735251](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202309291637346.png)

题解：**差分数组**

具体思路可以看官方题解，重点是需要多**总结规律**

```java
class Solution {
    public int[] fullBloomFlowers(int[][] flowers, int[] people) {
        TreeMap<Integer, Integer> cnt = new TreeMap<>();
        for(int[] flower: flowers){
            cnt.put(flower[0], cnt.getOrDefault(flower[0], 0)+1);
            cnt.put(flower[1]+1, cnt.getOrDefault(flower[1]+1, 0)-1);
        }
        int m = people.length;
        Integer[] indices = IntStream.range(0, m).boxed().toArray(Integer[]::new);
        Arrays.sort(indices, (i, j)->people[i] - people[j]);
        int cur = 0;
        int[] ans  = new int[m];
        for(int x: indices){
            while(!cnt.isEmpty() && cnt.firstKey()<=people[x]){
                cur += cnt.pollFirstEntry().getValue();
            }
            ans[x] = cur;
        }
        return ans;
    }
}
```

  解法二：二分查找

```java
class Solution {
    public int[] fullBloomFlowers(int[][] flowers, int[] people) {
        int n = flowers.length;
        int[] start = new int[n];
        int[] end = new int[n];
        for(int i=0; i<n; i++){
            start[i] = flowers[i][0];
            end[i] = flowers[i][1];
        }
        Arrays.sort(start);
        Arrays.sort(end);

        int m = people.length;
        int[] ans = new int[m];
        for(int i=0; i<m; i++){
            // 这个地方之所以要+1，是需要把起点算进去
            int x = binarySearch(start, people[i]+1);
            // 而这个地方不+1，是因为不需要把末尾算进去
            int y = binarySearch(end, people[i]);
            ans[i] = x-y;
        }
        return ans;
    }

    public int binarySearch(int[] arr, int target){
        int n = arr.length;
        int left = 0, right = n-1;
        // 这个地方赋值有技巧，如果arr中的值都比target小，那么res的长度就应该是n
        int res = n;
        while(left<=right){
            int mid = left + (right - left)/2;
            if(arr[mid] >= target){
                res = mid;
                right = mid - 1;
            }else{
                left = mid+1;
            }
        }
        return res;
    }
}
```

