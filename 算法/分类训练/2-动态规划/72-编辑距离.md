# 72-编辑距离

[72-编辑距离](https://leetcode.cn/problems/edit-distance/description/)，难度困难

![image-20231010193148752](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310101931826.png)

题解1：递归+备忘录：自顶向下

```java
class Solution {
    int[][] memo;
    public int minDistance(String word1, String word2) {
        int m = word1.length(), n = word2.length();
        memo = new int[m][n];
        for(int i=0; i<m; i++){
            Arrays.fill(memo[i], -1);
        }
        return dfs(word1, m-1, word2, n-1);
    }
    public int dfs(String s1, int i, String s2, int j){
        if(i==-1) return j+1;
        if(j==-1) return i+1;
        if(memo[i][j]!=-1)
            return memo[i][j];
        if(s1.charAt(i)==s2.charAt(j)){
            memo[i][j] = dfs(s1, i-1, s2, j-1);
        }else{// 插入，删除，替换
            memo[i][j] = Math.min(dfs(s1, i, s2, j-1)+1, Math.min(dfs(s1, i-1, s2, j)+1, dfs(s1, i-1, s2, j-1)+1));
        }
        return memo[i][j];
    }
}
```



题解2：动态规划：自底向上

```java
class Solution {
    public int minDistance(String word1, String word2) {
        int m = word1.length(), n = word2.length();
        int[][] dp = new int[m+1][n+1];// 表示s1[0...i]和s2[0...j]的最短编辑距离
        for(int i=1; i<=m; i++){
            dp[i][0] = i;
        }
        for(int j=1; j<=n; j++)
            dp[0][j] = j;
        // 自底向上
        for(int i=1; i<=m ;i++){
            for(int j=1; j<=n; j++){
                if(word1.charAt(i-1)==word2.charAt(j-1)){
                    dp[i][j] = dp[i-1][j-1];
                }else{
                    dp[i][j] = Math.min(dp[i][j-1]+1, Math.min(dp[i-1][j]+1, dp[i-1][j-1]+1));
                }
            }
        }
        return dp[m][n];
    }
}
```

题解3：动态规划+空间压缩

```java
class Solution {
    public int minDistance(String word1, String word2) {
        int m = word1.length(), n = word2.length();
        int[] dp = new int[n+1];// 表示s1[0...i]和s2[0...j]的最短编辑距离
        for(int j=0; j<=n; j++)
            dp[j] = j;

        // 自底向上
        for(int i=1; i<=m ;i++){
            int prev = i-1;// 这个充当dp[i-1][j-1],其实的值为dp[i-1][0] = i-1
            dp[0] = i;
            for(int j=1; j<=n; j++){
                int tmp = dp[j];
                if(word1.charAt(i-1)==word2.charAt(j-1)){
                    dp[j] = prev;
                }else{
                    dp[j] = Math.min(dp[j-1]+1, Math.min(dp[j]+1, prev+1));
                }
                prev = tmp;
            }
        }
        return dp[n];
    }
}
```

