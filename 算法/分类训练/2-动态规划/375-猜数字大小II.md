# 375-猜数字大小II

[375-猜数字大小](https://leetcode.cn/problems/guess-number-higher-or-lower-ii/)，难度中等

![image-20231011193718220](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310111937288.png)

题解：动态规划

为了将支付的金额最小化，除了需要将每次支付的金额控制在较低值以外，还需要在猜数字的过程中缩小所选数字的范围。当猜了数字`x`并且猜错时，会知道数字`x`比所选数字大还是小。如果`x`比所选的数字大，则任何比`x`大的数字一定都比所选数字大，因此应该在比`x`小的数字中继续猜数字。如果`x`比所选数字小，同理可知应该比`x`大的数字中继续猜数字。

![image-20231011213611146](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310112136227.png)

```java
class Solution {
    public int getMoneyAmount(int n) {
        int[][] dp = new int[n+1][n+1];
        for(int i=n; i>=1; i--){
            for(int j=i+1; j<=n; j++){
                dp[i][j] = j + dp[i][j-1];
                for(int k=i; k<j; k++){// 闭区间
                    dp[i][j] = Math.min(dp[i][j], k + Math.max(dp[i][k-1], dp[k+1][j]));
                }
            }
        }
        return dp[1][n];
    }
}
/**
根据状态转移方程：f[i][j] = k + f[i][k-1] + f[k+1][j]，当k取j时，就有：f[i][j] = j + f[i][j-1] + f[j+1][j]；我们知道f[j+1][j] = 0，同时此处也可以解释为什么在遍历的时候k!=j，如果j=n，那么k+1=n+1，就会导致数组索引越界。

为什么这么做是合理的呢，假设j<n，那么f[i][j] = j + f[i][j-1] + f[j+1][j]  ==>  f[i][j] = j + f[i][j-1]，这个情况也是f[i][j]的子情况之一，并不影响全局最小值的判断；再假设 j==n，首先令 f[i][j] = j + f[i][j-1]，然后在第三层关于k的循环中，当k=j-1时，那么f[i][j] = Math.min(f[i][j], j-1 + Math.max(f[i][j-2], f[j][j]));我们知道f[j][j] = 0, 因为f[i][j-2]>=0, 因此我们需要考虑 f[i][j-1]与f[i][j-2]的大小关系，因此一定会有 f[i][j-1] >= f[i][j-2]，所以就有 j + f[i][j-1] > j-1 + f[i][j-2] ，因此我们可以证明：假设在遍历k的过程中，我们首先声明的 f[i][j] = j + f[i][j-1] 一直保持最小，在k的最后一轮的时候，我们有理由相信，f[i][j] = j + f[i][j-1] 并不是一直最小，所以可以取到正确值
 */
```



题解：递归+备忘录

```java
class Solution{
    int[][] memo;
    public int getMoneyAmount(int n) {
        memo = new int[n+1][n+1];
        for(int[] row: memo)
            Arrays.fill(row, -1);
        return dfs(1, n);
    }
    public int dfs(int i, int j){
        if(j<=i) return 0;
        if(memo[i][j]!=-1)
            return memo[i][j];
        int res = Integer.MAX_VALUE;
        for(int k=i; k<j; k++){
            res = Math.min(res, k + Math.max(dfs(i, k-1), dfs(k+1, j)));
        }
        return memo[i][j] = res;
    }
}
```