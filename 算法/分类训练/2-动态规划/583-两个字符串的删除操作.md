# 583-两个字符串的删除操作

[583-两个字符串的删除操作](https://leetcode.cn/problems/delete-operation-for-two-strings/)，难度中等

![image-20231010211304041](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310102113096.png)

==利用最长公共子序列求解==

题解1：动态规划

```java
class Solution {
    public int minDistance(String word1, String word2) {
        int m = word1.length(), n = word2.length();
        int[][] dp = new int[m+1][n+1];

        for(int i=1; i<=m; i++){
            for(int j=1; j<=n; j++){
                if(word1.charAt(i-1)==word2.charAt(j-1)){
                    dp[i][j] = dp[i-1][j-1]+1;
                }else{
                    dp[i][j] = Math.max(dp[i-1][j], Math.max(dp[i][j-1], dp[i-1][j-1]));
                }
            }
        }
        return m+n-dp[m][n]*2;
    }
}
```



题解2：动态规划+空间压缩

```java
class Solution {
    public int minDistance(String word1, String word2) {
        int m = word1.length(), n = word2.length();
        int[] dp = new int[n+1];

        for(int i=1; i<=m; i++){
            int prev = 0;
            for(int j=1; j<=n; j++){
                int tmp = dp[j];
                if(word1.charAt(i-1)==word2.charAt(j-1)){
                    dp[j] = prev+1;
                }else{
                    dp[j] = Math.max(dp[j], Math.max(dp[j-1], prev));
                }
                prev = tmp;
            }
        }
        return m+n-dp[n]*2;
    }
}
```



题解3：递归+备忘录

```java
class Solution {
    int[][] memo;
    public int minDistance(String word1, String word2) {
        int m = word1.length(), n = word2.length();
        memo = new int[m][n];
        for(int[] row: memo){
            Arrays.fill(row, -1);
        }
        return m+n - 2*dfs(word1, m-1, word2, n-1);
    }

    public int dfs(String s, int i, String t, int j){
        if(i==-1) return 0;
        if(j==-1) return 0;
        if(memo[i][j]!=-1){
            return memo[i][j];
        }

        if(s.charAt(i) == t.charAt(j)){
            memo[i][j] = dfs(s, i-1, t, j-1)+1;
        }else{
            memo[i][j] = Math.max(dfs(s, i, t, j-1), dfs(s, i-1, t, j));
        }
        return memo[i][j];
    }

}
```

