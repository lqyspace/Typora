[TOC]

# 区间DP

![image-20231011144531670](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310111445876.png)

**线性DP：通常是在数组的前缀或者后缀上进行转移，这类DP通常叫做线性DP。**

**区间DP：我们会把问题的规模缩小到数组中间的区间上，而不仅仅是前缀或者后缀。**



## 516-最长回文子序列

`s=eacbba`

思路1：==转换：==求s和反转后s的LCS（最长公共子序列）

思路2：[选或不选]从两侧向内缩小问题规模

![image-20231011151131904](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310111511979.png)

![image-20231011151352267](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310111513360.png)

![image-20231011151417995](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310111514040.png)

题解：递归+备忘录

```java
class Solution{
    int[][] memo;
	public int longestPalindromeSubseq(String s){
        int n = s.length();
        memo = new int[n][n];
        for(int[] row: memo){
            Arrays.fill(row, -1);
        }
        return dfs(s, 0, n-1);
    }
    // dfs(s, i, j)表示s[i...j]内的最长回文子序列
    public int dfs(String s, int i, int j){
        if(i==j) return 1;
        if(i>j) return 0;
        if(memo[i][j]!=-1)
            return memo[i][j];
        if(s.charAt(i)==s.charAt(j)){
            memo[i][j] = dfs(s, i+1, j-1)+2;
        }else{
            memo[i][j] = Math.max(dfs(s, i+1, j), dfs(s, i, j-1));
        }
        return memo[i][j];
    }
}
```

题解：动态规划

```java
class Solution{
    public int longestPalindromeSubseq(String s){
        int n = s.length();
        int[][] dp = new int[n][n]; // 表示s[i...j]内的最长回文子序列
        // base
        for(int i=0; i<n; i++)
            dp[i][i] = 1;
        for(int i=n-1; i>=0; i--){
            for(int j=i+1; j<n; j++){
                if(s.charAt(i)==s.charAt(j)){
                    dp[i][j] = dp[i+1][j-1]+2;
                }else{
                    dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1]);
                }
            }
        }
        return dp[0][n-1];
    }
}
```

题解：动态规划+空间压缩

```java
class Solution{
    public int longestPalindromeSubseq(String s){
        int n = s.length();
        int[] dp = new int[n];
        for(int i=0; i<n; i++)
            dp[i] = 1;
        for(int i=n-1; i>=0; i--){
            int prev = 0;
            for(int j=i+1; j<n; j++){
                int tmp = dp[j];
                if(s.charAt(i)==s.charAt(j))
                    dp[j] = prev+2;
                else
                    dp[]
            }
        }
    }
}
```



## 1039-多边三角形剖分的最低得分

![image-20231011183439606](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310111834689.png)

![image-20231011183454897](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310111834974.png)

![image-20231011183510187](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310111835258.png)

![image-20231011183524124](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310111835184.png)

题解：递归+备忘录

```java
class Solution {
    int[][] memo;
    public int minScoreTriangulation(int[] values) {
        int n = values.length;
        memo = new int[n][n];
        for(int[] row: memo){
            Arrays.fill(row, -1);
        }
        return dfs(values, 0, n-1);
    }

    public int dfs(int[] values, int i, int j){
        if(j==i+1) return 0;
        if(memo[i][j]!=-1) return memo[i][j];
        int res = Integer.MAX_VALUE;
        for(int k=i+1; k<j; k++){
            res = Math.min(res, dfs(values, i, k) + dfs(values, k, j) + values[i]*values[j] * values[k]);
        }
        return memo[i][j] = res;
    }
}

// 时间复杂度：O(n^3)
// 空间复杂度：O(n^2)
```

题解：动态规划

![image-20231011185433751](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310111854813.png)

```java
class Solution {
    public int minScoreTriangulation(int[] values) {
        int n = values.length;
        int[][] dp = new int[n][n];

        for(int i=n-1; i>=0; i--){
            for(int j=i+2; j<n; j++){
                dp[i][j] = Integer.MAX_VALUE;
                for(int k=i+1; k<j; k++){
                    dp[i][j] = Math.min(dp[i][j], dp[i][k]+dp[k][j]+values[i]*values[k]*values[j]);
                }
            }
        }
        return dp[0][n-1];
    }
}

// 时间复杂度：O(n^3)
// 空间复杂度：O(n^2)
```

![image-20231011191011880](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310111910921.png)