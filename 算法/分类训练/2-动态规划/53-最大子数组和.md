# 53-最大子数组和

[53-最大子数组和](https://leetcode.cn/problems/maximum-subarray/)，难度中等

![image-20230923101726440](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202309231017514.png)

题解：

动态规划：

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int n = nums.length;
        int[] dp = new int[n];
        for(int i=0; i<n; i++){
            dp[i] = nums[i];
        }
        int  ans = dp[0];
        for(int i=1; i<n; i++){
            dp[i] = Math.max(dp[i], nums[i]+dp[i-1]);
            ans = Math.max(ans, dp[i]);
        }
        return ans;
    }
}
```



前缀和：

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int n = nums.length;
        int[] preSum = new int[n+1];
        for(int i=1; i<=n; i++){
            preSum[i] = preSum[i-1] + nums[i-1];
        }

        int min = preSum[1];
        int res = preSum[1];
        for(int i=0; i<n; i++){
            // 因为min是被减的那一个，所以位置偏左
            if(preSum[i]<min) min = preSum[i];
            else
                // 但是真正有前缀和的位置偏右，所以需要右移一位
                res = Math.max(res, preSum[i+1]-min);
        }
        return res;
    }
}
```



==分治法：==

分治法的思路是这样的，其实也是分类讨论。

连续子序列的最大和主要由这三部分子区间里元素的最大和得到：

- 第 1 部分：子区间 `[left, mid]`；

- 第 2 部分：子区间 `[mid + 1, right]`；
- 第 3 部分：包含子区间 `[mid , mid + 1]` 的子区间，即 `nums[mid]` 与 `nums[mid + 1]` 一定会被选取。

对这三个部分求最大值即可。

说明：考虑第 3 部分跨越两个区间的连续子数组的时候，由于 `nums[mid]` 与 `nums[mid + 1]` 一定会被选取，可以从中间向两边扩散，扩散到底 选出最大值，具体请见代码：

![image.png](https://pic.leetcode-cn.com/1621840913-dcvfVD-image.png)

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int n = nums.length;
        return maxSubArraySum(nums, 0, n-1);
    }
    public int max3(int a, int b, int c){
        return Math.max(a, Math.max(b, c));
    }

    public int maxSubArraySum(int[] nums, int left, int right){
        if(left == right)
            return nums[left];
        int mid = left + (right - left)/2;
        return max3(maxSubArraySum(nums, left, mid), maxSubArraySum(nums, mid+1, right), maxCrossArraySum(nums, left, mid, right));
    }

    public int maxCrossArraySum(int[] nums, int left, int mid, int right){
        // 一定会包含num[mid]
        int sum = 0;
        int leftSum = Integer.MIN_VALUE;
        // 左半边包含nums[mid]元素，最多可以到达什么地方
        // 走到边界，看看最值是什么
        // 计算以mid为结尾的最大子数组
        for(int i=mid; i>=left; i--){
            sum += nums[i];
            if(sum > leftSum){
                leftSum = sum;
            }
        }

        sum = 0;
        int rightSum = Integer.MIN_VALUE;
        // 右半边不包含nums[mid]元素，最多可以到达什么地方
        // 计算以 mid+1 开始的最大的子数组是多少
        for(int i=mid+1; i<=right; i++){
            sum += nums[i];
            if(sum > rightSum)
                rightSum = sum;
        }
        return leftSum + rightSum;
    }
}
```

