# 161-相隔为1的编辑距离

[161-相隔为1的编辑距离](https://leetcode.cn/problems/one-edit-distance/)，难度中等，这道题和 74-编辑距离类似。

![image-20231010204720460](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310102047519.png)

题解1：递归+备忘录

```java
class Solution {
    int[][] memo;
    public boolean isOneEditDistance(String s, String t) {
        // 这道题和74-编辑距离类似
        int m = s.length(), n = t.length();
        memo = new int[m][n];
        for(int[] row: memo){
            Arrays.fill(row, -1);
        }
        int cnt = dfs(s, m-1, t, n-1);
        return cnt==1;
    }
    public int dfs(String s1, int i, String s2, int j){
        if(i==-1) return j+1;
        if(j==-1) return i+1;
        if(memo[i][j]!=-1){
            return memo[i][j];
        }
        if(s1.charAt(i)==s2.charAt(j)){
            memo[i][j] = dfs(s1, i-1, s2, j-1);
        }else{
            memo[i][j] = Math.min(Math.min(dfs(s1, i, s2, j-1), dfs(s1, i-1, s2, j)), dfs(s1, i-1, s2, j-1))+1;
        }
        return memo[i][j];
    }
}
```



题解2：动态规划

```java
class Solution {
    public boolean isOneEditDistance(String s, String t) {
        int m = s.length(), n = t.length();
        int[][] dp = new int[m+1][n+1];
        for(int i=1; i<=m; i++){
            dp[i][0] = i;
        }
        for(int j=1; j<=n; j++){
            dp[0][j] = j;
        }

        for(int i=1; i<=m; i++){
            for(int j=1; j<=n; j++){
                if(s.charAt(i-1)==t.charAt(j-1)){
                    dp[i][j] = dp[i-1][j-1];
                }else{
                    dp[i][j] = Math.min(dp[i][j-1], Math.min(dp[i-1][j], dp[i-1][j-1]))+1;
                }
            }
        }

        return dp[m][n]==1;
    }
}
```



题解3：动态规划+空间压缩

```java
class Solution {
    public boolean isOneEditDistance(String s, String t) {
        int m = s.length(), n = t.length();
        int[] dp = new int[n+1];
        for(int j=1; j<=n; j++){
            dp[j] = j;
        }

        for(int i=1; i<=m; i++){
            int prev = i-1;
            dp[0] = i;
            for(int j=1; j<=n; j++){
                int tmp = dp[j];
                if(s.charAt(i-1)==t.charAt(j-1)){
                    dp[j] = prev;
                }else{
                    dp[j] = Math.min(dp[j-1], Math.min(dp[j], prev))+1;
                }
                prev = tmp;
            }
        }

        return dp[n]==1;
    }
}
```

