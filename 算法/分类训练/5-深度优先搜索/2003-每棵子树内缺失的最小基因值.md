# 2003-每棵子树内缺失的最小基因值

[2003-每棵子树内缺失的最小基因值](https://leetcode.cn/problems/smallest-missing-genetic-value-in-each-subtree/description/?envType=daily-question&envId=2023-10-31)，难度困难

![image-20231101162718940](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202311011627348.png)

![image-20231101162733315](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202311011627390.png)

![image-20231101162845031](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202311011628094.png)

```java
class Solution {
    public int[] smallestMissingValueSubtree(int[] parents, int[] nums) {
        int n = parents.length;
        List<Integer>[] children = new List[n];
        for (int i = 0; i < n; i++) {
            children[i] = new ArrayList<Integer>();
        }
        for (int i = 1; i < n; i++) {
            children[parents[i]].add(i);
        }

        int[] res = new int[n];
        Arrays.fill(res, 1);
        Set<Integer>[] geneSet = new Set[n];
        for (int i = 0; i < n; i++) {
            geneSet[i] = new HashSet<Integer>();
        }
        dfs(0, res, nums, children, geneSet);
        return res;
    }

    public int dfs(int node, int[] res, int[] nums, List<Integer>[] children, Set<Integer>[] geneSet) {
        geneSet[node].add(nums[node]);
        for (int child : children[node]) {
            res[node] = Math.max(res[node], dfs(child, res, nums, children, geneSet));
            if (geneSet[node].size() < geneSet[child].size()) {
                Set<Integer> temp = geneSet[node];
                geneSet[node] = geneSet[child];
                geneSet[child] = temp;
            }
            geneSet[node].addAll(geneSet[child]);
        }
        while (geneSet[node].contains(res[node])) {
            res[node]++;
        }
        return res[node];
    }
}
```

> 时间复杂度：O(nlogn) 基于启发式合并的基因集合合并需要O(nlogn)
>
> 空间复杂度：O(nlogn)

![image-20231101164126227](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202311011641316.png)

这个方法里有一点比较巧妙，就是最开始的时候给`res`数组的所有值都赋值为1。

对于任一节点为根的子树来说，如果子树内包含了`1`这个基因值，那么这个子树的最小缺失基因值就一定不是`1`，那么就需要通过深度优先的思路更新缺失的最小基因值；如果对于任一节点为根的子树内不包含基因值`1`，那么缺失的最小基因值就一定是`1`。

```java
class Solution {
    public int[] smallestMissingValueSubtree(int[] parents, int[] nums) {
        int n = parents.length;
        List<Integer>[] trees = new ArrayList[n];
        for(int i=0; i<n; i++)
            trees[i] = new ArrayList<>();
        for(int i=0; i<n; i++){
            int parent = parents[i];
            if (parent==-1) continue;
            trees[parent].add(i);
        }

        int[] res = new int[n];
        Arrays.fill(res, 1);
        Set<Integer> geneSet = new HashSet<>();
        boolean[] visited = new boolean[n];

        int iNode = 1, node = -1;
        // 找到基因值为1的点
        for(int i=0; i<n; i++){
            if(nums[i]==1){
                node = i;
                break;
            }
        }
        // 不含基因值为1的子树，那么他们缺失的最小基因值就是1
        // 而对于那些包含了最小基因值为1的子树则需要通过深度优先的方式找到缺失的最小基因值
        while(node != -1){
            dfs(node, nums, trees, geneSet, visited);
            // 查看以node为根的子树所不含的最小基因值
            while(geneSet.contains(iNode))
                iNode++;
            res[node] = iNode;
            // 遍历父节点的基因值
            node = parents[node];
        }
        return res;
    }
	// 该dfs的作用：收集包含了基因值为1的节点的所有子树的基因值
    private void dfs(int node, int[] nums, List<Integer>[] trees, Set<Integer> geneSet, boolean[] visited) {
        if(visited[node]) return;
        visited[node] = true;
        geneSet.add(nums[node]);
        for(int child: trees[node]){
            dfs(child, nums, trees, geneSet, visited);
        }
    }
}
```

