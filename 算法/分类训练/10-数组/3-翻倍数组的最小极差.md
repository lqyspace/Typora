# 翻倍数组的最小极差

这是一道携程笔试真题，原题如下：

![image-20231108002018153](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202311080020547.png)

![image-20231108002053267](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202311080020675.png)

题解：**一次遍历**

这道题我们可以这样考虑，题目让我翻倍数组的某一个子数组内的数值，使极差值最小。

我们可以把数据分成三类，一类是比最大值的一半要大的值，另一类是比最大值的一半的值要小的值，还有一类是正好等于最大值的一半。

有一点我们一定需要注意，既然是子数组，那么我们寻找的子区间一定是连续的才行。

众所周知，如果我们将大于最大值一半的值进行翻倍，那么我们翻倍以后的子数组内的值一定是大于当前最大值，可能会造成极差变大，因此对于大于最大值一半的数值我们不做任何操作。

对于小于最大值一半的数值，我们可以进行翻倍，这样翻倍以后的值仍然是小于等于最大值的，有可能会减少极差。

对于等于最大值一半的数值，我们需要再考虑一遍，判断对该值有没有必要进行翻倍。

这里我使用到了两个优先级队列，一个最大值优先级队列，一个是最小值优先级队列，两个队列不断维护数值反转后的新的最大值和最小值。

代码如下：

```java
class Solution{
    public void jiCha(int[] nums){
        int n = nums.length;
        // 最大值优先级对列：降序
        PriorityQueue<Integer> pqMax = new PriorityQueue<>(new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return o2.intValue() - o1.intValue();
            }
        });
        // 最小值优先级队列：升序
        PriorityQueue<Integer> pqMin = new PriorityQueue<>();
        for(int i=0; i<n; i++){
            pqMin.offer(nums[i]);
            pqMax.offer(nums[i]);
        }
        // 初始化极差
        int diff = pqMax.peek() - pqMin.peek();
        // 向上取整
        int middle = (pqMax.peek()+1)/2;
        int cnt = 0;
        
        for(int i=0; i<n; ){
            // 复刻一个临时最大值优先级队列
            PriorityQueue<Integer> newPqMax = new PriorityQueue<>(new Comparator<Integer>() {
                @Override
                public int compare(Integer o1, Integer o2) {
                    return o2.intValue() - o1.intValue();
                }
            });
            newPqMax.addAll(pqMax);
            // 复刻一个临时最小值优先级队列
            PriorityQueue<Integer> newPqMin = new PriorityQueue<>(pqMin);
            // 将连续的子数组内小于middle的数值翻倍
            while (i<n && nums[i]<middle){
                cnt++;
                newPqMax.remove(nums[i]);
                newPqMin.remove(nums[i]);
                newPqMax.offer(nums[i]*2);
                newPqMin.offer(nums[i]*2);
                i++;
            }
            // 如果cnt不等于0，说明存在连续子区间内的数字小于middle
            if(cnt!=0){
                cnt=0;
                // 更新翻倍以后新的极差
                diff = Math.min(diff, newPqMax.peek() - newPqMin.peek());
            }
            // 单独考虑和中值相等的情况，是否翻倍的数值能得到最小极差
            while (i<n && nums[i]==middle){
                newPqMax.remove(nums[i]);
                newPqMin.remove(nums[i]);
                newPqMax.offer(nums[i]*2);
                newPqMin.offer(nums[i]*2);
                diff = Math.min(diff, newPqMax.peek() - newPqMin.peek());
                i++;
            }
            if (i<n && nums[i]>middle)
                i++;
        }
        System.out.println(diff);
    }
}
```

