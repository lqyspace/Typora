# 189-轮转数组

[189-轮转数组](https://leetcode.cn/problems/rotate-array/description/?envType=study-plan-v2&envId=top-interview-150)，难度中等

![image-20231027231520089](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310272315996.png)

方法一：**使用额外的数组**

将原数组下标为`i`的元素放至数组下标`(i+k) mod n`的位置，最后将新数组拷贝至原数组即可。

```java
class Solution {
    public void rotate(int[] nums, int k) {
        int n = nums.length;
        k = k % n;
        if(k==0) return;
        int[] newArr = new int[n];
        for(int i=0; i<n; i++){
            newArr[(i+k)%n] = nums[i];
        }
        System.arraycopy(newArr, 0, nums, 0, n);
    }
}
```

> 时间复杂度：O(n)
>
> 空间复杂度：O(n)



方法二：**环状替换**

![image-20231027233056360](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310272330453.png)

![image-20231027233114662](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310272331702.png)

题解大致看懂了，直接看代码吧。这个题目还是熟能生巧吧，可能刚开始能难想到这个方法

```java
class Solution {
    public void rotate(int[] nums, int k) {
        int n = nums.length;
        k = k%n;
        if(k==0) return;
        int cnt = gcd(n, k);
        for(int start = 0; start < cnt; start++){
            int current = start;
            int prev = nums[current];
            do{
                int next = (current + k)%n;
                int tmp = nums[next];
                nums[next] = prev;
                prev = tmp;
                current = next;
            } while(start != current);
        }
    }
    public int gcd(int x, int y){
        return y>0? gcd(y, x%y) : x;
    }
}
```

> 时间复杂度：O(n)
>
> 空间复杂度：O(1)



方法三：**数组翻转**

先将整个数组翻转，然后翻转前`k`个，再翻转后`n-k`个。

```java
class Solution {
    public void rotate(int[] nums, int k) {
        int n = nums.length;
        k = k%n;
        reverse(nums, 0, n-1);
        reverse(nums, 0, k-1);
        reverse(nums, k, n-1);
    }
    public void reverse(int[] nums, int i, int j){
        while(i<j){
            int tmp = nums[i];
            nums[i++] = nums[j];
            nums[j--] = tmp;
        }
    }
}
```

> 时间复杂度：O(1)
>
> 空间复杂度：O(1)