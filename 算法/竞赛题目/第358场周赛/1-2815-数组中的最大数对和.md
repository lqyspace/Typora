# 2815-数组中的最大数对和

[力扣2815-数组中的最大数对和](https://leetcode.cn/problems/max-pair-sum-in-an-array/description/)，难度简单

![image-20230818173809236](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308181738323.png)

**解法1：暴力**

```java
class Solution {
    public int maxSum(int[] nums){
        int n = nums.length;
        int res = -1;
        for(int i=0; i<n; i++)
            for(int j=i+1; j<n; j++){
                if(!isEqual(nums[i], nums[j])) continue;
                res = Math.max(res, nums[i]+nums[j]);
            }
        return res;
    }
    
    // 判断两个数数位上地最大数是否有相同
    public boolean isEqual(int a, int b){
        int A = -1, B = -1;
        int tmp;
        while(a!=0){
            tmp = a%10;
            A = Math.max(A, tmp);
            a = a/10;
        }
        while(b!=0){
            tmp = b%10;
            B = Math.max(B, tmp);
            b = b/10;
        }
        return A==B;        
    }
}
```

两边循环，里面还有一个判断两个数是否是最大数位相同的数。

总之时间复杂度：$O(N^2)$；空间复杂度：$O(1)$



**解法2：有一个数组来记录对应数位的最大值，详细可以看代码**

时间复杂度：$O(nlogU)$，其中 $n$ 为数组 $nums$ 的长度，$U=max(nums)$ 的长度；空间复杂度：$O(1)$

```java
class Solution {
    public int maxSum(int[] nums){
        int res = -1;
        // 记录每个数位的最大值是哪一个
        int[] maxDig = new int[10];
        Arrays.fill(maxDig, Integer.MIN_VALUE);
        for (int num: nums){
            // 获取该数字的最大数位
            int tmp = -1;
            for (int x=num; x>0; x/=10)
                tmp = Math.max(tmp, x%10);
            // 更新答案，位置不能换
            res = Math.max(res, maxDig[tmp] + num);
            // 更新最大数位的值
            maxDig[tmp] = Math.max(maxDig[tmp], num);
        }
        return res;        
    }
}
```

注意：`res`位置不能调换。首先，我们需要想明白，这是一遍遍历的过程，所以只要数组中不存在重复的值，那么就不会利用到重复的数；其次，把`res`更新的位置放在`maxDig`之前，是为了避免重复加了本身值。同时`maxDig`值的更新不会影响到`res`的结果。