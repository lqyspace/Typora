# 2817-限制条件下元素之间的最小绝对差

[力扣2817-限制条件下元素之间的最小绝对差](https://leetcode.cn/problems/minimum-absolute-difference-between-elements-with-constraint/description/)，难度中等

![image-20230818203409123](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308182034214.png)

举个例子，我们来观察一下：

`nums=[5,3,2,10,15],  x = 2`，这道题的思路就是枚举，不过枚举的时候我们也需要观察细节。

根据上面的条件，我们可以枚举出：

```java
5-2, 5-10, 5-15
3-10, 3-15
2-15
```

假如此时我们枚举的时候只看当前数字的前面遍历过的数字，因此根据我们正常遍历的顺序，我们只能利用我们遍历到的数字。假如此时枚举的是5, 5前面已经没有数字了，假如枚举的数字是3，3前面也没有差距是2的数字。当我们枚举2的时候，2的前面有一个数字5；当我们枚举10的时候，10的前面有数字5和3，当我们枚举数字15的时候，15的前面有数字5, 3和2。由此可见，我们已经枚举完所有的情况，没有遗漏。

因此，如果我们想要计算最小差值，根据`TreeSet`的特性，我们利用`ceiling`和`floor`这两个函数，可以枚举出大于等于给定数字 或 小于等于给定数字的数字，因此就可以求出最小差值。

因此我们可以借用 `TreeSet`，它可以自动排序。

```java
class Solution {
    public int minAbsoluteDifference(List<Integer> nums, int x) {
		// 将列表转为数组，提高访问性能
        int[] numss = nums.stream().mapToInt(i->i).toArray();
        int res = Integer.MAX_VALUE, n = numss.length;
        TreeSet<Integer> ts = new TreeSet<>();
        ts.add(Integer.MAX_VALUE); // 哨兵，一定要有，要不然ceiling和floor这两个函数可能报错
        ts.add(Integer.MIN_VALUE / 2);
        int left = 0, right = left+x;
        if(right >= numss.length) return -1;
        while(left < numss.length && right < numss.length){
            ts.add(numss[left]);
            res = Math.min(res, Math.min(ts.ceiling(numss[right]) - numss[right], numss[right] - ts.floor(numss[right])));
            left++; right++;
        }
        return res;
    }
}
```

