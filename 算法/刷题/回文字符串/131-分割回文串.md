# 131 分割回文串

[力扣131分割回文串](https://leetcode.cn/problems/palindrome-partitioning/)，难度中等

![image-20230718200706096](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202307182007147.png)

思路分析：找到所有可能的解，提示我们使用 **回溯算法**（采用深度优先遍历的方式遍历一棵隐式树结构）。

**方法一：回溯算法**

回溯算法思考的步骤：

1、画出树形结构，本题的递归树模型是一个多叉树；

> 友情提示：强烈建议以后做题的时候根据具体的例子画出一个树形结构

![image.png](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202307181955714.png)

2、编码

- 每一个节点表示剩余没有扫描到的字符串，产生分支是截取了剩余字符串的前缀；
- 产生前缀字符串的时候，判断前缀字符串是否是回文串
  - 如果前缀字符串是回文串，则可以产生分支和节点
  - 如果前缀字符串不是回文，则不产生分支和节点，这一步是剪枝的操作
- 在叶子节点时空节点的时候结算，**此时从根节点到叶子节点的路径，就是结果集里的一个结果，使用深度优先遍历，记录下所有可能的结果。**
- 使用一个路径变量 `track`搜索,  `track` 全局使用一个（注意结算的时候，要生成一个拷贝），因此在递归执行方法结束以后需要回溯，即将递归之前添加进来的元素拿出去。
- `track`的操作只在列表的末端，因此适合的数据结构是栈。

```java
class Solution {
    List<List<String>> res = new LinkedList<>();
    List<String> track = new LinkedList<>();
    public List<List<String>> partition(String s) {
    	backtrack(s, 0);
        return res;
    }
    
    public void backtrack(String s, int start){
        if(start == s.length()){
            // base case走到叶子结点
            // 即整个s被分成若干个回文子串，记下答案
            res.add(new LinkedList<>(track));
            return;
        }
        
        for(int i=start; i<s.length(); i++){
            // 只有是回文子串才可以继续分割
            if(!isHuiwen(s, start, i))
                continue;
            // 做选择
            // s[start...i]是一个回文串，可以进行分割
            track.add(new String(s.substring(start, i+1)));
            // 进入回溯的的下一层，继续切分s[i+1...]
            backtrack(s, i+1);
            track.remove(track.size()-1);
        }
    }
    
    public boolean isHuiwen(String s, int left, int right){
        // 这个地方之所以不写 <= 是因为，当相等时，说明left==right，此时一定是回文串，直接返回true
        while(left < right){
            if(s.charAt(left) == s.charAt(right))
                return false;
            left++;
            right--;
        }
        return true;
    }
}
```

复杂度分析：

- 时间复杂度：$O(N\cdot 2^N)$，这里的$N$为输入字符串的长度，每一个位置可拆分，也不可拆分，尝试是否可以拆分的时间复杂度为$O(2^N)$，判断每一个子串是否是回文字符串，时间复杂度是$O(N)$
- 空间复杂度：
  - 如果不计算保存结果的空间，空间复杂度为$O(N)$，递归调用栈的高度为$N$。
  - 如果计算保存答案需要空间$2^N\times N$，这里的$2^N$为保守估计，实际情况不会这么多。空间复杂度为$O(2^N \times N)$



## 回溯+动归

验证回文串的时候，每一次都是用双指针的方式验证是否是回文串，这个地方可以优化，可以先用动态规划把结果算出来，这就就可以利用 $O(1)$的时间复杂度直接得到一个字串是否是回文串。

```java
class Solution {
    List<List<String>> res = new LinkedList<>();
    List<String> track = new LinkedList<>();
    public List<List<String>> partition(String s) {
        int len = s.length();
        if(len==0) 
            return res;
        
        char[] cs = s.toCharArray();
        // 预处理
        // 状态：dp[i][j]表示s[i][j]是否是回文串
        boolean[][] dp = new boolean[len][len];
        for(int right = 0; right<len; right++){
            for(int left = 0; left<=right; left++){
                if(cs[left] == cs[right] && (right - left <= 2 || dp[left+1][right-1]))
                    dp[left][right] = true;
            }
        }
        
        backtrack(s, dp, 0);
        return res;
    }
    public void backtrack(String s, boolean[][] dp, int start){
        if(start == s.length()){
            res.add(new LinkedList<>(track));
            return;
        }
        for(int i=start; i<s.length(); i++){
            if(!dp[start][i])
                continue;
            track.add(new String(s.substring(start, i+1)));
            backtrack(s, dp, i+1);
            track.remove(track.size()-1);
        }
    }
}
```

复杂度分析：

- 时间复杂度：$O(2^N)$，这里的$N$是输入字符串的长度，每一个位置可拆分，也不可拆分，尝试是否可以拆分的时间复杂度为$O(2^N)$，判断每一个子串是否是回文字符串，时间复杂度是$O(N^2)$，所以总的时间复杂度$O(N^2+2^N)=O(2^N)$

- 空间复杂度：

  - 如果不计算保存结果的空间，动态规划表格的大小为$O(N^2)$，递归调用栈的高度为$N$，空间复杂度为$O(N^2+N)=O(N^2)$

  - 如果计算保存答案需要空间$2^N\times N$，这里的$2^N$为保守估计，实际情况不会这么多。空间复杂度为$O(2^N \times N + N^2 + N)=O(2^N \times N)$









