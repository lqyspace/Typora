# 214-最短回文字符串

[214-最短回文字符串](https://leetcode.cn/problems/shortest-palindrome/description/)，难度困难

![image-20230911234557550](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202309112346788.png)

解题方法：

最开始用的解题方法是：最长回文字符串的求法

但是报错：超出内存限制错误，代码如下：

```java
class Solution {
    public String shortestPalindrome(String s) {
        if(s==null || s.length()==0) return s;
        int n = s.length();
        boolean[][] dp = new boolean[n][n];
        for(int i=0; i<n; i++){
            dp[i][i] = true;
        }
        for(int i=n-1; i>=0; i--){
            for(int j=i+1; j<n; j++){
                dp[i][j] = s.charAt(i)==s.charAt(j) && (j-i<=2 || dp[i+1][j-1]);
            }
        }
        int i=n-1;
        for(; i>=0; i--){
            if(dp[0][i]){
                break;
            }
        }
        StringBuilder sb = new StringBuilder(s.substring(i+1, s.length()));
        StringBuilder newStr = new StringBuilder(sb.reverse().toString()+s);
        
        return newStr.toString();
    }
}
```

接下来使用的方法是：哈希字符串

```java
class Solution {
    public String shortestPalindrome(String s) {
        if(s==null || s.length()==0) return s;
        int R = 26, Q = 1000000007;
        char[] schar = s.toCharArray();
        int left = 0, right = 0;
        int mul = 1, best = -1;
        for(int i=0; i<s.length(); i++){
            left = (int)((((long)left * R) % Q + schar[i] - 'a')%Q);
            right = (int)((right + ((long)mul * (schar[i]-'a')) % Q) % Q);
            if(left == right)
                best = i;
            mul = (int)((long)mul*R % Q);
        }
        String add = (best==s.length()-1? "": s.substring(best+1));
        StringBuilder sb = new StringBuilder(add).reverse();
        sb.append(s);
        
        return sb.toString();
    }
}
```