# 接雨水

[42-接雨水](https://leetcode.cn/problems/trapping-rain-water/description/)，难度困难

![image-20230922162802202](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202309221628283.png)

题解：这道题要是说用动态规划的话，但是又没有状态转移方程。本道题其实也能在暴力的基础上进行不断的优化。

首先运用暴力的方法，我们要求在第`i`个位置可以存的下多少的水，取决于在第`i`个位置的左边，右边的最高的值的最小值，在思考的时候，我关注的只是第`i`个位置可以存的下多少的水。其他的位置，以此类推。

```java
class Solution {
    public int trap(int[] height) {
        int n = height.length;
        int res = 0;
        if(n==1) return res;
        for(int i=1; i<n-1; i++){
            int l_max = 0, r_max = 0;
            // 左边最大值
            for(int j=i; j>=0; j--){
                l_max = Math.max(l_max, height[j]);
            }
            // 右边最大值
            for(int j=i; j<n; j++){
                r_max = Math.max(r_max, height[j]);
            }
            res += (Math.min(l_max, r_max)-height[i]);
        }
        return res;
    }
}
```



其次，进一步优化：空间换时间，降低时间复杂度

```java
class Solution {
    public int trap(int[] height) {
        int n = height.length;
        int res = 0;
        if(n==1) return res;
        int[] l_max = new int[n];
        int[] r_max = new int[n];
        // base case
        l_max[0] = height[0];
        r_max[n-1] = height[n-1];
        for(int i=1; i<n; i++){
            l_max[i] = Math.max(l_max[i-1], height[i]);
        }
        for(int i=n-2; i>=0; i--){
            r_max[i] = Math.max(r_max[i+1], height[i]);
        }
        for(int i=1; i<n-1; i++){
            res += (Math.min(l_max[i], r_max[i]) - height[i]);
        }
        return res;
    }
}
```





进一步优化，我们观察到，`res`和`min(l_max, r_max)`有关系，因此我们可以进一步将空间复杂度降低。

```java
class Solution {
    public int trap(int[] height) {
        int n = height.length;
        int res = 0;
        if(n==0) return res;
        int left = 0, right = height.length - 1;
        int l_max = 0, r_max = 0;
        while(left <= right){
            l_max = Math.max(l_max, height[left]);
            r_max = Math.max(r_max, height[right]);
            
            if(l_max < r_max){
                res += (l_max - height[left]);
                left++;// 点睛之笔，车轮战
            }else {
                res += (r_max - height[right]);
                righ
            }
        }
        return res;
    }
}
```

