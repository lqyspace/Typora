# 20-有效括号

[20-有效括号](https://leetcode.cn/problems/valid-parentheses/description/)，难度中等

![image-20230902111607937](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202309021116992.png)

题解：

我根据《如何解决括号相关问题》中提到的解法思考了两种解法：第一种方法是不用栈，第二种方法是用栈。

对于这道题而言，题目中共有三种类型的括号，如果使用不用栈的解法的话，单纯进行遍历字符串匹配，你需要记录与每一个右括号对应的左括号的位置，因为是有三种右括号，我们不能遇到一个右括号就对left减一，而且还需要找每种右括号的对应关系，因此需要记录每个右括号对应的左括号的位置，可想而知这是比较麻烦的。下面是不用栈的模板，你可以自行体会：

```java
/**
* 一个字符串合法括号字符串的条件:
* 1. 左右括号数量相等;
* 2. 任意一个位置左括号的数量都大于等于右括号的数量。
*/

/**
 * 定义一个函数，检验字符串是否为合法括号字符串
 * @param str 待检验的字符串
 * @return boolean 类型，是/否合法括号字符串
 */
boolean isValid(String str) {
    // 待匹配的左括号数量
    int left = 0;
    for (int i = 0; i < str.length(); i++) {
        if (str.charAt(i) == '(') {
            left++;
        } else {
            // 遇到右括号
            left--;
        }

        // 右括号太多
        if (left == -1)
            return false;
    }
    // 是否所有的左括号都被匹配了
    return left == 0;
}
```

这种解法比较适合只有一种类型的括号，对于有三种类型的括号，用栈的解法比较好。

下面来看用栈的解法：

```java
boolean isValid(String str) {
    Stack<Character> left = new Stack<>();
    for (char c : str.toCharArray()) {
        if (c == '(' || c == '{' || c == '[')
            left.push(c);
        else { // 字符 c 是右括号
            if (!left.empty() && leftOf(c) == left.peek())
                left.pop();
            else
                // 和最近的左括号不匹配
                return false;
        }
    }
    // 是否所有的左括号都被匹配了
    return left.empty();
}

char leftOf(char c) {
    if (c == '}') return '{';
    if (c == ')') return '(';
    return '[';
}
```

