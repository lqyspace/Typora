# 7-整数反转

[7-整数反转](https://leetcode.cn/problems/reverse-integer/description/)，难度中等

![image-20230825201126306](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308252011368.png)

解题思路：

怎么翻转一个整数？

用栈？

或者把整数转为字符串，再反转这个字符串？

这两种方式都可以，但是并不好。实际上我们只要能拿到这个数字的末尾数字就可以了。

以 `12345` 为例，先拿到5，再拿到4，之后是 `3`，`2`，`1`，我们按照这样的顺序就可以翻转一个数字了。

怎么拿末尾数字呢？好办，用取模运算就可以了。

![1.jpg](https://pic.leetcode-cn.com/be35cb60bec9a9ae794abad671e6618abb5664780bc7ee30ca93ca423884a666-1.jpg)

1、将 `12345 % 10`得到5，之后再 `12345/10`

2、将 `1234 % 10`得到4，之后再 `1234/10`

以此类推

这么看起来，一个循环就可以搞定，循环判断的条件是 `x>0`， 但是这个做法是错误的，因为没有考虑**负数**

循环判断的条件应该是 `x!=0`。

有了取模和除法操作，对于像 `12300`这样的数字，也是可以完美解决掉。

看起来这个题目已经解决掉了，但是题目中给出了两个条件：

> 1、假设环境不允许存储64位整数（有符号或无符号）
>
> 2、$-2^{31} \leq x \leq 2^{31}-1$
>
> 3、如果反转后整数超过32位有符号的整数范围 $[-2^{31} \leq x \leq 2^{31}-1]$，则返回0

也就是说，我们不能够用 `long` 存储结果，而且有些数字可能是合法范围内的数字，但是翻转以后就不是合法的数字了，就超过范围了。

假设有`1147483649`这个数字，它是小于最大的32位整数`2147483647`的，但是将这个数字反转过来后就变成了`9463847411`，这就比最大的32位整数还要大了，这样的数字是没法存到`int`里面的，所以肯定要返回0(溢出了)。 甚至，我们还需要提前判断。

![2.jpg](https://pic.leetcode-cn.com/42c736510f4914af169907d61b22d1a39bd5a16bbd7eca0466d90350e2763164-2.jpg)

上图中，绿色是最大32位整数

第二排数字中，橘色的是5，它是大于上面同位置的4，这就意味着5后面跟任何数字，都会比32位整数大。

所以，我们到了最大整数的1/10的时候就要开始判断。

如果某个数字大于214748364，那后面就不用再判断了，肯定溢出了

如果某个数字等于214748364，这就对应上图中的第三，第四，第五行的数字，需要跟最大数的末尾数字比较，如果比7大，那说明溢出了。



对于负数也是一样。

![3.jpg](https://pic.leetcode-cn.com/525aa75c19702e57b780c91a7ebb990359b14e96acc09b6327d9e1f0a5b3a16a-3.jpg)

上图绿色部分是最小的32位整数，同样是在最小数的1/10处开始判断。

如果某个数比-214748364小，那说明肯定溢出了

如果某个数等于-214748364，还需要跟最小数的末尾比较，即看它是否小于8

[力扣8-字符串转换整数](https://leetcode.cn/problems/string-to-integer-atoi/description/)跟这题类似，可以去做做看。

自己写的代码：

```java
class Solution {
    public int reverse(int x) {
        int res=0;
		while(x!=0){
            res = x%10 + res*10;
            x /= 10;
            if(res > Integer.MAX_VALUE/10 && x!=0 || res < Integer.MIN_VALUE/10 && x!=0)
                return 0;
            if(res == Integer.MAX_VALUE/10 && x>=8 || res==Integer.MIN_VALUE/10 && x<=-9)
                return 0;
        }
        return res;
    }
}
```

细想，你再细想，一个合法int类型的整数，最高位肯定不会超过2，因此当这个合法的int整数倒过来的时候，最后一位肯定小于8或者大于-9，所以上面的代码还可以继续改进：

```java
class Solution {
    public int reverse(int x) {
        int res=0;
		while(x!=0){
            // 注意上下顺序有点不一样
            if(res > Integer.MAX_VALUE/10 || res < Integer.MIN_VALUE/10)
                return 0;
            res = x%10 + res*10;
            x /= 10;
        }
        return res;
    }
}
```





































