# 556-下一个更大元素III

[556-下一个更大的元素](https://leetcode.cn/problems/next-greater-element-iii/description/)，难度中等

![image-20230825175112588](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308251751651.png)

解题思路：

- 为了能够获得刚好比n大的整数，那么我们的遍历方式一定是从后往前遍历，先处理低位的数字顺序，将低位的数字尽量变大
- 在从低位往高位遍历的过程中，如果次低位比低位的数字大于等于的话，那么从个位到次低位的这段数字就不用改变。如果次低位比低位小的，次低位往后的数字一定是降序的。因此可以在次低位往后的这段数字中，找出一个刚好比次低位大的数字
- 交换着两个数字的位置，然后将次低位交换前的位置开始，往后的所有数字升序排序
- 需要注意的是，次低位往后的数字一定是降序的，即使交了数字之后，也是降序的，因此可以翻转后面的数字
- 为了避免数字溢出，转换成字符串进行处理

```java
class Solution {
    public int nextGreaterElement(int n) {
		StringBuilder sb = new StringBuilder(n+"");
        int i = sb.length()-2;
        while(i>=0 && sb.charAt(i)>=sb.charAt(i+1)){
            i--;
        }
        if(i<0) return -1;
        
        // 找一个刚好比i大的数字
        int ind = 0;
        for(int j=sb.length()-1; j>=i+1; j--){
            if(sb.charAt(j)>sb.charAt(i)){
                ind = j;
                break;
            }
        }
        // 交换
        swap(sb, i, ind);
        // 翻转
        reverse(sb, i);
        
        String res = sb.toString();
        if(res.length()>10 || res.length()==10 && res.compareTo(Integer.MAX_VALUE +"") >0)
            return -1;
        
        return Integer.parseInt(res);
    }
    
    public void swap(StringBuilder sb, int i, int j){
        // 交换位置
        char tmp = sb.charAt(i);
        sb.setCharAt(i, sb.charAt(j));
        sb.setCharAt(j, tmp);
    }
    
    public void reverse(StringBuilder sb, int i){
        // 将i之后的翻转
        String subs = sb.substring(i+1);
        sb.replace(i+1, sb.length(), new StringBuilder(subs).reverse().toString());
    }
}
```

官方给的答案：

```java
class Solution {
    public int nextGreaterElement(int n) {
        char[] nums = Integer.toString(n).toCharArray();
        int i = nums.length - 2;
        while (i >= 0 && nums[i] >= nums[i + 1]) {
            i--;
        }
        if (i < 0) {
            return -1;
        }

        int j = nums.length - 1;
        while (j >= 0 && nums[i] >= nums[j]) {
            j--;
        }
        swap(nums, i, j);
        reverse(nums, i + 1);
        long ans = Long.parseLong(new String(nums));
        return ans > Integer.MAX_VALUE ? -1 : (int) ans;
    }

    public void reverse(char[] nums, int begin) {
        int i = begin, j = nums.length - 1;
        while (i < j) {
            swap(nums, i, j);
            i++;
            j--;
        }
    }

    public void swap(char[] nums, int i, int j) {
        char temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```



解题思路二： 

不将数字进行转换，可以使用O(1)的时间复杂度解决此题。

类似方法一，不断比较最低位与次低位数字的大小，如果次低位数字不低于最低位数字，则移除最低位数字，继续循环，循环结束后的位置就是方法一对应的下标`i`。

对于方法一中的`j`的计算也是同样的道理。

最后，我们参考 [7-整数反转的官方题解](https://leetcode.cn/problems/reverse-integer/description/) 的做法，将 `i+1` 之后的部分翻转，即得到下一个整数。如果中途计算会溢出，则返回-1

```java
class Solution {
    public int nextGreaterElement(int n) {
        int x = n, cnt = 1;
        for (; x >= 10 && x / 10 % 10 >= x % 10; x /= 10) {
            ++cnt;
        }
        x /= 10;
        if (x == 0) {
            return -1;
        }

        int targetDigit = x % 10;
        int x2 = n, cnt2 = 0;
        for (; x2 % 10 <= targetDigit; x2 /= 10) {
            ++cnt2;
        }
        x += x2 % 10 - targetDigit; // 把 x2 % 10 换到 targetDigit 上

        for (int i = 0; i < cnt; ++i, n /= 10) { // 反转 n 末尾的 cnt 个数字拼到 x 后
            int d = i != cnt2 ? n % 10 : targetDigit;
            if (x > Integer.MAX_VALUE / 10 || x == Integer.MAX_VALUE / 10 && d > 7) {
                return -1;
            }
            x = x * 10 + d;
        }
        return x;
    }
}
```

