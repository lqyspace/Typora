# 459-重复的子字符串

[459-重复的子字符串](https://leetcode.cn/problems/repeated-substring-pattern/description/)，难度简单

![image-20230912004616880](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202309120046919.png)

题解1：

如果一个字符串可以被子字符串重复构造多次，那么这个字符串的长度一定是子字符串的长度的整数倍；

且子字符串一定是这个字符串的前缀。

![image-20230912005111357](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202309120051390.png)

自己写的代码：

```java
class Solution {
    public boolean repeatedSubstringPattern(String s) {
        // 如果一个字符串可以被子串多次重复重构
        // 那么可以从子串的2,倍，3倍，4倍下手来做题
        int times = 2;
        boolean flag = false;
        HashSet<String> hs = new HashSet<>();
        while(times<=s.length()){
            if(s.length()%times!=0) {
                times++;
                continue;
            }
            int start = 0;
            for(int i=0; i<times; i++){
                start = s.length()/times * i;
                hs.add(s.substring(start, start+s.length()/times));
            }
            if(hs.size()==1) return true;
            hs.clear();
            times++;
        }
        return flag;
    }
}
```

题解代码：

```java
class Solution {
    public boolean repeatedSubstringPattern(String s) {
        int n = s.length();
        
        // 子字符串的长度范围：[1, n/2]
        for(int i=1; i<=n/2; i++){
            if(n%i!=0) continue;
            boolean flag = true;
            for(int j=i; j<n; j++){
                if(s.charAt(j)!=s.charAt(j-i)){
                    flag = false;
                    break;
                }
            }
            if(flag) return true;
        }
        return false;
    }
}
```

