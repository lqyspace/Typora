# 155-最小栈

[155-最小栈](https://leetcode.cn/problems/min-stack/)，难度中等

![image-20230826161827578](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308261618656.png)

解题思路：

我们知道栈是一种操作受限的数据结构，只能从栈顶插入或弹出元素，所以对于标准的栈来说，如果想实现本题的 `getMin` 方法，只能老老实实把所有元素弹出来然后找最小值。**想提高时间效率，那肯定要通过空间换时间的思路**。

不过在具体说解法之前，我想聊一下动态集合中维护最值的问题。这类问题看似简单，但实际上是个很棘手的问题。其实本题就是如下一个场景：

假设你有若干数字，你用一个 `min` 变量维护了其中的最小值，如果现在给这些数字中添加一个新数字，那么只要比较这个新数字和 `min` 的大小就可以得出最新的最小值。但如果现在从这些数字钟删除一个数字，你还能用 `min` 变量得到最小值吗？答案是不能，因为如果这个被删除的数字恰好是最小值，那么新的 `min` 变量应该更新为第二小的元素对吧，但是我没有记录第二小的元素是多少，所以只能把所有数字重新遍历一遍。

明确了难点再回到本题，就可以对症下药了。删除栈顶元素的时候，不确定新的最小值是多少，但楼下那哥们知道啊，他当时入栈时的最小值，就是现在的最小值呗。

所以这道题的关键就是，**每个元素入栈时，还要记下来当前栈中的最小值**。比方说，可以用一个额外的栈 `minStk` 来记录栈中每个元素入栈时的栈中的最小元素是多少，这样每次删除元素时就能快速得到剩余栈中的最小元素了。



![img](https://labuladong.github.io/pictures/短题解/155.jpeg)



当然，我们还可以做一些优化，减少 `minStk` 中存储的元素个数，我把原始解法和优化解法都写出来了，供参考。

> PS：这道题并不难，但我还是很细致地分析了，希望你深刻理解其中的难点。下一步可以做一下 [239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum)，请仔细观察和思考，队列结构是如何解决这个难点的。

```java
class MinStack {
    // 保存所有入栈出栈后的所有元素
	Stack<Integer> st;
    // 保存每次入栈或出栈后的最小值
    Stack<Integer> minStack;
    public MinStack() {
		st = new Stack();
        minStack = new Stack();
    }
    
    public void push(int val) {
        // 如果这个val比minStack的栈顶元素还小，那就添加进去
		if(minStack.isEmpty() || val<=minStack.peek())
            minStack.push(val);
        st.push(val);
    }
    
    public void pop() {
        // 如果st的栈顶元素是最小值，那就需要连通minStack栈的栈顶元素也得删除
        // 但是如果st的栈顶元素和minStack的栈顶元素并不相等，则说明要删除的数并不是最小值，
        // 所以只需要删除st的栈顶元素即可，minStack的栈顶元素不用删除
		if(st.pop().equals(minStack.peek())){
            minStack.pop();
        }
    }
    
    public int top() {
		return st.peek();
    }
    
    public int getMin() {
		return minStack.peek();
    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(val);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */
```

下面是题解：

```java
// 原始思路
class MinStack1 {
    // 记录栈中的所有元素
    Stack<Integer> stk = new Stack<>();
    // 阶段性记录栈中的最小元素
    Stack<Integer> minStk = new Stack<>();

    public void push(int val) {
        stk.push(val);
        // 维护 minStk 栈顶为全栈最小元素
        if (minStk.isEmpty() || val <= minStk.peek()) {
            // 新插入的这个元素就是全栈最小的
            minStk.push(val);
        } else {
            // 插入的这个元素比较大
            minStk.push(minStk.peek());
        }
    }
    
    public void pop() {
        stk.pop();
        minStk.pop();
    }
    
    public int top() {
        return stk.peek();
    }
    
    public int getMin() {
        // minStk 栈顶为全栈最小元素
        return minStk.peek();
    }
}
// 优化版
class MinStack {
    // 记录栈中的所有元素
    Stack<Integer> stk = new Stack<>();
    // 阶段性记录栈中的最小元素
    Stack<Integer> minStk = new Stack<>();

    public void push(int val) {
        stk.push(val);
        // 维护 minStk 栈顶为全栈最小元素
        if (minStk.isEmpty() || val <= minStk.peek()) {
            // 新插入的这个元素就是全栈最小的
            minStk.push(val);
        }
    }

    public void pop() {
        // 注意 Java 的语言特性，比较 Integer 相等要用 equals 方法
        if (stk.peek().equals(minStk.peek())) {
            // 弹出的元素是全栈最小的
            minStk.pop();
        }
        stk.pop();
    }

    public int top() {
        return stk.peek();
    }

    public int getMin() {
        // minStk 栈顶为全栈最小元素
        return minStk.peek();
    }
}
```

