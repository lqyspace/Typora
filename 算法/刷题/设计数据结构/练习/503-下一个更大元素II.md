# 503-下一个更大元素

[503-下一个更大元素](https://leetcode.cn/problems/next-greater-element-ii/)，难度中等

![image-20230825160638300](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308251606359.png)

解法一：常规思路

```java
class Solution {
    public int[] nextGreaterElements(int[] nums) {
		int[] res = new int[nums.length];
        Arrays.fill(res, -1);
        for(int i=0; i<nums.length; i++){
            int j=i+1;
            j = j%nums.length;
            while(j!=i){
                if(nums[j]>nums[i]){
                    res[i] = nums[j];
                    break;
                }else
                    j++;
                j = j%nums.length;
            }
        }
        return res;
    }
}
```



解法二：**单调栈**

- 常规的思路就是把数组翻倍，这样就能把数组最后一位的下一个更大的元素找到
- 但是我们没必要构造一个新数组，我们可以利用循环数组模拟数组长度翻倍的效果
- 套用单调栈的模板

![img](https://labuladong.github.io/algo/images/单调栈/2.jpeg)

```java
class Solution {
    public int[] nextGreaterElements(int[] nums) {
		int[] res = new int[nums.length];
        Stack<Integer> st = new Stack();
        for(int i=2*nums.length - 1; i>=0; i--){
            while(!st.isEmpty() && st.peek() <= nums[i%nums.length]){
                st.pop();
            }
            res[i%nums.length] = st.isEmpty()? -1: st.peek();
            st.push(nums[i%nums.length]);
        }
        return res;
    }
}
```

