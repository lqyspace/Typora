# 496-下一个更大元素I

[496-下一个更大元素](https://leetcode.cn/problems/next-greater-element-i/)，难度简单

![image-20230825142811259](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308251428330.png)

解题思路：**单调栈模板**

- 单调栈实际上就是栈，只是利用一些巧妙的逻辑，使得每次新元素入栈后，栈内的元素都保持有序（单调递增或者单调递减）。
- 在找下一个更大元素的过程，使用倒着遍历的的方式，如果栈顶元素比当前元素小，那就把栈顶元素逐个删除，然后把当前入栈；如果当前元素比栈顶元素小，那就直接入栈，这样就保证了栈内的元素是从小到大排列的，也就可以找到当前元素下一个更大的元素。

我自己写的代码：

```java
class Solution {
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
		int[] res = new int[nums1.length];
        // 记录nums1中的数字
        HashMap<Integer, Integer> hm = new HashMap<>();
        for(int i=0; i<nums1.length; i++)
            hm.put(nums1[i], i);
        // 使用栈，记录比当前数字更大的数字
        Stack<Integer> st = new Stack();
        // 倒着遍历更容易找到 下一个更大的元素
        for(int i=nums2.length-1; i>=0; i--){
            while(!st.isEmpty() && nums2[i] >= st.peek()){
                // 删除栈顶的元素
                st.pop();
            }
            if(hm.containsKey(nums2[i])){
                res[hm.get(nums2[i])] = st.isEmpty()? -1: st.peek();
            }
            st.push(nums2[i]);
        }
        return res;
    }
}
```

题解给的模板：

```java
int[] nextGreaterElement(int[] nums1, int[] nums2) {
    // 记录 nums2 中每个元素的下一个更大元素
    int[] greater = nextGreaterElement(nums2);
    // 转化成映射：元素 x -> x 的下一个最大元素
    HashMap<Integer, Integer> greaterMap = new HashMap<>();
    for (int i = 0; i < nums2.length; i++) {
        greaterMap.put(nums2[i], greater[i]);
    }
    // nums1 是 nums2 的子集，所以根据 greaterMap 可以得到结果
    int[] res = new int[nums1.length];
    for (int i = 0; i < nums1.length; i++) {
        res[i] = greaterMap.get(nums1[i]);
    }
    return res;
}

int[] nextGreaterElement(int[] nums) {
    int n = nums.length;
    // 存放答案的数组
    int[] res = new int[n];
    Stack<Integer> s = new Stack<>(); 
    // 倒着往栈里放
    for (int i = n - 1; i >= 0; i--) {
        // 判定个子高矮
        while (!s.isEmpty() && s.peek() <= nums[i]) {
            // 矮个起开，反正也被挡着了。。。
            s.pop();
        }
        // nums[i] 身后的更大元素
        res[i] = s.isEmpty() ? -1 : s.peek();
        s.push(nums[i]);
    }
    return res;
}

```

