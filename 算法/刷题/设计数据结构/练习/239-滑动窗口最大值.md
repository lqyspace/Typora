# 239-滑动窗口最大值

[239-滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/description/)，难度困难

![image-20230826154812600](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308261548673.png)

解题思路：本题套用单调队列解决滑动窗口模板，具体解析不赘述

> 我在 [155. 最小栈](https://leetcode.cn/problems/min-stack) 的思路中详细分析了动态集合中维护最值的「千古难题」，如果你没有做，可以先去做一下。我想请你结合这两道题仔细思考：队列和栈分别是如何解决最值维护问题的？
>
> 我自己的回答：在实现这道题的时候，是用队列维护的，实现过程是头部删除，尾部插入，所以可以用这个解题模板。但是 [155-最小栈](https://leetcode.cn/problems/min-stack) 这道题，插入和删除都在栈顶，所以这个解题模板并不适用于 [155-最小栈](https://leetcode.cn/problems/min-stack)。
>
> 但是这种题型都有一个共同特点，那就是==**先使用了栈或队列来保存入栈或出栈后的所有元素，然后使用一个辅助栈来保存每次元素入栈或出栈后的最小值  或  辅助队列来计算当前队列里的最大值与最小值**==

使用一个队列充当不断滑动的窗口，每次滑动记录其中的最大值：



![img](https://labuladong.github.io/pictures/单调队列/1.png)



如何在 `O(1)` 时间计算最大值，只需要一个特殊的数据结构「单调队列」，`push` 方法依然在队尾添加元素，但是要把前面比自己小的元素都删掉，直到遇到更大的元素才停止删除。



![img](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308261549639.png)



使用单调队列数据结构就能完成本题。

```java
class Solution {
    /* 单调队列的实现 */
    class MonotonicQueue {
        LinkedList<Integer> q = new LinkedList<>();
        public void push(int n) {
            // 将小于 n 的元素全部删除
            while (!q.isEmpty() && q.getLast() < n) {

                q.pollLast();
            }
            // 然后将 n 加入尾部
            q.addLast(n);
        }

        public int max() {
            return q.getFirst();
        }

        public void pop(int n) {
            if (n == q.getFirst()) {
                q.pollFirst();
            }
        }
    }

    /* 解题函数的实现 */
    public int[] maxSlidingWindow(int[] nums, int k) {
        MonotonicQueue window = new MonotonicQueue();
        List<Integer> res = new ArrayList<>();

        for (int i = 0; i < nums.length; i++) {
            if (i < k - 1) {
                //先填满窗口的前 k - 1
                window.push(nums[i]);
            } else {

                // 窗口向前滑动，加入新数字
                window.push(nums[i]);
                // 记录当前窗口的最大值
                res.add(window.max());
                // 移出旧数字
                window.pop(nums[i - k + 1]);
            }
        }
        // 需要转成 int[] 数组再返回
        int[] arr = new int[res.size()];
        for (int i = 0; i < res.size(); i++) {
            arr[i] = res.get(i);
        }
        return arr;
    }
}
```

扩展延伸版：

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        MonotonicQueue<Integer> mon = new MonotonicQueue<>();
        List<Integer> res = new ArrayList<>();

        for(int i=0; i<nums.length; i++){
            if(i<k-1)
                mon.push(nums[i]);
            else {
                mon.push(nums[i]);
                res.add(mon.max());
                mon.pop();
            }
        }
        int[] arr = new int[res.size()];
        for(int i=0; i<res.size(); i++)
            arr[i] = res.get(i);
        return arr;
    }
}

class MonotonicQueue<E extends Comparable<E>>{
    private LinkedList<E> queue;
    private LinkedList<E> maxq;
    private LinkedList<E> minq;

    public MonotonicQueue(){
        maxq = new LinkedList<>();
        minq = new LinkedList<>();
        queue = new LinkedList<>();
    }

    public void push(E elem){
        queue.addLast(elem);

        while(!maxq.isEmpty() && maxq.getLast().compareTo(elem) < 0){
            maxq.pollLast();
        }
        maxq.addLast(elem);

        while(!minq.isEmpty() && minq.getLast().compareTo(elem) > 0){
            minq.pollLast();
        }
        minq.addLast(elem);
    }

    public E pop(){
        if(size()==0) return null;

        E first = queue.pollFirst();
        if(maxq.getFirst().equals(first))
            maxq.pollFirst();
        if(minq.getFirst().equals(first))
            minq.pollFirst();
        return first;
    }

    public int size(){
        return queue.size();
    }

    public E max(){
        return maxq.getFirst();
    }

    public E min(){
        return minq.getFirst();
    }
}
```

