# 115-不同的子序列

[力扣115-不同的子序列](https://leetcode.cn/problems/distinct-subsequences/description/?show=1)，难度困难

![image-20230803115935746](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308031159834.png)

我们的原问题是求 `s[0...]` 中不同子序列 `t[0...]` 在s中的什么位置，假设 `s[2]`，`s[6]` 是字符  `t[0]`，那么原问题转化成了在 `s[2...]`和 `s[6...]`中寻找不同的子序列 `t[1...]`。

我的解法：

```java
class Solution {
    int res = 0;
    public int numDistinct(String s, String t) {
        StringBuilder sb = new StringBuilder();
        dfs(s, t, 0, sb);
        return res;
    }

    public void dfs(String s, String t, int index, StringBuilder sb){
        int len = sb.length();
        if(len == t.length()){
            res++;
            return;
        }
        char cht = t.charAt(len);
        for(int i=index; i<s.length(); i++){
            if(s.charAt(i) == cht){
                sb.append(cht);
                dfs(s, t, i+1, sb);
                sb.deleteCharAt(sb.length()-1);
            }
        }
    }
}
```

小优化：

```java
class Solution {
    public int numDistinct(String s, String t) {
        return dfs(s, 0, t, 0);
    }

    public int dfs(String s, int index, String t, int j){
        if(j == t.length()){
            return 1;
        }
        char cht = t.charAt(j);
        int res = 0;
        for(int i=index; i<s.length(); i++){
            if(s.charAt(i) == cht){
                res += dfs(s, i+1, t, j+1);
            }
        }
        return res;
    }
}
```

这个解法采用深度优先搜索遍历的解法，如果不考虑时间的话，可以解出正确解。

但是如果字符串都太长的话，这个两个解法超时了。

这个解法当然超时，因为没有用 `memo` 备忘录消除重叠子问题。但就算你加上备忘录优化之后，算法依然可能超时，因为我们的递归函数 `dp` 中包含一个 for 循环。

带备忘录的动态规划算法的时间复杂度 = 子问题的个数 x 函数本身的时间复杂度 = O(MN) * O(M)，`M, N` 分别代表 `s, t` 的长度。

下面尝试用第二种视角进行穷举，即站在 `s` 的视角：

我们的原问题是求 `s[0..]` 中不同子序列 `t[0..]`，可以先看看 `s[0]` 是否能匹配 `t[0]`，如果不可以，那没得说，原问题就转化为让 `s[1..]` 去匹配 `t[0..]`；

但如果 `s[0]` 可以匹配 `t[0]`，那么又有两种情况，这两种情况是累加的关系：

1、让 `s[0]` 匹配 `t[0]`，那么原问题转化为让 `s[1..]` 去匹配 `t[1..]`。

2、不让 `s[0]` 匹配 `t[0]`，那么原问题转化为让 `s[1..]` 去匹配 `t[0..]`。

比如 `s = "aab", t = "ab"`，就有两种匹配方式：`a_b` 和 `_ab`。

按照这个思路，状态转移方程就是：

```java
// 站在s的视角的状态转移方程
int dp(String s, int i, String t, int j){
	if(s.charAt(i)==t.charAt(j))
        return dp(s, i+1, t, j+1) + dp(s, i+1, t, j);
    else
        return dp(s, i+1, t, j);
}
```

然后，就能翻译成代码，处理一下 base case，加个备忘录，具体代码我写在下面。如果你愿意，也可以改写成自底向上的迭代解法。

这个解法函数本身没有循环，递归次数（子问题个数）经过优化之后就是 O(MN)，所以总的时间复杂度就是 O(MN)。

**详细题解：[动态规划穷举的两种视角](https://labuladong.github.io/article/fname.html?fname=动归两种视角)**

**标签：[动态规划](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzAxODQxMDM0Mw==&action=getalbum&album_id=1318881141113536512)**

```java
class Solution{
    int[][] memo;
    public int numDistinct(String s, String t){
        memo = new int[s.length()][t.length()];
        for(int[] row: memo)
            Arrays.fill(row, -1);
        return dp(s, 0, t, 0);
    }
    
    public int dp(String s, int i, String t, int j){
        int m = s.length(), n = t.length();
        if(j == n)
            // 子序列全部匹配玩
            return 1;
        if(n-j > m-i)
            // 待匹配的长度不足以继续匹配下去
            return 0;
        // 备忘录里面已经存在
        if(memo[i][j]!=-1)
            return memo[i][j];
        
        int res = 0;
        // 状态转移方程
        if(s.charAt(i) == t.charAt(j))
            res += dp(s, i+1, t, j+1) + dp(s, i+1, t, j);
        else
            res += dp(s, i+1, t, j);
        memo[i][j] = res;
        return res;
    }
}
```



