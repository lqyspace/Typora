# 44-通配符匹配

[44-通配符匹配](https://leetcode.cn/problems/wildcard-matching/description/)，难度困难

![image-20230922200113110](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202309222001211.png)

这道题跟 [10-正则表达式匹配](https://leetcode.cn/problems/regular-expression-matching/description/) 属于同一类型的方法，具体的解题方法不再赘述，直接看代码，下面的代码是自己写的代码。

```java
class Solution {
    int[][] memo;
    public boolean isMatch(String s, String p) {
        int m = s.length(), n = p.length();
        memo = new int[m][n];
        for(int[] row: memo){
            Arrays.fill(row, -1);
        }
        return dp(s, 0, p, 0);
    }

    public boolean dp(String s, int i, String p, int j){
        if(j>=p.length())
            return i>=s.length();
        if(i==s.length()){
            // p的最后几位如果不是*，则返回false
            for(; j<p.length(); j++){
                if(p.charAt(j)!='*'){
                    return false;
                }
            }
            return true;
        }

        if(memo[i][j]!=-1){
            return memo[i][j]==1;
        }

        boolean res = true;
        if(s.charAt(i)==p.charAt(j) || p.charAt(j)=='?'){
            // 只匹配一个
            res = dp(s, i+1, p, j+1);
        }else if(p.charAt(j)=='*'){
            // 单个*可以匹配也可以不匹配
            res = dp(s, i+1, p, j) || dp(s, i+1, p, j+1) || dp(s, i, p, j+1);
        }else{
            res = false;
        }
        memo[i][j] = res? 1:0;
        return res;
    }
}
```

官解如下：

```java
class Solution {
    // 备忘录，-1 代表还未计算，0 代表 false，1 代表 true
    private int[][] memo;

    public boolean isMatch(String s, String p) {
        if (p.isEmpty()) {
            return s.isEmpty();
        }
        // 将 p 中相邻的 * 去除，以提升效率
        String pp = removeAdjStar(p);
        int m = s.length(), n = pp.length();
        // 备忘录初始化为 -1
        memo = new int[m][n];
        for (int i = 0; i < m; i++) {
            Arrays.fill(memo[i], -1);
        }
        // 执行自顶向下带备忘录的动态规划
        return dp(s, 0, pp, 0);
    }

    // 删除相邻的 * 号，返回删除后的字符
    private String removeAdjStar(String p) {
        if (p.isEmpty()) {
            return "";
        }
        StringBuilder sb = new StringBuilder();
        sb.append(p.charAt(0));
        for (int i = 1; i < p.length(); i++) {
            if (p.charAt(i) == '*' && p.charAt(i - 1) == '*') {
                continue;
            }
            sb.append(p.charAt(i));
        }
        return sb.toString();
    }

    // 定义：判断 s[i..] 是否能被 p[j..] 匹配
    private boolean dp(String s, int i, String p, int j) {
        // base case
        if (j == p.length() && i == s.length()) {
            return true;
        }
        if (i == s.length()) {
            for (int k = j; k < p.length(); k++) {
                if (p.charAt(k) != '*') {
                    return false;
                }
            }
            return true;
        }
        if (j == p.length()) {
            return false;
        }
        if (memo[i][j] != -1) {
            return memo[i][j] == 1;
        }

        boolean res = false;
        if (s.charAt(i) == p.charAt(j) || p.charAt(j) == '?') {
            // s[i] 和 p[j] 完成匹配
            res = dp(s, i + 1, p, j + 1);
        } else if (p.charAt(j) == '*') {
            // s[i] 和 p[j] 不匹配，但 p[j] 是通配符 *
            // 可以匹配 0 个或多个 s 中的字符，
            // 只要有一种情况能够完成匹配即可
            res = dp(s, i + 1, p, j)
                    || dp(s, i, p, j + 1);
        }
        // 将 s[i] 和 p[j] 的匹配结果存储备忘录
        memo[i][j] = res ? 1 : 0;

        return res;
    }
}
```

