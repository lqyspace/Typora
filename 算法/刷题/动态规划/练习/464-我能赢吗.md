# 464-我能赢吗

[力扣464-我能赢吗](https://leetcode.cn/problems/can-i-win/description/)，难度中等

![image-20230812152952899](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308121529980.png)

**题目大意**

数字池中有一堆数字[1, 2, 3, 4, 5, 6, 7, 8, ...,  maxChoosableInteger]，两个人轮流不放回的从这些数字中拿走一个数字。

当某个人抽到一个数字后，两个人已抽到的数字的累加和 $>=desiredTotal$，那么此时这个人就赢了。

问，先手是否必赢？

> 注意，与$desiredTotal$比较的不是各自的累加和，而是两个人已抽到数字都加在一起的累加和。



**分析**

博弈问题，都会假设两个游戏的玩家都很聪明，两个人都会 **每次选择前，分析后续所有可能的结果。**

当选择一种方案后可以让自己稳赢的时候，一定会选择这个方案；当无论怎么选择都必输，才不情愿的选择某一个方案。

这道题是没有任何规律可寻的，玩家在做选择的时候，都只能穷举所有可能的方案，选择最优解。



**游戏的规则**

两个人轮流在同一个公共整数池中拿数字，而且都把已选择的数字放在一起求和。

刚开始的时候，玩家$A$是先手，但是在玩家$A$拿完数字后，玩家$B$就成剩余局面的先手。

也就是说当轮到自己选择的时候，自己就是先手，对方就是后手。

进一步，我们可以完全抛掉 **先后手** 这个概念，直接变成：**在当前局面下，当前做选择的玩家一定能赢吗？**

这就抽象成了一个「递归」问题：

- 递归函数定义：在当前局面下，当前做选择的玩家一定能赢吗？

- 输入：当前局面，包括可选的「公共整数池」，「已选择的数字」之和，$desiredTotal$。
- 输出：当前做选择的玩家一定能赢吗？
- 递归的产生：假如当前玩家从「公共整数池」中选择了数字 $x$，那么当下一步对方在新局面做选择的时候是否一定输。

关于「递归的产生」这里多解释一下。

**如果当前做选择的玩家在「公共整数池」中选择 xxx，如果选择了 xxx 之后，对手继续玩一定会输，那么当前玩家一定赢。**
**如果当前的玩家把「公共整数池」全部遍历判断了，但无论选择哪个数字，对手都一定赢，那么当前玩家就一定输。**

**代码解法**：

```java
class Solution{
    // 定义一个备忘录，避免重复的计算
    HashMap<Integer, Boolean> memo = new HashMap<>();
    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {
		// 计算所有数字是否可以到达目标和
        double total = (1+maxChoosableInteger)*maxChoosableInteger*0.5;
        if(total<desiredTotal) return false;
        
        return dfs(maxChoosableInteger, 0, 0, desiredTotal);
    }
    
    public boolean dfs(int maxChoosableInteger, int usedNumber, int currentTotal, int desiredTotal){
        // usedNumber 表示被选择的数字
        // 特别说明：usedNumber形如：0100，从右往左数，第3位是1，说明数字3已经访问过；0101，则说明数字1和3已经访问过
        // 题目中maxChoosableInteger的最大值为20，不会超过最大整数范围32位。
        // 如果usedNumber在memo中出现过，则说明已经进行过计算，为了避免重复直接返回结果
        if(!memo.containsKey(usedNumber)){
            boolean res = false;
            // 对usedNumber进行逐个遍历，从右往左最多遍历usedNumber的第maxChoosableInteger位（从右往左数，索引从1开始）
            for(int i=0; i<maxChoosableInteger; i++){
                // 注意此处的 i 是从0开始的
                // 当前玩家选择了 i+1 以后，如果大于等于 desiredTotal，则当前玩家必赢
                if(((usedNumber >> i) & 1) == 0){
                    // 将usedNumber右移i位，然后与1进行逻辑与，如果值为0，说明usedNumber右移i位后，最后的末尾是0而不是1。也就是说，usedNumber的倒数第i+1位（从右往左数，末尾为第1位）是0而不是1，所以数字i+1并没有被访问过，因此执行下面的操作
                    if(i+1+currentTotal >= desiredTotal){
                        res = true;
                        break;
                    }
                // 当前玩家选择了i+1以后，另一个玩家是否一定会输
                if(!dfs(maxChoosableInteger, usedNumber | (1 << i), i+1+currentTotal, desiredTotal)){// usedNumber 与 (1 << i) 逻辑或，即将usedNumber的从右往左数第i+1位标记为1，末尾认为为第1位
                    res = true;
                    break;
                }                
            }
          }
            memo.put(usedNumber, res);
        }
        return memo.get(usedNumber);
    }
}
```















































