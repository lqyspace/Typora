# 494-目标和

[494-目标和](https://leetcode.cn/problems/target-sum/)，难度中等

![image-20230926172020443](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202309261720511.png)

题解：回溯的解法

```java
class Solution {
    int res = 0;
    public int findTargetSumWays(int[] nums, int target) {
		backtrace(nums, 0, target, 0);
        return res;
    }
    public void backtrace(int[] nums, int i, int target, int path){
        if(i==nums.length){
        	if(target==path){
                res++;
            }
            return;
        } 
        // 这一句不要写，因此即使中途已经超过了target，后期可能会有减操作
        // if(target<=path) return;
        
        // 既然已经详细的枚举了，那么就不要再写for循环了
        path+=(nums[i]);
        backtrace(nums, i+1, target, path);
        path-=nums[i];

        path+=(-nums[i]);
        backtrace(nums, i+1, target, path);
        path-=(-nums[i]);
        
        // 这部分代码可以优化
        
    }
}
```

```java
class Solution {
    int res = 0;
    public int findTargetSumWays(int[] nums, int target) {
		backtrace(nums, 0, target);
        return res;
    }
    public void backtrace(int[] nums, int i, int target){
        if(i==nums.length){
        	if(target==0){
                res++;
            }
            return;
        } 
        // 这一句不要写，因此即使中途已经超过了target，后期可能会有减操作
        // if(target<=path) return;
        
        // 这部分代码可以优化
        backtrace(nums, i+1, target-nums[i]);
        backtrace(nums, i+1, target+nums[i]);
        
    }
}
```

题解：动态规划

这道题中，每一个状态 `i` 和 `target` 的值会组成一个唯一的键，所以可以用备忘录进行剪枝

```java
class Solution {
    HashMap<String, Integer> memo = new HashMap<>();
    public int findTargetSumWays(int[] nums, int target) {
		if(nums.length == 0) return 0;
        return backtrace(nums, 0, target);
    }
    
    public int backtrace(int[] nums, int i, int target){
        if(i==nums.length){
        	if(target==0){
                return 1;
            }
            return 0;
        } 
        String key = i + "," + target;
        if(memo.containsKey(key)){
            return memo.get(key);
        }
               
        // 这部分代码可以优化
        int res = backtrace(nums, i+1, target-nums[i]) + backtrace(nums, i+1, target+nums[i]);
        memo.put(key, res);
        return res;
    }
}
```

