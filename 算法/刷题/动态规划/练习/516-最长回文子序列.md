# 最长回文子序列

[力扣516-最长回文子序列](https://leetcode.cn/problems/longest-palindromic-subsequence/description/)，难度中等

![image-20230806092622401](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308060926254.png)

代码及解析如下：

```java
class Solution {
    public int longestPalindromeSubseq(String s) {
        // 假设dp[i][j]表示字符串s[i...j]范围内的最长回文字符串的长度
        // 如果已知dp[i+1][j-1],如何推倒dp[i][j]
        // dp[i][i]表示其本身肯定是一个最长回文字符串
        int[][] dp = new int[s.length()][s.length()];
        for(int i=0; i<s.length(); i++)
            dp[i][i] = 1;
        // 推到状态转移方程
        // if s[i] == s[j],则 dp[i][j] = dp[i+1][j-1] + 2
        // if s[i] != s[j]，则 dp[i][j] 的值肯定是 dp[i][j-1], d[i+1]dp[j]中的最大一个
        // 因为我们要推倒dp[i][j] 需要用上 dp[i+1][j-1], dp[i][j-1], dp[i+1][j]，所以
        // i：i=n-1; i>=0; i--
        // 因为 s[i...j]中一定是i<=j,那些i>j的位置没有意义，应初始化为0，又因为前面已经将i==j的部分给初始值1，所以下面的循环里：j=i+1
        // j：j=i+1; j<n; j++
        int n = s.length();
        for(int i=n-1; i>=0; i--)
            for(int j=i+1; j<n; j++){
                if(s.charAt(i) == s.charAt(j))
                    dp[i][j] = dp[i+1][j-1] + 2;
                else
                    dp[i][j] = Math.max(dp[i][j-1], dp[i+1][j]);
            }
        return dp[0][n-1];
    }
}
```

