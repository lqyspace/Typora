# 最长递增子序列

力扣300 [最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)，难度中等

![image-20230710164620112](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202307101646173.png)

## 动态规划思想

众所周知，动态规划的思想是数学归纳法。

对于数学归纳法大家都不陌生，如果我们想证明一个数学结论，那我们先假设这个结论在 `k<n`是成立，然后根据这个假设，想办法推导证明 `k=n`的时候也成立。如果能够证明出来，那么就说明这个结论对于 `k`等于任何数都成立。

类似的，我们设计动态规划的思想，不是需要一个`dp`数组吗？我们可以假设 `dp[0...i-1]`都已经被算出来了，那么如何通过以前的值算出 `dp[i]`的值呢？

首先，我们需要定义 `dp[i]`的含义：`dp[i]`表示以 `num[i]`这个数结尾的最长递增子序列的长度。

根据这个定义，我们可以推算出 `dp[i]`的初始值为1，因为以 `num[i]`结尾的最长递增子序列起码要包含它自己。

![img](https://labuladong.github.io/algo/images/最长递增子序列/8.jpeg)

我们的目的是找出 `dp`数组中的最大值。

由于我们需要找的是以 `num[i]`结尾的严格递增的子序列，子序列和子串并不一样，子串是要求连续的，而子序列却不一定连续。

假设我们已经知道了`dp[0...4]`的值，那么我们如何通过这些已知结果计算出 `dp[5]`呢？

![img](https://labuladong.github.io/algo/images/最长递增子序列/6.jpeg)

`num[5]=3`，既然是递增子序列，我们只要找到前面那些结尾比3晓得子序列，然后把3接到这些子序列的末尾，就可以形成一个新的子序列，而且这个新的子序列的长度加1.

`num[5]`前面哪些元素小于3的呢？这个好算，用for循环比较一波就能把这些元素找出来。

```java
int lengthOfLIS(int[] nums) {
    // 定义：dp[i] 表示以 nums[i] 这个数结尾的最长递增子序列的长度
    int[] dp = new int[nums.length];
    // base case：dp 数组全都初始化为 1
    Arrays.fill(dp, 1);
    for (int i = 0; i < nums.length; i++) {
        for (int j = 0; j < i; j++) {
            if (nums[i] > nums[j]) 
                dp[i] = Math.max(dp[i], dp[j] + 1);
        }
    }
    
    int res = 0;
    for (int i = 0; i < dp.length; i++) {
        res = Math.max(res, dp[i]);
    }
    return res;
}
```

至此，这道题解决了，时间复杂度为 `O(N^2)`。总结一下如何找到动态规划转移关系：

1、明确 `dp`数组的含义。这一步对于任何动态规划任何问题都很重要，如果不得当或者不够清晰，都会阻碍之后的步骤。

2、根据 `dp`数组的含义，运用数学归纳的思想，假设 `dp[0...i-1]`都已知，想办法求出 `dp[i]`，一旦这一步完成了，整个题目基本就解决了。

但如果无法完成这一步，很可能就是 `dp` 数组的定义不够恰当，需要重新定义 `dp` 数组的含义；或者可能是 `dp` 数组存储的信息还不够，不足以推出下一步的答案，需要把 `dp` 数组扩大成二维数组甚至三维数组。

目前的解法是标准的动态规划，但对最长递增子序列问题来说，这个解法不是最优的，可能无法通过所有测试用例了，下面讲讲更高效的解法。



## 二分查找法

这个解法的时间复杂度为 `O(NlogN)`，但是这个解法有点难，一般人想不到，如果之前没有遇到过类似的解法，估计很难想到。正常情况下，能够使用动态规划的解法解出此题已经很不错了。

其实最长递增子序列和一种叫做patience game的纸牌游戏有关，甚至有一种排序叫做patience sorting（耐心排序）。

为了简单起见，后文跳过了所有的数学证明，通过一个简单的例子来理解一下算法思路。

首先，给你一排扑克牌，我们像遍历数组那样从左到右一张一张处理这些扑克牌，最终把这些扑克牌分成若干堆。

![img](https://labuladong.github.io/algo/images/最长递增子序列/poker1.jpeg)

处理这些扑克牌要遵循以下的规则：

只能把点数小的牌压在点数大的牌；如果当前牌点数较大没有可以放置的牌堆，则新建一个堆，把这张牌放进去；如果当前排有多个堆可以选择，则选择最左边的那一堆放置。

比如把上述的扑克牌最终分成这样的5堆（我们认为纸牌A的牌面最大，纸牌2的牌面最小）。

![img](https://labuladong.github.io/algo/images/最长递增子序列/poker2.jpeg)

为什么遇到多个可选择的堆的时候要放在最左边的堆上呢？因为这样的可以保证牌堆顶的牌有序（2,4,7,8，Q），证明略。

![img](https://labuladong.github.io/algo/images/最长递增子序列/poker3.jpeg)



按照上述规则执行，可以算出最长递增子序列，牌的堆数就是最长递增子序列的长度，证明略。

![img](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202307102045252.jpeg)

> 在上述牌堆中，我们可以发现以下几点特征：
>
> 1、每一堆的牌堆顶的牌是有序递增的，因为牌根据大小是首选放在最左边的。
>
> 2、每一堆的牌是按照降序排序的。这就相当于在牌中找到的一组降序的序列，该算法也可以用于找牌中最长递减子序列，如果把牌的的顺序倒过来，就可以变成递增子序列。
>
> 3、牌的堆数就是最长递增子序列的长度。

我们只要把处理扑克牌的过程编程写出来即可。每次处理一张扑克牌不是要找一个合适的牌堆顶来放吗，牌堆顶的牌不是**有序**吗，这就能用到二分查找了：用二分查找来搜索当前牌应放置的位置。

```java
int lengthOfLIS(int[] nums){
	int[] top = new int[nums.length];// 存放堆顶的牌
    int piles = 0; // 牌的初始堆数为0
    // 处理每一张牌
    for(int i=0; i<nums.length; i++){
        // 获取当前的牌面
        int poker = nums[i];
        // 使用二分查找看牌应该放的位置——左侧边界
        int left = 0, right = piles;
        while(left<right){
            int mid = left + (right - left)/2;
            if(top[mid] > poker)
                right = mid;
            else if(top[mid] < poker)
                left = mid + 1;
            else
                right = mid;
        }
        if(left == piles) piles++;// 如果没有可以放置的堆顶，那就新建一个堆；
        top[left] = poker;// 找到可以防止的牌堆，放在牌堆顶上   
    }
    return piles;
}
```

**1、为什么要求左侧边界？**

因为我们要将牌放在可以放的最左侧的牌堆上

**2、`top[mid]>poker`有何深意？**

只要这个 `if`语句可以被执行到，那说明poker最低最低也是可以放在这个牌堆上的，只不过我们的目的是为了找到左侧边界。

**3、为什么最后的 `if`语句判断的是 `left==piles`？**

如果这个牌面不能在牌堆里找到一个可以放的牌顶的话，那么程序的流程一定是是不会走第一个 `if`语句的（理由看2），然后最后一个 `else`是当 `top[mid]==poker`才会执行的程序，此时这张重复的牌会放在重复的牌堆顶位置上，因此牌面最后还是可以找到一个牌堆进行放置。因此如果一个牌面没有可以放置的牌堆顶的话，那么流程一定会执行中间那条语句，我们来看一下循环终止的条件 `left==right`而 `right==piles`，因此，如果 `left==piles`的话，那么就没有可以放置的牌堆顶。



## 扩展到二维

俄罗斯套娃信封问题，[力扣354题](https://leetcode.cn/problems/russian-doll-envelopes/)，困难

![image-20230711232109413](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202307112321470.png)

首先，我们来分析一下这道题，这道题目其实是最长递增子序列的变种，因为每次合法的嵌套都是大的嵌套小的，相当于在二维平面找一个最长递增子序列，其长度就是最多能嵌套的信封个数。

或许我们会想到有面积法求解，但是这个解法是不行的，因为 `1 x 10`大于 `3 x 3`，但是并不满足条件

这道题的巧妙之处就是：

**先对宽度进行升序排序，如果遇到 `w`相同的情况，则按照高度 `h`降序排序；之后把所有的 `h`作为一个数组，在这个数组上计算 `LIS`的长度就是答案。**

画一个图理解一下：

![img](https://labuladong.github.io/algo/images/信封嵌套/1.jpg)

然后在 `h`上寻找最长递增子序列，这个子序列就是最优的嵌套方案：

![img](https://labuladong.github.io/algo/images/信封嵌套/2.jpg)

那么为什么这样就能找到可以相互嵌套的信封序列呢？

首先，对宽度 `w`从小到大排序，确保了 `w`这个维度可以相互嵌套的，所以我们只需要专注于 `h`这个维度可以进行嵌套即可。

其次，两个 `w`相同的信封不能相互包含，所以对于宽度 `w`相同的信封，对高度 `h`进行降序处理，可以保证二维`LIS`中不存在多个相同的宽度 `w`的信封。因为题目中也规定了长宽相同也是无法进行嵌套的。

解法代码：

```java
public int maxEnvelopes(int[][] envelopes) {
    // 先排序
    // 将宽度进行升序，如果宽度一样，将高度降序
    Arrays.sort(envelopes, new Comparator<int[]>()
                {
                    public int compare(int[] a, int[] b){
                        return a[0] - b[0]==0? b[1]-a[1]: a[0]-b[0];
                    }
                });
    // 对高度进行LIS
    int[] height = new int[envelopes.length];
    for(int i=0; i<envelopes.length; i++)
        height[i] = envelopes[i][1];
    return lengthOfLIS(height);
}

public int lengthOfLIS(int[] nums){
    // 使用二分搜索提高搜索效率
    int piles = 0;// 分的牌堆数
    int n = nums.length;
    // 牌堆顶的牌
    int[] top = new int[n];

    for(int i=0; i<n; i++){
        int poker = nums[i];
        int left = 0, right = piles;
        while(left < right){
            int mid = left + (right - left)/2;
            if(top[mid] > poker)
                right = mid;
            else if(top[mid] < poker)
                left = mid + 1;
            else
                right = mid;
        }

        if(left == piles)piles++;
        top[left] = poker;
    }
    return piles;
}
```

由于力扣官方增加了测试用例，这里必须使用二分搜索版的 `lengthOfLIS` 函数才能通过所有测试用例。这样的话算法的时间复杂度为 `O(NlogN)`，因为排序和计算 `LIS` 各需要 `O(NlogN)` 的时间，加到一起还是 `O(NlogN)`；空间复杂度为 `O(N)`，因为计算 `LIS` 的函数中需要一个 `top` 数组。