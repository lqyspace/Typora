# 最大子数组和

[力扣53](https://leetcode.cn/problems/maximum-subarray/)，难度中等

![image-20230711234925436](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202307112349492.png)

## 滑动窗口解法

使用滑动窗口解题，**当滑动窗口的数字和大于等于0时，扩大窗口。当滑动窗口内的数字和小于0时，缩小滑动窗口。在每次移动窗口的时候更新答案。**

```java
public int maxSubArray(int[] nums) {
    int res = Integer.MIN_VALUE;
    int left = 0, right = 0;
    int sum = 0;
    while(right < nums.length){
        int cur = nums[right++];
        sum += cur;
        res = Math.max(res, sum);

        while(sum<0){
            sum -= nums[left++];
        }
    }
    return res;
}
```

有一个地方需要注意一下：那就是 `res=Math.max(res, sum)`的位置，得放在内层 `while`的前面。假设一种情况，如果数组里面全是负数的话，那么会因为 `res=Math.max(res, sum)`在内层 `while`的后面，因此 `res`的值会一直都是0，所以是不对的，应该放在内层 `while`的前面。

首先讨论一种特殊情况，就是 `nums` 中全是负数的时候，此时算法是可以得到正确答案的。

如果 `nums`中有正有负，这种情况下元素和最大的子数组一定是以正数开头的（因为以负数开头的话，把这个负数去掉，就可以得到最大的子数组和，所以与假设矛盾）。那么此时我们需要穷举所有以正数开头的子数组，计算他们的元素和，找到元素和最大的那个子数组。

说到这里，解法代码的逻辑应该就清晰了。算法只有在窗口元素和大于 0 时才会不断扩大窗口，并且在扩大窗口时更新答案，这其实就是在穷举所有正数开头的子数组，寻找子数组和最大的那个，所以这段代码能够得到正确的结果。

```java
public int maxSubArray(int[] nums) {
    int[] dp = new int[nums.length];// 表示以nums[i]结尾的数字的连续子数组和
    dp[0] = nums[0];
    int res = dp[0];
    for(int i=0; i<nums.length; i++){
        dp[i] = Math.max(nums[i], nums[i]+dp[i-1]);
        res = Math.max(res, dp[i]);
    }
    
}
```



## 动态规划解法

**`dp[i]`表示以数字`nums[i]`结尾的 最大子数组的和。**

依然使用数学归纳法来找状态转移方程：假设我们已经知道了 `dp[i-1]`，那么如何推导出 `dp[i]`呢？

可以做的选择有两个，要么与前面的相邻子数组连接，形成一个和更大的子数组：要么不与前面的子数组连接，自成一派，自己作为一个字数组。

```java
public int maxSubArray(int[] nums) {
    int n = nums.length;
    int[] dp = new int[n];
    int res = Integer.MIN_VALUE;
    dp[0] = nums[0];
    for(int i=1;i<n; i++){
        dp[i] = Math.max(nums[i], dp[i-1] + nums[i]);
    }
    for(int i=0; i<n; i++){
        res = Math.max(res, dp[i]);
    }
    return res;
}
```

以上的解法的时间复杂度是 `O(N)`，空间复杂度也是 `O(N)`。不过注意到空间复杂度还可以继续优化：

```java
public int maxSubArray(int[] nums) {
    int n = nums.length;
    int dp = nums[0];
    int res = dp;
    for(int i=1; i<n; i++){
        dp = Math.max(nums[i], dp+nums[i]);
        res = Math.max(res, dp);
    }
    return res;
}
```



## 前缀和思路

在动态规划的思路中，我们使用状态转移方程推导出 `nums[i]`结尾的最大子数组的和。

其实这道题也可以使用 **前缀和**的思路进行求解：以 `nums[i]`为结尾的最大子数组的和是多少，反过来想，也就是在前缀和中，用 `preSum[i+1]-min(preSum[0...i])`。

所以，我们可以利用前缀和数组计算以每个元素结尾的子数组之和，进而得到最大的子数组：

```java
int maxSubArray(int[] nums){
    int n = nums.length;
    int res = Integer.MIN_VALUE;
    int local_min = Integer.MAX_VALUE;
    int[] preSum = new int[n+1];
    for(int i=1; i<=n; i++){
        preSum[i] = preSum[i-1] + nums[i-1];
    }
    for(int i=0; i<n; i++){
        local_min = Math.min(local_min, preSum[i]);
        res = Math.max(res, preSum[i+1]-local_min);
    }
    return res;
}
```

至此，前缀和解法也完成了。

简单总结下动态规划解法吧，虽然说状态转移方程确实有点玄学，但大部分还是有些规律可循的，跑不出那几个套路。像子数组、子序列这类问题，你就可以尝试定义 `dp[i]` 是以 `nums[i]` 为结尾的最大子数组和/最长递增子序列，因为这样定义更容易将 `dp[i+1]` 和 `dp[i]` 建立起联系，利用数学归纳法写出状态转移方程。

























