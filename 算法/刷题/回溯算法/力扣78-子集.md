# 子集

[力扣78 子集](https://leetcode.cn/problems/subsets/)，难度中等

![image-20230716135030180](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202307161350223.png)

这道题有若干种解法，接下来讲介绍各种解法：



## 回溯算法

首先，生成元素个数为0的子集，那么就只有空集 `[]`，为了方便表示，我们使用 `S_0`。

然后，在 `S_0`的基础上生成元素个数为1的子集，我们称之为 `S_1`。

![img](https://labuladong.github.io/algo/images/排列组合/3.jpeg)

接下来，以此类推，我们最终可以建立如下图的一棵树

![img](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202307161355807.jpeg)

由于本题不考虑顺序对集合的影响，因此 `[1,2]`和 `[2,1]`的效果是一样的。

如果把根节点作为第0层，第一层作为元素个数为1的节点，那么第 `n` 层的所有节点就是大小为 `n` 的所有子集。

我们想要得到所有的子集，那么遍历这棵树即可。

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> subsets(int[] nums) {
		List<Integer> path = new ArrayList<>();
        backtrack(nums, path, 0);
        return res;
    }
    
    public void backtrack(int[] nums, List<Integer> path, int start){
        // 前序操作，每一个节点的值都是一个子集
        res.add(new ArrayList<>(path));
        
        for(int i=start; i<nums.length; i++){// 用start进行控制，避免重复添加元素
            // 做选择
            path.add(nums[i]);
            // 执行操作,遍历下一个位置的节点
            backtrack(nums, path, i+1);
            // 撤销选择
            path.remove(path.size()-1);
        }
    }
}
```



## 二进制位求解

记原来序列中元素的总和是 n，原序列中的数字 $a_i$ 的状态只有两个可能，即 **在子集中** 和 **不在子集中**。我们使用 1 表示 **在子集中**，使用 0 表示 **不在子集中**，那么每一个子集可以对应一个长度为 n 的 0,1序列。例如，在本题中，子集 12就表示为 110，子集13就表示为101，空集就表示为000。

可以发现`0/1`序列对应的二进制数正好从0到$2^n-1$。我们可以枚举$mask\in [0, 2^n-1]$，mask的二进制表示一个 `0/1`序列，我们可以按照 `0/1`序列在原集合当中取数，当我们遍历完所有的 $2^n$个mask，我们也就能构造出所有的子集。

```java
class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        List<Integer> tmp = new ArrayList<>();
        int n = nums.length;
        for(int mask=0; mask<(1<<n); mask++){// 左移 i 位
            tmp.clear();
            for(int i=0; i<n; i++){
                if((mask & (1<<i)) != 0)// mask 与 1<<i 进行与操作，目的是看 mask的第i位是否是1，是的话就添加进tmp列表里
                    tmp.add(nums[i]);
            }
            res.add(new ArrayList<>(tmp));
        }
        return res;
    }
}
```

时间复杂度：$O(n\times 2^n)$，空间复杂度：$O(n)$





## 逐个枚举

逐个枚举，空集的幂集只有空集，每增加一个元素，让之前的幂集中的每一个子集都追加这个元素，这就是新增的子集。

```java
// 迭代枚举
class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        // 添加空集合
        res.add(new ArrayList<>());
        // 添加新元素
        for(int i=0; i<nums.length; i++){
            // 获取当前res的元素的个数
            int size = res.size();
            for(int j=0; j<size; j++){
                List<Integer> tmp = new ArrayList<>(res.get(j));
                tmp.add(nums[i]);
                res.add(tmp);
            }
        }
        return res;
    }
}




// 递归枚举
class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        return dfs(nums, 0);
    }
    
    public List<List<Integer>> dfs(int[] nums, int i){
        if(i==nums.length){
            List<List<Integer>> h = new ArrayList<>();
            h.add(new ArrayList<Integer>());
            return h;
        }
        List<List<Integer>> ans = dfs(nums, i+1);
        int size = ans.size();
        for(int j=0; j<size; j++){
            List<Integer> tmp = new ArrayList<>(ans.get(i));
            tmp.add(nums[i]);
            ans.add(tmp);
        }
        return new ArrayList<>(ans);
    }
}

// 递归枚举
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> subsets(int[] nums) {
        res.add(new ArrayList<>());
        dfs(nums, 0);
        return res;
    }
    
    public void dfs(int[] nums, int i){
        if(i>=nums.length)
            return;
        int size = res.size();
        for(int j=0; j<size(); j++){
            List<Integer> tmp = new ArrayList<>(res.get(j));
            tmp.add(nums[i]);
            res.add(tmp);
        }
        dfs(nums, i+1);
    }
}
```





















