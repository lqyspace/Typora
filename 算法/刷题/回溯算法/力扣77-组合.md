# 组合

[组合，力扣77题](https://leetcode.cn/problems/combinations/)，难度中等

![image-20230717112744916](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202307171127025.png)

## 回溯

首先，使用回溯算法求解：

```java
class Solution {
    List<List<Integer>> res = new LinkedList<>();
    int k = 0;
    public List<List<Integer>> combine(int n, int k) {
		List<Integer> track = new LinkedList<>();
        this.k = k;
        backtrack(n, 1, track);
        return res;
    }
    
    public void backtrack(int num, int start, List<Integer> track){
        if(track.size()==this.k){
            res.add(new LinkedList<>(track));
            return;
        }
        if(start == num+1){
            return;
        }
        
        for(int i=start; i<=num; i++){
            // 做选择
            track.add(i);
            backtrack(num, i+1, track);
            // 撤销选择
            track.remove(track.size()-1);
        }
    }
}
```

时间复杂度：$O(n^2)$

空间复杂度：$O(n)$

## 二进制求解

```java
class Solution {
    public List<List<Integer>> combine(int n, int k) {
		List<List<Integer>> res = new LinkedList<>();
        List<Integer> track = new LinkedList<>();
        for(int mask=0; mask<(1<<n); mask++){
            track.clear();
            for(int i=0; i<n; i++){
                if((mask & (1<<i))!=0)
                    track.add(i+1);
            }
            // 你得把这个if语句写在外面，写在内层循环是不对的
            // 因为这个内层循环是为了统计mask二进制数字里有几个1
            // 比如1011这个二进制，虽然1的个数大于2，但是也不能在内层循环里判断
            if(track.size()==k){
                res.add(new LinkedList<>(track));
            }
        }
        return res;
    }
}
```

时间复杂度：$O(n\times 2^n)$

空间复杂度：$O(n)$

## 逐个枚举

```java
// 迭代枚举
// 每增加一个新元素，就往以前的元素里面添加这个新元素，然后重新添加回res中
// 这个代码对于这道题有点超时，但仍然是一个好算法
class Solution {
    public List<List<Integer>> combine(int n, int k) {
		List<List<Integer>> res = new LinkedList<>();
        List<List<Integer>> ans = new LinkedList<>();
        res.add(new LinkedList<>());
        for(int i=1; i<=n; i++){
            int size = res.size();
            for(int j=0; j<size; j++){
                List<Integer> tmp = new LinkedList<>(res.get(j));
                tmp.add(i);
                if(tmp.size()==k){
                    ans.add(tmp);
                }
                res.add(tmp);
            }
        }
        return res;
    }
}
时间复杂度：O(2^n)

    
// 递归迭代
// 超时，但是这个方法不错
class Solution {
    List<List<Integer>> res = new LinkedList<>();
    List<List<Integer>> ans = new LinkedList<>();
    public List<List<Integer>> combine(int n, int k) {
        res.add(new LinkedList<>());
		dfs(n, k, 1);
        return ans;
    }
    
    public void dfs(int n, int k, int index){
        if(index>=n+1)
            return;
        
        int size = res.size();
        for(int i=0; i<size; i++){
            List<Integer> tmp = new LinkedList<>(res.get(i));
            tmp.add(index);
            res.add(tmp);
            if(tmp.size()==k)
                ans.add(tmp);
        }
        dfs(n, k, index+1);
    }
}

时间复杂度：O(2^n)

// 递归迭代
// 超时，但是这个方法不错
class Solution {
    List<List<Integer>> ans = new LinkedList<>();
    public List<List<Integer>> combine(int n, int k) {
		dfs(n, k, 1);
        return ans;
    }
    
    public List<List<Integer>> dfs(int n, int k, int index){
        if(index>=n+1){
            List<List<Integer>> t = new LinkedList<>();
            t.add(new LinkedList<>());
            return t;
        }
            
        List<List<Integer>> tt = dfs(n, k, index+1);
        
        int size = tt.size();
        for(int i=0; i<size; i++){
            List<Integer> tmp = new LinkedList<>(tt.get(i));
            tmp.add(index);
            tt.add(tmp);
            if(tmp.size()==k)
                ans.add(tmp);
        }
        return new LinkedList<>(tt);
    }
}
```

