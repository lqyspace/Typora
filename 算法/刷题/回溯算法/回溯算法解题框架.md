# 回溯算法解题框架

## 框架

回溯算法和`DFS`算法非常类似，本质上就是一种暴力穷举算法。

回溯算法和`DFS`的细微差别是：回溯算法实在遍历 **树枝**，`DFS`算法实在遍历 **节点**。

解决一个回溯问题，实际上就是一个决策树遍历过程，站在回溯树的一个节点上，你只需要思考3个问题：

1、路径：也就是已经做出的选择。

2、选择列表：也就是你当前可以做的选择。

3、结束条件：也就是到达决策树底层，无法再做选择的条件。

回溯算法的框架：

```python
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return
    
    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```

**其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」**，特别简单。

下面我们就通过「全排列」这个问题来解开之前的疑惑，详细探究一下其中的奥妙！



## 全排列问题

力扣第 46 题「[全排列](https://leetcode.cn/problems/permutations/)」就是给你输入一个数组 `nums`，让你返回这些数字的全排列。

![image-20230715105152885](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202307151051930.png)

我们在高中的时候就做过排列组合的数学题，我们也知道 `n` 个不重复的数，全排列共有 `n!` 个。那么我们当时是怎么穷举全排列的呢？

比方说给三个数 `[1,2,3]`，你肯定不会无规律地乱穷举，一般是这样：

先固定第一位为 1，然后第二位可以是 2，那么第三位只能是 3；然后可以把第二位变成 3，第三位就只能是 2 了；然后就只能变化第一位，变成 2，然后再穷举后两位……

其实这就是回溯算法，我们高中无师自通就会用，或者有的同学直接画出如下这棵回溯树：

![img](https://labuladong.github.io/algo/images/backtracking/1.jpg)

只要从根遍历这棵树，记录路径上的数字，其实就是所有的全排列。**我们不妨把这棵树称为回溯算法的「决策树」**。

**为啥说这是决策树呢，因为你在每个节点上其实都在做决策**。比如说你站在下图的红色节点上：

![img](https://labuladong.github.io/algo/images/backtracking/2.jpg)

你现在就在做决策，可以选择 1 那条树枝，也可以选择 3 那条树枝。为啥只能在 1 和 3 之中选择呢？因为 2 这个树枝在你身后，这个选择你之前做过了，而全排列是不允许重复使用数字的。

**现在可以解答开头的几个名词：`[2]` 就是「路径」，记录你已经做过的选择；`[1,3]` 就是「选择列表」，表示你当前可以做出的选择；「结束条件」就是遍历到树的底层叶子节点，这里也就是选择列表为空的时候**。

如果明白了这几个名词，可以把「路径」和「选择」列表作为决策树上每个节点的属性，比如下图列出了几个蓝色节点的属性：

![img](https://labuladong.github.io/algo/images/backtracking/3.jpg)

**我们定义的 `backtrack` 函数其实就像一个指针，在这棵树上游走，同时要正确维护每个节点的属性，每当走到树的底层叶子节点，其「路径」就是一个全排列**。

再进一步，如何遍历一棵树？这个应该不难吧。回忆一下之前 [学习数据结构的框架思维](https://labuladong.github.io/algo/di-ling-zh-bfe1b/xue-xi-sua-01220/) 写过，各种搜索问题其实都是树的遍历问题，而多叉树的遍历框架就是这样：

```java
void traverse(TreeNode root) {
    for (TreeNode child : root.childern) {
        // 前序位置需要的操作
        traverse(child);
        // 后序位置需要的操作
    }
}
```

> Info
>
> 细心的读者肯定会疑问：多叉树 `DFS` 遍历框架的前序位置和后序位置应该在 for 循环外面，并不应该是在 for 循环里面呀？为什么在回溯算法中跑到 for 循环里面了？
>
> 是的，`DFS` 算法的前序和后序位置应该在 for 循环外面，不过回溯算法和 `DFS` 算法略有不同，后文 [图论算法基础](https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-03a72/tu-lun-ji--d55b2/) 会详细对比，这里可以暂且忽略这个问题

而所谓的前序遍历和后序遍历，他们只是两个很有用的时间点，我给你画张图你就明白了：

![img](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202307151038862.jpeg)

**前序遍历的代码在进入某一个节点之前的那个时间点执行，后序遍历代码在离开某个节点之后的那个时间点执行**。

回想我们刚才说的，「路径」和「选择」是每个节点的属性，函数在树上游走要正确处理节点的属性，那么就要在这两个特殊时间点搞点动作：

![img](https://labuladong.github.io/algo/images/backtracking/5.jpg)

现在，你是否理解了回溯算法的这段核心框架？



```python
for 选择 in 选择列表:
    # 做选择
    将该选择从选择列表移除
    路径.add(选择)
    backtrack(路径, 选择列表)
    # 撤销选择
    路径.remove(选择)
    将该选择再加入选择列表
```

**我们只要在递归之前做出选择，在递归之后撤销刚才的选择**，就能正确得到每个节点的选择列表和路径。

下面，看全排列的代码：

```java
class Solution {
    List<List<Integer>> res = new LinkedList<>();
    public List<List<Integer>> permute(int[] nums) {
		List<Integer> path = new LinkedList<>();
        boolean[] used = new boolean[nums.length];
        backTrack(nums, path, used);
        return res;
    }
    
    public void backTrack(int[] nums, LinkedList<Integer> path, boolean[] used){
        if(path.size()==nums.length){
            res.add(new LinkedList(path));
            return;
        }
            
        for(int i=0; i<nums.length; i++){
            if(used[i])
                continue;
            path.add(nums[i]);
            used[i] = true;
            backTrack(nums, path, used);
            path.remove(path.size()-1);
            used[i] = false;
        }
    }
}
```



下面我们来看看有 `DFS`写的代码的问题：

```java
class Solution {
    List<List<Integer>> res = new LinkedList<>();
    public List<List<Integer>> permute(int[] nums) {
		LinkedList<Integer> path = new LinkedList<>();
        boolean[] used = new boolean[nums.length];
        backTrack(nums, path, used, 0);
        return res;
    }
    
    public void backTrack(int[] nums, List<Integer> path, boolean[] used, int j){
        path.add(nums[j]);
        used[j] = true;
        if(path.size()==nums.length){
            res.add(new LinkedList(path));
            path.remove(path.size()-1);
            used[j] = false;
            return;
        }
        for(int i=0; i<nums.length; i++){
            if(used[i])
                continue;
            backTrack(nums, path, used, i);
        }
        path.remove(path.size()-1);
        used[j] = false;
    }
}
```

这个代码是典型的的 `DFS`的代码，乍一看这个代码是没有问题的，但是细细揣摩便能发现端倪。

这个代码的错误便是：**不能输出全排列的所有情况**，这是为什么呢？

因为这个代码在 `permute` 函数里面已经传入了一个从 0 号开始的数组，因此得到的排列也只是从 0 号位数字开始的排列，所以排列的情况也只有 [[1,2,3], [1,3,2]]这两种，因此此代码还缺少对起始位的遍历，所以还需要在 `permute` 函数里对 `backTrack`进行遍历，但是这又与 `backTrack`本身的代码存在冗余，对该代码进行改进的话最终也会改成回溯算法的样子，因此 `DFS`解题不妥，还是乖乖使用 **回溯算法**。

==**重点！！！对于全排列问题，首选回溯算法！！！！**==

==**重点！！！对于全排列问题，首选回溯算法！！！！**==

==**重点！！！对于全排列问题，首选回溯算法！！！！**==





## N皇后问题

力扣第 51 题「[N 皇后](https://leetcode.cn/problems/n-queens/)」就是这个经典问题，简单解释一下：给你一个 `N×N` 的棋盘，让你放置 `N` 个皇后，使得它们不能互相攻击，请你计算出所有可能的放法。函数签名如下

![image-20230715114633425](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202307151146497.png)

```java
List<List<String>> solveNQueens(int n);
```

**皇后可以攻击同一行、同一列、左上左下右上右下四个方向的任意单位。**

比如如果给你输入 `N = 4`，那么你就要在 `4x4` 的棋盘上放置 4 个皇后，返回以下结果（用 `.` 代表空棋盘，`Q` 代表皇后）：



```bash
[
    [".Q..","...Q","Q...","..Q."],
    ["..Q.","Q...","...Q",".Q.."]
]
```

![img](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202307151151760.jpeg)

这个问题本质上跟全排列问题差不多，**决策树的每一层表示棋盘上的每一行**；**每个节点可以做出的选择是，在该行的任意一列放置一个皇后。**

**这里纠正一下思路：**

你不要使用上一行皇后的位置去判断下一行皇后应该放在哪儿，如果你这样做的话，是错误的，因为即使对于上一行的皇后满足要求的位置，也不一定对上面所有行的皇后的位置都满足要求。所有你需要保证对于上面所有行都满足要求的情况下，才能判断该行哪些位置是可行的位置。这个思路实现起来过于复杂。

所以 **你完全可以直接在下一行的每一个位置进行遍历，如果该位置不适合放皇后，直接遍历下一个节点便是，这样就能直接判断该行该位置是否可以放皇后。**

因此 **在判断的时候只需要判断该位置的上面（正上，左上，右上）即可，下面不用判断，因为下面没有皇后。**

代码如果：

```java
class Solution {
    List<List<String>> res = new ArrayList<>();
    public List<List<String>> solveNQueens(int n) {
		List<String> board = new ArrayList<>();
        // '.'表示空, 'Q'表示皇后，初始化空棋盘
        for(int i=0; i<n; i++){
            StringBuilder sb = new StringBuilder();
            for(int j=0; j<n; j++)
                sb.append('.');
            board.add(sb.toString());
        }
        
        backTrack(board, 0);// 从第0行开始
        return res;
    }
    
    public void backTrack(List<String> board, int row){
        if(row==board.size()){
            res.add(new ArrayList(board));
            return;
        }
            
        for(int col = 0; col < board.get(0).length(); col++){
            if(!isValid(board, row, col))
                continue;
            
            // 开始放皇后
            StringBuilder sb = new StringBuilder(board.get(row));
            sb.setCharAt(col, 'Q');
            board.set(row, sb.toString());
            
            backTrack(board, row+1);
            
            // 撤销选择
            sb.setCharAt(col, '.');
            board.set(row, sb.toString());
        }
    }
    
    // 判断位置是否满足要求
    public boolean isValid(List<String> board, int row, int col){
        // 判断正上方是否满足
        for(int i = row-1; i>=0; i--)
            if(board.get(i).charAt(col)=='Q')
                return false;
        
        // 判断左上是否满足要求
        for(int i=row-1, j=col-1; i>=0 && j>=0; i--, j--)
            if(board.get(i).charAt(j)=='Q')
                return false;
        
        // 判断右上是否满足
        for(int i=row-1, j=col+1; i>=0 && j<board.get(0).length(); i--, j++)
            if(board.get(i).charAt(j)=='Q')
                return false;
        
        return true;
    }
}
```

> Info
>
> 肯定有读者问，按照 N 皇后问题的描述，我们为什么不检查左下角，右下角和下方的格子，只检查了左上角，右上角和上方的格子呢？
>
> 因为皇后是一行一行从上往下放的，所以左下方，右下方和正下方不用检查（还没放皇后）；因为一行只会放一个皇后，所以每行不用检查。也就是最后只用检查上面，左上，右上三个方向。

函数 `backtrack` 依然像个在决策树上游走的指针，通过 `row` 和 `col` 就可以表示函数遍历到的位置，通过 `isValid` 函数可以将不符合条件的情况剪枝：

![img](https://labuladong.github.io/algo/images/backtracking/7.jpg)

这个问题的复杂度确实非常高，粗略估算一下：

`N` 行棋盘中，第一行有 `N` 个位置可能可以放皇后，第二行有 `N - 1` 个位置，第三行有 `N - 2` 个位置，以此类推，再叠加每次放皇后之前 `isValid` 函数所需的 O(N) 复杂度，所以总的时间复杂度上界是 O(N! * N)，而且没有什么明显的冗余计算可以优化效率。你可以试试 `N = 10` 的时候，计算就已经很耗时了。

当然，因为有 `isValid` 函数剪枝，并不会真的在每个位置都尝试放皇后，所以实际的执行效率会高一些。但正如后文 [算法时空复杂度分析实用指南](https://labuladong.github.io/algo/di-ling-zh-bfe1b/suan-fa-sh-05f25/) 所说，这个时间复杂度作为上界是没问题的。

**有的时候，如果我们并不想得到所有合法的答案，只想要一个答案，怎么办呢**？比如解数独的算法，找所有解法复杂度太高，只要找到一种解法就可以。

其实特别简单，只要稍微修改一下回溯算法的代码，用一个外部变量记录是否找到答案，找到答案后就停止继续递归即可：

```java
class Solution {
    List<List<String>> res = new ArrayList<>();
    boolean fund = false;
    public List<List<String>> solveNQueens(int n) {
		List<String> board = new ArrayList<>();
        // '.'表示空, 'Q'表示皇后，初始化空棋盘
        for(int i=0; i<n; i++){
            StringBuilder sb = new StringBuilder();
            for(int j=0; j<n; j++)
                sb.append('.');
            board.add(sb.toString());
        }
        
        backTrack(board, 0);// 从第0行开始
        return res;
    }
    
    public void backTrack(List<String> board, int row){
        if(fund)
            return;
        
        if(row==board.size()){
            res.add(new ArrayList(board));
            fund = true;
            return;
        }
            
        for(int col = 0; col < board.get(0).length(); col++){
            if(!isValid(board, row, col))
                continue;
            
            // 开始放皇后
            StringBuilder sb = new StringBuilder(board.get(row));
            sb.setCharAt(col, 'Q');
            board.set(row, sb.toString());
            
            backTrack(board, row+1);
            
            // 撤销选择
            sb.setCharAt(col, '.');
            board.set(row, sb.toString());
        }
    }
    
    // 判断位置是否满足要求
    public boolean isValid(List<String> board, int row, int col){
        // 判断正上方是否满足
        for(int i = row-1; i>=0; i--)
            if(board.get(i).charAt(col)=='Q')
                return false;
        
        // 判断左上是否满足要求
        for(int i=row-1, j=col-1; i>=0 && j>=0; i--, j--)
            if(board.get(i).charAt(j)=='Q')
                return false;
        
        // 判断右上是否满足
        for(int i=row-1, j=col+1; i>=0 && j<board.get(0).length(); i--, j++)
            if(board.get(i).charAt(j)=='Q')
                return false;
        
        return true;
    }
}
```

这样修改后，只要找到一个答案，后续的递归穷举都会被阻断。也许你可以在 N 皇后问题的代码框架上，稍加修改，写一个解数独的算法？可以参考我的这篇文章 [回溯算法秒杀数独问题](https://labuladong.github.io/algo/di-san-zha-24031/bao-li-sou-96f79/hui-su-sua-9e939/)。

再简单拓展一下，有可能题目不需要你计算出 N 皇后问题的所有具体结果，而仅仅问你共有几种解法，应该怎么做呢？

比如力扣第 52 题「[N 皇后 II](https://leetcode.cn/problems/n-queens-ii/)」：



## N皇后II

给你一个整数 `n`，返回 `n` 皇后问题不同的解决方案的数量。比如输入 `n = 4`，你的算法返回 2，因为 4x4 的棋盘只有两种可行的解决方案。

![img](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202307151151760.jpeg)

其实你把我们上面写的解法 copy 过去也可以解决这个问题，因为我们计算出来的 `res` 就存储了所有合法的棋盘嘛，那么 `res` 中元素的个数不就是所有可行解法的总数吗？

是这样的，但要知道创建和存储这些具体的棋盘解法是要消耗空间和时间的，所以效率上可能会差一些。

更好的办法就是直接把 `res` 变量变成 int 类型，每次在 base case 找到一个合法答案的时候递增 `res` 变量即可：

```java
// 仅仅记录合法结果的数量
int res = 0;

void backtrack(List<String> board, int row) {
    if (row == board.size()) {
        // 找到一个合法结果
        res++;
        return;
    }

    // 其他都一样
}
```



## 最后总结

回溯算法就是个多叉树的遍历问题，关键就是在前序遍历和后序遍历的位置做一些操作，算法框架如下：



```python
def backtrack(...):
    for 选择 in 选择列表:
        做选择
        backtrack(...)
        撤销选择
```

**写 `backtrack` 函数时，需要维护走过的「路径」和当前可以做的「选择列表」，当触发「结束条件」时，将「路径」记入结果集**。

其实想想看，回溯算法和动态规划是不是有点像呢？我们在动态规划系列文章中多次强调，动态规划的三个需要明确的点就是「状态」「选择」和「base case」，是不是就对应着走过的「路径」，当前的「选择列表」和「结束条件」？

动态规划和回溯算法底层都把问题抽象成了树的结构，但这两种算法在思路上是完全不同的。在 [东哥带你刷二叉树（纲领篇）](https://labuladong.github.io/algo/di-ling-zh-bfe1b/dong-ge-da-334dd/) 你将看到动态规划和回溯算法更深层次的区别和联系。