# 路径总和

[力扣112](https://leetcode.cn/problems/path-sum/)，难度简单

![image-20230715150144064](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202307151501123.png)

首先使用回溯算法来解：

运用了回溯算法模板，这里不做解释。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    boolean fund = false;
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if(root == null) return false;
        backtrack(root, 0, targetSum);
        return fund;
    }

    public void backtrack(TreeNode root, int path, int targetSum){
        if(root==null)
            return;
        path += root.val;

        if(path == targetSum && root.left==null && root.right==null){
            fund = true;
            return;
        }
        
        backtrack(root.left, path, targetSum);
        backtrack(root.right, path, targetSum);

        path -= root.val;
    }
}
```



接下来使用 `DFS`求解：

这个`DFS`的方式真是巧妙，只要树中存在一个点满足条件就会立即返回。

该题的思路是对`targetSum`进行间操作，每一遍历一个点减去该点的值，减到一个节点的左右子树都为空的时候，且该点的值恰好等于 `targetSum`，则求解成功。

```java
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if(root == null) return false;
        if(root.left == null && root.right==null)
            return root.val==targetSum;

        return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);
    }
}
```



接下来使用 `BFS`求解：

使用对列保存遍历到的每个节点以及该节点的路径和。如果该节点恰好是叶子结点，并且路径和正好等于`targetSum`，则说明找到了解。

```java
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        Deque<TNode> pth = new LinkedList<>();
        TNode tn = new TNode(root.val, root);
        pth.add(tn);
        while(!pth.isEmpty()){
            TNode tcur = pth.pollFirst();
            TreeNode cur = tcur.root;
            int path = tcur.path;
            if(cur.left==null && cur.right==null && path == targetSum)
                return true;
            if(cur.left!=null)
                pth.add(new TNode(path+cur.left.var, cur.left));
            if(cur.right!=null)
                pth.add(new TNode(path+cur.right.var, cur.right));
        }
        return false;
    }
}

class TNode{
    int path;
    TreeNode root;
    public TNode(){};
    TNode(int path){
        this.path = path;
    }
    TNode(int path, TreeNode root){
        this.path = path;
        this.root = root;
    }
}
```



使用 栈 求解：

使用栈求解与 `BFS`有所不同，使用栈求解会导致：先把根的右子树的所有节点访问完毕了以后，才回去访问左子树，代码的思路依旧是遍历树中的所有节点，如果存在，则一定可以找到一个值为`targetSum`。

为什么这段代码可行呢：因为栈中同时保存了（节点，路径和），也就是说只要能把所有的节点访问一遍，那么就一定能找到正确的结果。

无论使用栈还是对列，都是树的一种遍历方式而已。

```java
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if(root==null) return false;

        Deque<TNode> pth = new LinkedList<>();
        TNode tn = new TNode(root.val, root);
        pth.add(tn);
        while(!pth.isEmpty()){
            TNode tcur = pth.pollLast();
            TreeNode cur = tcur.root;
            int path = tcur.path;
            if(cur.left==null && cur.right==null && path == targetSum)
                return true;
            if(cur.left!=null)
                pth.addLast(new TNode(path+cur.left.val, cur.left));
            if(cur.right!=null)
                pth.addLast(new TNode(path+cur.right.val, cur.right));
        }
        return false;
    }
}

class TNode{
    int path;
    TreeNode root;
    public TNode(){};
    TNode(int path){
        this.path = path;
    }
    TNode(int path, TreeNode root){
        this.path = path;
        this.root = root;
    }
}
```
