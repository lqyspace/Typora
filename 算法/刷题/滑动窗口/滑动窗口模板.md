# 滑动窗口

## 前言

简言之就是维护一个窗口，不断进行滑动，然后更新答案。

算法的大致逻辑如下：

```java
int left = 0, right = 0;

while (left < right && right < s.size()) {
    // 增大窗口
    window.add(s[right]);
    right++;
    
    while (window needs shrink) {
        // 缩小窗口
        window.remove(s[left]);
        left++;
    }
}
```

这个算法技巧的时间复杂度是 `O(n)`，比字符串暴力求解要高效的多。

由于在解决 **滑动窗口** 问题时，算法内部的各种细节容易出错，比如：如何向窗口中添加元素，如何缩小窗口，在窗口的哪个阶段更新结果等。即便明白了这些细节，也容易出bug，因此就需要提供一个滑动窗口的算法模板。

```java
/* 滑动窗口算法框架 */
void slidingWindow(String s) {
    // 用合适的数据结构记录窗口中的数据
    HashMap<Character, Integer> window = new HashMap<>();

    int left = 0, right = 0;
    while (right < s.length()) {
        // c 是将移入窗口的字符
        char c = s.charAt(right);
        window.put(c, window.getOrDefault(c, 0) + 1);
        // 增大窗口
        right++;
        // 进行窗口内数据的一系列更新
        ...

        /*** debug 输出的位置 ***/
        // 注意在最终的解法代码中不要 print
        // 因为 IO 操作很耗时，可能导致超时
        System.out.printf("window: [%d, %d)\n", left, right);
        /********************/

        // 判断左侧窗口是否要收缩
        while (left < right && window needs shrink) {
            // d 是将移出窗口的字符
            char d = s.charAt(left);
            window.put(d, window.get(d) - 1);
            // 缩小窗口
            left++;
            // 进行窗口内数据的一系列更新
            ...
        }
    }
}
```

其中，两处 `...` 的操作分别是扩大窗口和缩小窗口的更新操作，这两个操作是完全对称的。

另外，滑动窗口代码框架中有一个嵌套的 while 循环，但是算法的时间复杂度仍然是 `O(N)`，其中 `N`是输入字符串的/数组的长度。

> 之所以这么说，是因为指针 `left`，`right`不会回退（它们的值只增不减），所以字符串/数组中的每个元素都只会进入窗口一次，然后被移出窗口一次，不会出现有某些元素多次进入和移出窗口，所以算法的时间复杂度和字符串/数组的长度成正比。

另外，编写代码的时候需要注意，Java中的 Integer 和 String 这种包装类不能直接引用 `==`进行相等，而应该使用 `equals`方法。



## 最小覆盖子串

先来看看力扣第 76 题「 [最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)」难度 Hard：

![img](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306112102953.png)

就是说要在 `S`(source) 中找到包含 `T`(target) 中全部字母的一个子串，且这个子串一定是所有可能子串中最短的。

如果我们使用暴力解法，代码大概是这样的：

```java
for (int i = 0; i < s.size(); i++)
    for (int j = i + 1; j < s.size(); j++)
        if s[i:j] 包含 t 的所有字母:
            更新答案
```

思路很直接，但是显然，这个算法的复杂度肯定大于 O(N^2) 了，不好。



**滑动窗口算法的思路是这样**：

1、我们在字符串 `S` 中使用双指针中的左右指针技巧，初始化 `left = right = 0`，把索引**左闭右开**区间 `[left, right)` 称为一个「窗口」。

> 理论上你可以设计两端都开或者两端都闭的区间，但设计为左闭右开区间是最方便处理的。因为这样初始化 `left = right = 0` 时区间 `[0, 0)` 中没有元素，但只要让 `right` 向右移动（扩大）一位，区间 `[0, 1)` 就包含一个元素 `0` 了。如果你设置为两端都开的区间，那么让 `right` 向右移动一位后开区间 `(0, 1)` 仍然没有元素；如果你设置为两端都闭的区间，那么初始区间 `[0, 0]` 就包含了一个元素。这两种情况都会给边界处理带来不必要的麻烦。



2、我们先不断地增加 `right` 指针扩大窗口 `[left, right)`，直到窗口中的字符串符合要求（包含了 `T` 中的所有字符）。

3、此时，我们停止增加 `right`，转而不断增加 `left` 指针缩小窗口 `[left, right)`，直到窗口中的字符串不再符合要求（不包含 `T` 中的所有字符了）。同时，每次增加 `left`，我们都要更新一轮结果。

4、重复第 2 和第 3 步，直到 `right` 到达字符串 `S` 的尽头。

这个思路其实也不难，**第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解**，也就是最短的覆盖子串。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动，这就是「滑动窗口」这个名字的来历。

`needs` 和 `window` 相当于计数器，分别记录 `T` 中字符出现次数和「窗口」中的相应字符的出现次数。

```java
/**
 * 求字符串 s 中包含字符串 t 所有字符的最小子串
 * @param s 源字符串
 * @param t 给定字符串
 * @return 满足条件的最小子串
 */
public String minWindow(String s, String t) {
    // 用于记录需要的字符和窗口中的字符及其出现的次数
    Map<Character, Integer> need = new HashMap<>();
    Map<Character, Integer> window = new HashMap<>();
    // 统计 t 中各字符出现次数
    for (char c : t.toCharArray()) 
        need.put(c, need.getOrDefault(c, 0) + 1);

    int left = 0, right = 0;
    int valid = 0; // 窗口中满足需要的字符个数
    // 记录最小覆盖子串的起始索引及长度
    int start = 0, len = Integer.MAX_VALUE;
    while (right < s.length()) {
        // c 是将移入窗口的字符
        char c = s.charAt(right);
        // 扩大窗口
        right++;
        // 进行窗口内数据的一系列更新
        if (need.containsKey(c)) {
            window.put(c, window.getOrDefault(c, 0) + 1);
            if (window.get(c).equals(need.get(c)))
                valid++; // 只有当 window[c] 和 need[c] 对应的出现次数一致时，才能满足条件，valid 才能 +1
        }

        // 判断左侧窗口是否要收缩
        while (valid == need.size()) {
            // 更新最小覆盖子串
            if (right - left < len) {
                start = left;
                len = right - left;
            }
            // d 是将移出窗口的字符
            char d = s.charAt(left);
            // 缩小窗口
            left++;
            // 进行窗口内数据的一系列更新
            if (need.containsKey(d)) {
                if (window.get(d).equals(need.get(d)))
                    valid--; // 只有当 window[d] 内的出现次数和 need[d] 相等时，才能 -1
                window.put(d, window.get(d) - 1);
            }
        }
    }

    // 返回最小覆盖子串
    return len == Integer.MAX_VALUE ?
        "" : s.substring(start, start + len);
}
```

需要注意的是，当我们发现某个字符在 `window` 的数量满足了 `need` 的需要，就要更新 `valid`，表示有一个字符已经满足要求。而且，你能发现，两次对窗口内数据的更新操作是完全对称的。

当 `valid == need.size()` 时，说明 `T` 中所有字符已经被覆盖，已经得到一个可行的覆盖子串，现在应该开始收缩窗口了，以便得到「最小覆盖子串」。

移动 `left` 收缩窗口时，窗口内的字符都是可行解，所以应该在收缩窗口的阶段进行最小覆盖子串的更新，以便从可行解中找到长度最短的最终结果。



## 字符串排列

这是力扣第 567 题「 [字符串的排列](https://leetcode.cn/problems/permutation-in-string/)」，难度中等：

![img](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306112109383.png)

注意哦，输入的 `s1` 是可以包含重复字符的，所以这个题难度不小。

这种题目，是明显的滑动窗口算法，**相当给你一个 `S` 和一个 `T`，请问你 `S` 中是否存在一个子串，包含 `T` 中所有字符且不包含其他字符**？

```java
public boolean checkInclusion(String s1, String s2) {
    HashMap<Character, Integer> needs = new HashMap<>();
    HashMap<Character, Integer> window = new HashMap<>();

    for(char c: s1.toCharArray()){
        needs.put(c, needs.getOrDefault(c, 0)+1);
    }

    int left = 0, right = 0;
    int valid = 0; // 记录窗口内符合要求的字符个数
    while(right < s2.length()){
        char c = s2.charAt(right);
        right++;
        if(needs.containsKey(c)){
            window.put(c, window.getOrDefault(c, 0)+1);
            if(window.get(c).equals(needs.get(c))){
                valid++;
            }
        }

        while(valid == needs.size()){// 一定要保证字符串个数是相等的
            if(right-left==s1.length()){
                return true;// 如果在字符串个数相等的条件下，存在长度也一样，那直接返回true
            }
            char d = s2.charAt(left);
            left++;
            if(needs.containsKey(d)){
                if(window.get(d).equals(needs.get(d))){
                    valid--;
                }
                window.put(d, window.get(d)-1);
            }
        }
    }
    return false;
}
```



## 找所有字母异位词

这是力扣第 438 题「 [找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)」，难度中等：

![img](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306112133856.png)

**相当于，输入一个串 `S`，一个串 `T`，找到 `S` 中所有 `T` 的排列，返回它们的起始索引**。

```java
public List<Integer> findAnagrams(String s, String p) {
    List<Integer> res = new LinkedList<>();
    HashMap<Character, Integer> need = new HashMap<>();
    HashMap<Character, Integer> window = new HashMap<>();

    for(char c: p.toCharArray()){
        need.put(c, need.getOrDefault(c, 0)+1);
    }

    int left = 0, right = 0;
    int valid = 0;//记录窗口内符合要求的字符串的个数
    while(right < s.length()){
        char c = s.charAt(right);
        right++;
        if(need.containsKey(c)){
            window.put(c, window.getOrDefault(c, 0)+1);
            if(window.get(c).equals(need.get(c))){
                valid++;
            }
        }

        // 判断左窗口收缩
        while(valid == need.size()){
            if(right-left == p.length()){
                res.add(left);
            }

            char d = s.charAt(left);
            left++;
            if(need.containsKey(d)){
                if(window.get(d).equals(need.get(d))){
                    valid--;
                }
                window.put(d, window.get(d)-1);
            }
        }
    }
    return res;
}
```





## 最长无重复字串

这是力扣第 3 题「 [无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)」，难度中等：

![img](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306112159185.png)

```java
public int lengthOfLongestSubstring(String s) {
    if(s==null || s.length()==0) return 0;
    // 滑动窗口
    HashMap<Character, Integer> window = new HashMap<>();
    int left=0, right=0;
    int res = -1;
    while(right < s.length()){
        char c = s.charAt(right);
        right++;
        window.put(c, window.getOrDefault(c, 0)+1);

        while(window.get(c)>1 && left<right){// 说明存在重复节点
            // 开始缩小窗口
            char d = s.charAt(left);
            left++;
            window.put(d, window.get(d)-1);
        }
        res = Math.max(res, right - left);
    }
    return res;
}
```

这道题跟模板有点不一样，注意思考：

首先，滑动窗口在遍历每一个字符的时候，接下来都会进行一次判断，判断是否存在重复的字符，即大于1的情况。即一旦发现一个大于1的情况，就会被扼杀在摇篮里。

其次，需要注意的是，如何判断滑动窗口里不存在重复的字符串呢？即：截止到 `right`所指的字符，从左往右遍历，不断缩小窗口，直到窗口内不存在重复字符，此时便可以更新不重复子串的长度。

如果滑动窗口内本身就不存在重复字符，所以我们直接更新 `res`的值就可以了。

这个问题有点像 **以当前 `i`结尾的字符的 不重复子串的最大长度** 问题。

因此考虑使用 **动态规划+迭代** 的方式求解：

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        if(s == null) return 0;
        if(s.length() <=1) return s.length();
        int[] dp = new int[s.length()];
        dp[0] = 1;
        int max = -1;
        for(int i=1; i<s.length(); i++){
            // 获取子串
            String sub = s.substring(i-dp[i-1],i);
            int tmp = sub.lastIndexOf(String.valueOf(s.charAt(i)));
            if(tmp ==-1){
                dp[i] = dp[i-1] + 1;
            }else{
                dp[i] = sub.length()- tmp;
            }
            max = Math.max(max, dp[i]);
        }

        return max;

    }
}
```

这个解法有几点需要注意：

1. 因为你从 1 开始遍历的， 而你把 `max=-1`，如果字符串的长度恰好为1，就会导致输出为 `-1`，我的建议是：把max的初始值设为 `dp[0]`。
2. 状态转移方程：如果以 `i`结尾的字符恰好与前面相邻的子串融合而不存在重复，那么状态转移方程就为：`dp[i] = dp[i-1]+1`；如果以 `i`结尾的字符在前面的子串中存在重复，需要找出这个字符在前面的子串中的最后一次出现的索引位，从这个索引位截断，截断处后面的子串与 `i`处的字符组成一个新的子串，计算这个新的子串的长度即为 `dp[i]`的值
3. 在每一次迭代时可以计算出最大的子串长度
4. 时间复杂度：O(n)，空间复杂度：O(n)
5. 可以将其空间复杂度改为 O(1)，不再展示





## 最大连续1的个数

这是力扣1004. [最大连续1的个数](https://leetcode.cn/problems/max-consecutive-ones-iii/)，难度中等

![image-20230612000421363](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306120004466.png)

由题目知，我们可以使用滑动窗口进行求解：

我们想要获得最大的连续1的个数，即连续的1里面最多允许0的个数为K，当0的个数超过这个K值的时候，我们就需要移动左窗口，直到0的个数恢复为K，这个题的做法跟 [无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/) 这道题很像。

```java
class Solution {
    public int longestOnes(int[] nums, int k) {
        HashMap<Integer, Integer> window = new HashMap<>();

        int left=0, right = 0;
        int valid = 0;// 记录0的个数
        int res = -1;
        while(right < nums.length){
            if(nums[right]==0){
                valid++;
            }
            window.put(nums[right], window.getOrDefault(nums[right], 0)+1);
            // if(valid > k){// 如果添加的0的个数到达到了题目要求，计算此时的长度
            //     res = Math.max(res, right-left);
            // }// 不能刚好valid==k，因为不确定right之后是不是连续的1或者还是0
            right++;
            
            while(valid > k){
                window.put(nums[left], window.get(nums[left])-1);
                if(nums[left]==0)
                    valid--;
                left++;
            }
            res = Math.max(res, right-left);
        }
        return res;
    }
}
```

这里的 `valid`进行判断时候取得是 `valid>k`，这是因为如果刚好取 `valid=k`的话，可能会把right之后的1忽略掉了，因此采用 `valid>k`的条件，这样就一定能确保遍历到所有符合要求的1。

还有一个地方容易忽略导致出错：**一定要判断好 res 求解的条件，进行res求解的条件并不是只有 valid>k的时候才有，比如 [0,0,0,1] 4** ,一定要注意分析细节。

















