# 1438. 绝对值不超过限制的最长连续子数组

力扣1438题：[绝对值不超过限制的最长连续子数组](https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/)，难度中等

![image-20230612093207248](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306120932304.png)

![image-20230612093322709](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306120933765.png)

说说最一开始的思路，最开始在思考这道题的时候，寻思着寻找滑动窗口内的最大值max和最小值min，因为知道了最大值和最小值就知道了窗口内数据的差距。

我们知道，窗口向右移动的时候，窗口内的数据在增加，极有可能会导致窗口内的差距变大或者不变，因为在窗口向右移动的过程中可能会加入新的最大值或者最小值导致差距变大，因此我最开始的思考是用 `Math.max(num[right], max)`快速获取最大值或者最小值

```java
class Solution {
    public int longestSubarray(int[] nums, int limit) {
        int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;
        int res = -1;
        int right=0, left = 0;
        while(right<nums.length){
            min = minAndMaxVal(nums,left, right, 0);
            max = minAndMaxVal(nums,left, right, 1);
            while(max - min>limit){
                left++;
                min = minAndMaxVal(nums,left, right, 0);
                max = minAndMaxVal(nums,left, right, 1);
            }
            right++;
            res = Math.max(res, right - left);
        }
        return res;
    }

    public int minAndMaxVal(int[] nums, int left, int right, int flag){
        int min = nums[left];
        int max = nums[left];
        if(flag==1){//最大值
            for(int i=left; i<=right; i++){
                max = Math.max(max, nums[i]);
            }
        }else{
            for(int i=left; i<=right; i++){
                min = Math.min(min, nums[i]);
            }
        }
        return flag==1? max: min;
    }
}
```

上面这个代码看起来没什么问题，但是有一个弱点，那就是查询的时间复杂太高了，再加上for循环嵌套在while里面，因此这个代码并没有AC成功。原因竟是超时。



接下来我又考虑在获取到最值的时候同时获取索引，这样做有利用在向左移动窗口的时候，比较移除的值是不是最值，但是也存在一个问题，那就是向左移动窗口的时候，如果移出的是一个最值，那么接下来该如何在窗口内确定新的最值呢？

自己也曾想过是否需要写一个排序算法，但是嫌麻烦就没有写，而且你需要同时考虑保留值和索引。

因此就想到了 `TreeMap`，它的结构是红黑树，查找的时间复杂度是 `O(logn)`，而且提供了排序的功能，默认是升序。

结合以上考虑，套用 滑动窗口的模板，有了下面的代码：

```java
class Solution {
    public int longestSubarray(int[] nums, int limit) {
        int res = -1;
        int right = 0, left = 0;
        TreeMap<Integer, Integer> window = new TreeMap<>();// 记录窗口各种元素的个数
        
        while(right<nums.length){
            window.put(nums[right], window.getOrDefault(nums[right], 0)+1);
            right++;
            while(window.lastKey() - window.firstKey()>limit){
                window.put(nums[left], window.get(nums[left])-1);
                if(window.get(nums[left]).equals(0))// 如果发现某一个元素的个数是0，那么就移除这个元素
                    window.remove(nums[left]);
                left++;
            }
            res = Math.max(res, right - left);
        }
        return res;
    }
}
```

