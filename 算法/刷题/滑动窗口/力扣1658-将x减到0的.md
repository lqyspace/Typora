# 1658. 将x减到0的最小操作数

力扣1658. [将x减到0的最小操作数](https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/)，难度中等

![image-20230612110238545](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306121102599.png)

乍一看这个题目，可能没什么思路，而且对于如何删除左右边界的情况不确定，也不知道如何枚举，最开始想到的**递归+回溯**，递归和回溯其实说到底也就是枚举，那你同样需要考虑如何枚举，是先左再右再左再右，还是右左左右等等，要考虑的情况也而是相当复杂，这种思路要考虑的细节很多，稍不小心就容易漏解。

我们来分析一下题目，题目中说需要移除最左边或者最右边的元素，使移除的所有元素的和为x，让我们求移除的操作数。

假设有 `left` 和 `right` 两个指针，`left`指向最左边，`right`指向最右边，当left向右移动的时候，由于数组中元素都是正数，移除的元素的和是严格递增的，当left向左移动时，和是递减的；同理，如果将 `right`向左移，和是严格递增的，向右移动时则是递减。

因此本题我们可以考虑使用 `滑动窗口`来解题，不过需要分析一下滑动窗口的左移和右移分别代表什么含义。

我们假设先从数组的最右边开始一次性移到元素和刚好大于等于x的位置，由于此位置处的元素和大于x，因此考虑将 `right`指针右移，以减少一个元素，若此时的元素和小于x，此时肯定不能移动右指针，将右指针往左移元素变回原来大小，如果将右指针往右移，导致元素和进一步变小，因此可以将左指针右移一个元素将元素和适当变大，若此时的元素和大于x，则左指针肯定不能继续右移了，且右指针也不能左移，因为这两个操作都会使元素和变大，如果左指针左移一个位置的话又会使元素和变小（假设你真的这么干了，你真的将左指针左移了，那你必然会导致元素和变小，那你只能左移右指针以增大元素和，很明显，你这是在重复以前的老路，因此这种做法是不可取的），因此此时只能将右指针进一步右移，进一步减小元素和；若此时元素和小于x，则说明左指针右移的还不够，为什么这么说呢，因为你左移右指针的话，只能使元素和变大，因为你原本就是从右指针右移过来的，你再左移，就又移回原来的大小，因此不可取。

当然最开始一次性移动左指针也是一样的，只不过相应的操作取反。

综上，如果我们最开始将右指针一次性移动到位，那么接下来的操作如下：

1. 元素和大于x时，需要将右指针右移一个位置以减小元素和
2. 元素和小于x时，需要将左指针右移一个位置以增大元素和
3. 元素和等于x时，求解成功。

```java
class Solution {
    public int minOperations(int[] nums, int x) {
        int n = nums.length;
        int right = n, left = 0;
        int val = 0;
        while(right>0 && val + nums[right-1] <= x){ // 计算最长后缀
            val += nums[--right];
        }
        if(right==0 && val < x) return -1;// 全部移除也无法满足要求
        int res = val == x? n - right: n+1;

        while(left < n){
            val += nums[left++];
            while(right < n && val > x) // 缩小后缀长度
                val -= nums[right++];
            if(val > x) break; // 缩小失败，说明前缀过长
            if(val == x) res = Math.min(res, left + nums.length - right); // 前缀 + 后缀长度
        }
        return res>n? -1: res;
    }
}
```

解释一下这个代码：

刚开始求解出右边刚好小于等于x的位置，然后对元素和进行相应的判断，如果right==0且 val<x 的话，说明数组的元素根本打不到指定x的要求，因此直接返回-1即可；

如果 val == x，那么就可以直接给结果赋值 n - right，否则就给结果先赋最大值n+1，因为操作数不可能比 n+1 还要大

接下来就是循环的部分：不断枚举左指针的移动，如何元素和大于x就不断减小右指针的元素，如果仍然还是 val>x，则说明缩小失败，说明前缀过长，如果能满足 val==x，那就直接赋值。



还有一个比较好理解的代码：**逆向思维+双指针**

把问题转换成 从`nums`中移除一个最长的子数组，使得剩余元素的和为 x。

换句话说，就是在 `nums` 中找最长的子数组，其元素和等于 s-x，这里的s为所有元素的和。

```java
class Solution {
    public int minOperations(int[] nums, int x) {
        int target = -x;
        for(int num: nums) target += num;
        if(target<0) return -1; // 说明移除所有元素都不满足
        int ans = -1, left = 0, sum = 0;
        for(int right=0; right<nums.length; right++){
            sum+=nums[right];
            while(sum>target) sum -= nums[left++];
            if(sum==target) ans = Math.max(ans, right - left + 1);
        }

        return ans<0? -1: nums.length - ans;
    }
}
```

