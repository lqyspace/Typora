# 1658. 将x减到0的最小操作数

力扣1658. [将x减到0的最小操作数](https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/)，难度中等

![image-20230612110238545](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306121102599.png)

乍一看这个题目，可能没什么思路，而且对于如何删除左右边界的情况不确定，也不知道如何枚举，最开始想到的**递归+回溯**，递归和回溯其实说到底也就是枚举，那你同样需要考虑如何枚举，是先左再右再左再右，还是右左左右等等，要考虑的情况也而是相当复杂，这种思路要考虑的细节很多，稍不小心就容易漏解。

我们来分析一下题目，题目中说需要移除最左边或者最右边的元素，使移除的所有元素的和为x，让我们求移除的操作数。

假设有 `left` 和 `right` 两个指针，`left`指向最左边，`right`指向最右边，当left向右移动的时候，由于数组中元素都是正数，移除的元素的和是严格递增的，当left向左移动时，和是递减的；同理，如果将 `right`向左移，和是严格递增的，向右移动时则是递减。

因此本题我们可以考虑使用 `滑动窗口`来解题，不过需要分析一下滑动窗口的左移和右移分别代表什么含义。

我们假设先从数组的最右边开始一次性移到元素和刚好大于等于x的位置，由于此位置处的元素和大于x，因此考虑将 `right`指针右移，以减少一个元素，若此时的元素和小于x，此时肯定不能移动右指针，将右指针往左移元素变回原来大小，如果将右指针往右移，导致元素和进一步变小，因此可以将左指针右移一个元素将元素和适当变大，若此时的元素和大于x，则左指针肯定不能继续右移了，且右指针也不能左移，因为这两个操作都会使元素和变大，如果左指针左移一个位置的话又会使元素和变小（假设你真的这么干了，你真的将左指针左移了，那你必然会导致元素和变小，那你只能左移右指针以增大元素和，很明显，你这是在重复以前的老路，因此这种做法是不可取的），因此此时只能将右指针进一步右移，进一步减小元素和；若此时元素和小于x，则说明左指针右移的还不够，为什么这么说呢，因为你左移右指针的话，只能使元素和变大，因为你原本就是从右指针右移过来的，你再左移，就又移回原来的大小，因此不可取。

当然最开始一次性移动左指针也是一样的，只不过相应的操作取反。

综上，如果我们最开始将右指针一次性移动到位，那么接下来的操作如下：

1. 元素和大于x时，需要将右指针右移一个位置以减小元素和
2. 元素和小于x时，需要将左指针右移一个位置以增大元素和
3. 元素和等于x时，求解成功。

```java
class Solution {
    public int minOperations(int[] nums, int x) {
        int n = nums.length;
        int right = n, left = 0;
        int val = 0;
        while(right>0 && val + nums[right-1] <= x){ // 计算最长后缀
            val += nums[--right];
        }
        if(right==0 && val < x) return -1;// 全部移除也无法满足要求
        int res = val == x? n - right: n+1;

        while(left < n){
            val += nums[left++];
            while(right < n && val > x) // 缩小后缀长度
                val -= nums[right++];
            if(val > x) break; // 缩小失败，说明前缀过长
            if(val == x) res = Math.min(res, left + nums.length - right); // 前缀 + 后缀长度
        }
        return res>n? -1: res;
    }
}
```

解释一下这个代码：

首先，right被赋值为数组的长度，这个并不是唯一的，只不过在后续的使用中比较方便而已，我们完全可以将right定义为数组长度-1。

然后，求解出右边刚好小于等于x的位置，在while的循环里，right需要大于0，那能不能等于0呢？答案是不可以，如果right=0的话，那么就有可能导致数组`nums`出现索引异常的错误；然后 `val+nums[right-1]<=x`这个条件可以很好的控制`val`的值一定不会大于 x，这个循环终止了之后 `val`的值一定是小于等于 x的，那这个循环的另一个终止条件是什么呢？答案是 `right>0`这个条件，即我们需要主要考虑这个条件，当 `right=0`的时候条件终止。当然也是存在 `right`还不等于0的时候循环就已经终止了，主要是因为 val在下一次加右边的值的时候会导致val的值比x大。

接下来考虑一下边界的条件，如果right==0且 val<x 的话，这里就先不讨论val=x的情况（后续再讨论），说明数组的元素根本达不到指定x的要求，因此直接返回-1即可；

如果 val == x（此时开始考虑val=x的条件），那么就可以直接给结果res赋值 n - right，否则就给结果先赋最大值n+1，因为操作数不可能比 n+1 还要大。需要注意的是，此时还不能着急将res返回return，因此 n-right这个操作数并不一定保证就是最小操作数。

最后要考虑左边界元素了，因为前面的过程已经铺垫好了，此时val的值一定是小于等于x的，因此需要不断枚举左指针的移动，如果加上左边界的元素和大于x，那就需要不断减小右指针的元素直到val的值小于等于x为止，同时一定要确保right<n，如果仍然还是 val>x，则说明缩小失败，说明前缀中有一个元素特别大，无论怎么减小右边界都无济于事，因此此时数组中一定没有元素满足x的要求，那就结束循环。最后如果能满足 val==x，那就可以给res直接赋值了。

----------------------------------------------------------------假设这是一条分割线-------------------------------------------------------------

还有一个比较好理解的代码：**逆向思维+双指针**

把问题转换成 从`nums`中移除一个最长的子数组，使得剩余元素的和为 x。

换句话说，就是在 `nums` 中找最长的子数组，其元素和等于 s-x，这里的s为所有元素的和。

```java
class Solution {
    public int minOperations(int[] nums, int x) {
        int target = -x;
        for(int num: nums) target += num;
        if(target<0) return -1; // 说明移除所有元素都不满足
        int ans = -1, left = 0, sum = 0;
        for(int right=0; right<nums.length; right++){
            sum+=nums[right];
            // 这个循环执行完了以后，sum一定是小于等于target的，如果小于target，执行下一轮的循环就行。如果等于target的话，那就记录操作数res
            while(sum>target) sum -= nums[left++];
            if(sum==target) ans = Math.max(ans, right - left + 1);
        }

        return ans<0? -1: nums.length - ans;
    }
}
```

