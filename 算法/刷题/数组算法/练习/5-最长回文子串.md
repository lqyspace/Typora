# 5-最长回文子串

[力扣5-最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)，难度中等

![image-20230818143428225](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308181434289.png)

解题思路：**对于找最长回文串的思路就是，我从一个字符出发，不断向两边扩展，看最大能够扩展到多远，扩展的两端的距离就是回文串的长度。**

```java
class Solution {
    public String longestPalindrome(String s) {
		int n = s.length();
        if(n==1) return s;
        String res = "";
        for(int i=0; i<n; i++){
            // 以i为中心向两边扩展
            String s1 = palindrome(s, i, i);
            // 以 i，i+1为中心向两边扩展
            String s2 = palindrome(s, i, i+1);
            res = res.length()>s1.length()? (res.length() > s2.length()? res: s2): s1.length() > s2.length()? s1: s2;
        }
        return res;
        
    }
    
    public String palindrome(String s, int l, int r){
        int n = s.length();
        while(l>=0 && r<n && s.charAt(l) == s.charAt(r)){
            l--;
            r++;
        }
        return s.substring(l+1, r);
    }
}
```



**动态规划：**

```java
class Solution {
    public String longestPalindrome(String s) {
		int n = s.length();
        if(n==1) return s;
        boolean[][] dp = new boolean[n][n];// s[i...j]是否是回文串
        for(int i=0; i<n; i++)
            dp[i][i] = true;
        
        for(int i=n-1; i>=0; i--){
            for(int j=i+1; j<n; j++){
                if(s.charAt(i)==s.charAt(j))
                    dp[i][j] = dp[i+1][j-1]||(j-i<=2);
                else 
                    dp[i][j] = false;
            }
        }
        String res = "";
        for(int i=0; i<n; i++){
            for(int j=i; j<n; j++){
                if(dp[i][j])
                    res = res.length() > s.substring(i, j+1).length()? res: s.substring(i, j+1);
            }
        }
        return res;
    }
}
```

**优化：**

```java
class Solution {
    public String longestPalindrome(String s) {
		int n = s.length();
        if(n==1) return s;
        boolean[][] dp = new boolean[n][n];// s[i...j]是否是回文串
        for(int i=0; i<n; i++)
            dp[i][i] = true;
        int start = 0, maxLen = 1;
        for(int i=n-1; i>=0; i--){
            for(int j=i+1; j<n; j++){
                dp[i][j] = s.charAt(i)==s.charAt(j) && ((j-i<=2 || dp[i+1][j-1]));
                if(dp[i][j]){
                    if(maxLen < j-i+1){
                        maxLen = j-i+1;
                        start = i;
                    }
                }
            }
        }
        return s.substring(start, maxLen+start);
    }
}
```

**其他代码解法：**

```java
class Solution {
    public String longestPalindrome(String s) {
		int n = s.length();
        if(n==1) return s;
        boolean[][] dp = new boolean[n][n];// s[i...j]是否是回文串
        for(int i=0; i<n; i++)
            dp[i][i] = true;
        int start = 0, maxLen = 1;
        // 从长度2开始枚举
        for(int L = 2; L<=n; L++){
            for(int i=0; i<n; i++){
                // 获取右边界
                int j = i+L-1;
                // 如果右边界越界，退出当前循环
                if(j>=n) break;
                
                dp[i][j] = s.charAt(i)==s.charAt(j) && ((j-i<=2 || dp[i+1][j-1]));
                if(dp[i][j] && j-i+1>maxLen){
                    maxLen = j-i+1;
                    start = i;
                }
            }
        }
        return s.substring(start, maxLen+start);
    }
}
```

