# 380-O(1)时间插入，删除和获取随机元素

[力扣380-O(1)时间插入、删除和获取随机元素](https://leetcode.cn/problems/insert-delete-getrandom-o1/)，难度中等

![image-20230824170235893](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308241702990.png)

对于一个标椎的`HashSet`，你能否在O(1)的时间内实现getRandom函数？

其实是不能的，因为根据HashSet的底层实现，元素是被哈希函数【分散】到整个数组里面的，更别说还有拉链法等等解决哈希冲突的机制，基本做不到O(1)时间等概率获取元素。

要想实现O(1)时间的插入，删除和获取随机元素，可以使用==基于**数组**的数据结构 + 哈希表==解题。

首先基于数组的数据结构在获取元素的时候时间复杂度就是O(1)，但是插入和删除都涉及到元素的移动，所以不是O(1)的时间复杂度，但是如果对尾部进行插入和删除操作，时间复杂度就是O(1)，因此我们可以把要删除的元素先交换到尾部，然后删除的话就是O(1)的复杂度。

交换两个元素必须通过索引进行交换对吧，所以我们需要一个哈希表来记录每一个元素值对应的索引。

```java
class RandomizedSet {
	List<Integer> nums;
    Map<Integer, Integer> valToIndex;
    public RandomizedSet() {
		nums = new ArrayList<>();
        valToIndex = new HashMap<>();
    }
    
    public boolean insert(int val) {
		// 如果已经有了个元素，则返回false
        if(valToIndex.containsKey(val))
            return false;
        // 插入元素到末尾
        valToIndex.put(val, nums.size());
        nums.add(val);
        return true;
    }
    
    public boolean remove(int val) {
		// 如果元素不存在，则删除失败
        if(!valToIndex.containsKey(val))
            return false;
        //获取val的索引
        int index = valToIndex.get(val);
        // 将最后一个元素设置为index
        valToIndex.put(nums.get(nums.size()-1), index);
        // 交换
        Collections.swap(nums, index, nums.size()-1);
        // 删除
        nums.remove(nums.size()-1);
        valToIndex.remove(val);
        return true;
    }
    
    public int getRandom() {
		Random r = new Random();
        return nums.get(r.nextInt(nums.size()));
    }
}

/**
 * Your RandomizedSet object will be instantiated and called as such:
 * RandomizedSet obj = new RandomizedSet();
 * boolean param_1 = obj.insert(val);
 * boolean param_2 = obj.remove(val);
 * int param_3 = obj.getRandom();
 */
```

