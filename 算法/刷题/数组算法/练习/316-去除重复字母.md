# 316-去除重复字母

[力扣316-去除重复字母](https://leetcode.cn/problems/remove-duplicate-letters/)，难度中等

![image-20230825124622567](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308251246625.png)

解题思路：

解决这道题有三个要点需要注意：

- 去除重复字母
  - 这个比较容易实现，一边遍历字符串s，用一个辅助数组，已经访问过的字符设置为true，避免再次访问。已经访问过的字符用栈进行存储
- 字典序最小
  - 所谓的字典序最小，即让字母从小到大排列
  - 每访问到一个字符c的时候，就重复访问栈内的字符，将大于该字符c的字符删除掉
- 相对顺序不变

但是在解决这个问题的时候，有几点需要注意：

- 在删除栈内大于字符c的字符b时，如果字符b不会在后续的字符中再次出现，那么该字符b就不能删除，那么如何实现这个功能呢？
  - 可以先做一步统计，先统计s内各字符的数量，在删除栈内字符b之前先判断后续是否还有字符b，如果没有了则不能删除
  - **这个解法是真的巧妙，你需要记住并学习。你自己不是还在想如何判断后续字符的个数吗？你看，那么简单的方法，你都想不到，所以你需要记住这个方法：你可以提前用个数组统计一下各字符的数量。**

```java
class Solution {
    public String removeDuplicateLetters(String s) {
		// 创建一个栈
        Stack<Character> st = new Stack();
        // 记录s中字符的个数
        int[] count = new int[26];
        for(char c: s.toCharArray()){
            count[c - 'a']++;
        }
        
        // 判断字符是否已经遍历过
        boolean[] inStack = new boolean[26];
        
        for(char c: s.toCharArray()){
            // 每遍历一个字符，数量减一
            count[c - 'a']--;
            
            // 如果这个字符访问过，则跳过
            if(inStack[c-'a'])continue;
            
            // 删除大于c的字符
            while(!st.isEmpty() && st.peek() > c){
                // 如果后面没有这个字符，那么就不能删
                if(count[st.peek()-'a']==0)break;
                
                // 若之后还有这个字符，可以删除
                inStack[st.pop() - 'a'] = false;
            }
            // 添加
            st.push(c);
            inStack[c - 'a'] = true;
        }
        
        StringBuilder sb = new StringBuilder();
        while(!st.isEmpty()){
            sb.append(st.pop());
        }
        return sb.reverse().toString();
    }
}
```

