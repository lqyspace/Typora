# 二分查找

二分查找需要注意的细节：

- `mid`加一还是减一
- `while`里到底用 `<=`还是 `<`



二分查找顺口溜：

**搜索一个元素时**，搜索区间两端闭。

while条件带等号，否则需要打补丁。

if相等就返回，其他的事甭操心。

mid必须加减一，因为区间两端闭。

while结束就凉了，凄凄惨惨返-1.



**搜索左右边界时**，搜索区间要阐明。

左闭右开最常见，其余逻辑便自明。

while要用小于号，这样才能不漏掉。

if相等别返回，利用mid锁边界。

mid加一或减一？要看区间开或闭。

while结束不算完，因为你还没返回。

索引可能出边界，if检查保平安。



## 寻找一个数（基本的二分搜索）

```java
int binarySearch(int[] nums, int target) {
    int left = 0; 
    int right = nums.length - 1; // 注意

    while(left <= right) {
        int mid = left + (right - left) / 2;
        if(nums[mid] == target)
            return mid; 
        else if (nums[mid] < target)
            left = mid + 1; // 注意
        else if (nums[mid] > target)
            right = mid - 1; // 注意
    }
    return -1;
}
```

其中的一些细节：

> **1、为什么while循环的条件中是 <=，而不是 <？**

因为初始化 right 的赋值是 `nums.length-1`，即最后一个元素的索引，而不是 `nums.length`。

区别：前者相当于是两端都是闭区间 `[left, right]`，后者相当于是 `[left, right)`，因为索引大小为 `nums.length`是越界的，需要需要把right这一边视为开区间。

我们这个算法中使用的是前者 `[left, right]`两端都闭的区间，这个区间其实就是每次进行搜索的区间。

这个循环当找到目标值的时候就停止：

```java
if(nums[mid] == target)
    return mid; 
```

如果没有找到就需要while终止循环，返回-1。那么while循环什么时候终止呢，**搜索区间为空的时候应该终止** ，意味着你没得找了，就等于没找到。

`while(left<=right)`的终止条件是 `left=right+1`，写成区间的形式是 `[right+1, right]`，或者带个具体的数字进去[3, 2]，可见这时候区间为空，没有数字即大于3又小于2，所以这时候终止是正确的，直接返回 -1 即可。

`while(left<right)`的终止条件是 `left=right`，写成区间的形式就是 `[right, right]`，或者带个具体的数字进去[2, 2]，这时候区间非空，如果这个时候终止循环的话，就会把2漏掉，索引2没有被搜索，如果这时候返回 -1 就是错的。

当然，如果非要写成 `while(left<right)`也不是不可以，我们既然知道出错的原因，打个补丁就行：

```java
//...
while(left < right) {
    // ...
}
return nums[left] == target ? left : -1;
```



> **2、为什么 `left = mid + 1`，`right = mid - 1`，我看有的代码是 `right = mid`， `left= mid`，没有那些加加减减，到底是怎么回事，怎么判断？**

这也是二分查找的一个难点，不过只要你能理解前面的内容，就能够很容易判断。

刚才明确了「搜索区间」这个概念，而且本算法的搜索区间是两端都闭的，即 `[left, right]`。那么当我们发现索引 `mid` 不是要找的 `target` 时，下一步应该去搜索哪里呢？

当然是去搜索区间 `[left, mid-1]` 或者区间 `[mid+1, right]` 对不对？**因为 `mid` 已经搜索过，应该从搜索区间中去除**。



> **3、此算法有什么缺陷？**

至此，你应该已经掌握了该算法的所有细节，以及这样处理的原因。但是，这个算法存在局限性。

比如说给你有序数组 `nums = [1,2,2,2,3]`，`target` 为 2，此算法返回的索引是 2，没错。但是如果我想得到 `target` 的左侧边界，即索引 1，或者我想得到 `target` 的右侧边界，即索引 3，这样的话此算法是无法处理的。

这样的需求很常见，**你也许会说，找到一个 `target`，然后向左或向右线性搜索不行吗？可以，但是不好，因为这样难以保证二分查找对数级的复杂度了**。



## 寻找左侧边界的二分搜索

以下是最常见的代码形式，其中的标记是需要注意的细节：

```java
int left_bound(int[] nums, int target) {
    int left = 0;
    int right = nums.length; // 注意
    
    while (left < right) { // 注意
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            right = mid;// 因为区间是左闭右开，下一轮没必要搜索mid
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid; // 注意
        }
    }
    // 如果索引越界，说明 数组中无目标元素，返回 -1
    if(left < 0 || left>=nums.length)
        return -1;
    // 循环终止时，可能找到了目标元素也可能没有找到，所以在这里还需要再判断一下
    return nums[left]==target? left: -1;
}
```

> **1、为什么while中是 `<`而不是 `<=`?**

因为 `right = nums.length`而不是 `right = nums.length-1`，因此每次的搜索区间是 `[left, right)`左闭右开。

`while(left<right)`终止的条件是 `left==right`，此时的搜索区间的是 `[left,right)`为空，所以可以终止。



> 这里先要说一个搜索左右边界和上面这个算法的一个区别，也是很多读者问的：**刚才的 `right` 不是 `nums.length - 1` 吗，为啥这里非要写成 `nums.length` 使得「搜索区间」变成左闭右开呢**？
>
> 因为对于搜索左右侧边界的二分查找，这种写法比较普遍，我就拿这种写法举例了，保证你以后遇到这类代码可以理解。你非要用两端都闭的写法反而更简单，我会在后面写相关的代码，把三种二分搜索都用一种两端都闭的写法统一起来，你耐心往后看就行了。



> **2、代码中的 `left<0`的判断是否有必要？**

其实对于这个算法，`left` 不可能小于 0。你可以想象一下算法执行的逻辑，left 初始化就是 0，且只可能一直往右走，那么只可能在右侧越界。不过在访问数组索引之前保证索引在左右两端都不越界是一个很好的编程习惯，没有坏处，我这里就同时判断了。这样做的另一个好处是可以让二分的模板更统一，降低你的记忆成本。



> **3、为什么 `left=mid+1`，`right=mid`？和之前的算法不一样？**

这是因为我们的搜索区间是左闭右开 `[left, right)`的，所以当 `nums[mid]`被检测之后，下一步应该去 `mid`的左侧或者右侧区间去搜索，即 `[left, mid)`或 `[mid+1, right)`.



> **4、为什么该算法可以搜索左侧边界？**

关键在于对于 `nums[mid]==target`的处理：

```java
if(nums[mid]==target)
    right = mid;
```

由此可见，在找到target时，没有返回而是继续搜索区间的上界 right，在区间 `[left, mid)`中继续搜索，即不断向左侧收缩，达到锁定左侧边界的目的。



> **5、为什么返回 left而不是right？**

都是一样的，因为终止的条件是 `left==right`



> **6、能不能将right改为 `nums.length-1`？**

可以，只要能够有效的避免漏掉的元素，怎么改都行！

因为你非要让搜索区间两端都闭，所以 `right` 应该初始化为 `nums.length - 1`，while 的终止条件应该是 `left == right + 1`，也就是其中应该用 `<=`：

```java
int leftBound(int[] nums, int target){
    // 搜索区间为 [left, right]
    int right = nums.length-1;
    int left = 0;
    while(left<=right){
        int mid = left + (right - left)/2;
        if(nums[mid] == target)
            right = mid-1;// 收缩右侧边界，因为区间是左闭右闭，下一轮右侧边界是mid-1
        else if(nums[mid] < target)
            left = mid+1;// 搜索区间变为 [mid+1, right]
        else if(nums[mid] > target)
            right = mid-1; // 搜索区间变为 [left, mid-1]
    }
    // 判断target是否在数组中
    // 如果越界，则说明肯定不在数组中，返回-1
    if(left >= nums.length || left<0)
        return -1;
    // 如果索引不越界，最后仍然需要再判断一下
    return nums[left] == target? left: -1;
}
```





## 寻找右侧边界的二分查找

先写一个常见的左闭右开区间的代码：

```java
int rightBound(int[] nums, int target){
    int left = 0, right = nums.length;
    while(left<right){
        int mid = left + (right - left)/2;
        if(nums[mid] == target){
            left = mid + 1;// 左闭右开区间，下一轮从 mid+1开始搜索，不断让区间向右移动
        }else if(nums[mid] > target){
            right = mid;
        }else if(nums[mid] < target){
            left = mid + 1;
        }
    }
    
    // 判断target是否在数组中
    // left - 1如果越界的话，那么target一定不在数组中
    if(left-1<0 || left >= nums.length+1)
        return -1;
    
    // 循环终止时，已经执行过left+1，因此返回值的时候需要将left-1
    return nums[left-1]==target? left-1: -1;
}
```

那么是否可以把它改写成左闭右闭进行搜索呢？

```java
int rightBound(int[] nums, int target){
    int left = 0, right = nums.length-1;
    while(left<=right){
        int mid = left + (right - left)/2;
        if(nums[mid] == target){
            left = mid+1;
        }else if(nums[mid] > target){
            right = mid - 1;
        }else if(nums[mid] < target){
            left = mid + 1;
        }
    }
    // 判断索引是否越界
    if(left - 1<0 || left >= nums.length + 1)
        return -1;
    return nums[left-1] == target? left - 1: -1;
}
```

当然，由于while循环结束的时候为 `right = left - 1`，因此上述代码可以改为 `right`，这样更有利于看出是在搜索右侧区间：

```java
int rightBound(int[] nums, int target){
    int left = 0, right = nums.length - 1;
    while(left <= right){
        int mid = left + (right - left)/2;
        if(nums[mid] == target)
            left = mid + 1;
        else if(nums[mid] > target)
            right = mid - 1;
        else if(nums[mid] < target)
            left = mid + 1;
    }
    //循环结束时：right = left - 1
    if(right < 0 || right >= nums.length)
        return -1;
    return nums[right]==target? right: -1;
}
```



> **1、为什么这个算法能够找到右侧边界？**

因为这个算法：

```java
if (nums[mid] == target) {
    left = mid + 1;
```

当 `nums[mid] == target` 时，不要立即返回，而是增大「搜索区间」的左边界 `left`，使得区间不断向右靠拢，达到锁定右侧边界的目的。



## 代码逻辑

### 第一个 最基本的二分查找

```
因为我们初始化 right = nums.length - 1
所以决定了我们的「搜索区间」是 [left, right]
所以决定了 while (left <= right)
同时也决定了 left = mid+1 和 right = mid-1

因为我们只需找到一个 target 的索引即可
所以当 nums[mid] == target 时可以立即返回
```



### 第二个 寻找左侧边界的二分查找

```
因为我们初始化 right = nums.length
所以决定了我们的「搜索区间」是 [left, right)
所以决定了 while (left < right)
同时也决定了 left = mid + 1 和 right = mid

因为我们需找到 target 的最左侧索引
所以当 nums[mid] == target 时不要立即返回
而要收紧右侧边界以锁定左侧边界
```



### 第三个 寻找右侧边界的二分查找

```
因为我们初始化 right = nums.length
所以决定了我们的「搜索区间」是 [left, right)
所以决定了 while (left < right)
同时也决定了 left = mid + 1 和 right = mid

因为我们需找到 target 的最右侧索引
所以当 nums[mid] == target 时不要立即返回
而要收紧左侧边界以锁定右侧边界

又因为收紧左侧边界时必须 left = mid + 1
所以最后无论返回 left 还是 right，必须减一
```



对于寻找左右边界的二分搜索，比较常见的手法是使用左闭右开的「搜索区间」，**我们还根据逻辑将「搜索区间」全都统一成了两端都闭，便于记忆，只要修改两处即可变化出三种写法**：

```java
int binarySearch(int[] nums, int target){
    int left = 0, right = nums.length - 1;
    while(left <= right){
        int mid = left + (right - left)/2;
        if(nums[mid] == target){
            return mid;// 直接返回
        }else if(nums[mid] > target){
            right = mid - 1;
        }else if(nums[mid] < target){
            left = mid + 1;
        }
    }
    return -1;// 如果遍历结束那么说明数组中没有，直接返回-1
}

int leftBound(int[] nums, int target){
    int left = 0, right = nums.length-1;
    while(left <= right){
        int mid = left + (right - left)/2;
        if(nums[mid] == target){
            right = mid - 1;// 别返回，锁定右边界
        }else if(nums[mid]>target){
            right = mid - 1;
        }else if(nums[mid] < target){
            left = mid + 1;
        }
    }
    // 判断target是否在数组中
    if(left<0 || left>=nums.length){
        return -1;
    }
    // 判断一下 nums[left]是不是target
    return nums[left]==target? left:-1;
}

int rightBound(int[] nums, int target){
    int left = 0, right = nums.length - 1;
    while(left <= right){
        int mid = left + (right - left)/2;
        if(nums[mid]==target){
            left = mid + 1;
        }else if(nums[mid] > target){
            right = mid - 1;
        }else if(nums[mid] < target){
            left = mid + 1;
        }
    }
    // 判断target是否在数组中
    //if(left-1<0 || left >= nums.length+1)
     //   return -1;
    
    //由于while的约束条件是right==left-1，且现在在求右边界
    // 所以用right代替left-1更合适
    if(right < 0|| right >= nums.length)
        return -1;
    return nums[right]==target? right: -1;
}
```

最后，注意几点细节：

1、分析二分查找的代码时，不要出现 else，全部展开成 else if方便理解。

2、注意搜索区间和while的终止条件，如果存在漏掉的元素，记得最后检查。

3、如需定义左闭右开的「搜索区间」搜索左右边界，只要在 `nums[mid] == target` 时做修改即可，搜索右侧时需要减一。

4、如果将「搜索区间」全都统一成两端都闭，好记，只要稍改 `nums[mid] == target` 条件处的代码和返回的逻辑即可，推荐拿小本本记下，作为二分搜索模板。



