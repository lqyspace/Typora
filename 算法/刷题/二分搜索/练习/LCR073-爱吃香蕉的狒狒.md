# LCR073爱吃香蕉的狒狒

[LCR073爱吃香蕉的狒狒](https://leetcode.cn/problems/nZZqjQ/?show=1)，难度中等

![image-20230823012637411](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308230126526.png)

题意分析：

猴子每小时可以吃K根香蕉，并且每小时只能吃一堆香蕉，如果这堆香蕉数量小于等于K，那么在这一小时内不能去吃另一堆的香蕉，如果这堆香蕉数量大于K根，那么猴子在这一小时内也只能吃K根香蕉，剩余的部分留下一小时再吃。

根据题意，可以分析出，猴子最低每小时可以吃一根香蕉，最多最多一个小时内也只能吃一堆香蕉，即最多也只能吃数组元素中的最大值。

猴子吃香蕉的速度，与时间是成反比的，猴子吃的速度越快，所需的时间越少。

现在让我们求猴子在满足规定时间内吃掉所有香蕉的最小速度。

注意：猴子在规定时间内吃掉所有的速度肯定有一个区间，求这个区间的最小值即可，即求左侧边界

我们来分析一下，猴子吃香蕉可能花的时间，考虑一种极端情况，假设猴子每小时只吃一根香蕉，数组最长是$10^4$，每堆香蕉的数量最大是$10^9$根，那么猴子要花$10^{13}$小时，这远大于int整形的最大值$2 \times 10^9$，为了避免溢出，猴子所花时间得用long类型。并且f函数的返回值也得用long类型。

```java
class Solution {
    public int minEatingSpeed(int[] piles, int h) {
		int left = 1, right = maxNumber(piles)+1;
        while(left < right){
            int mid = left + (right - left)/2;
            if(f(piles, mid) <= h)
                right = mid;
            else left = mid+1;
        }
        return left;
    }
    public long f(int[] nums, int k){// k是猴子吃香蕉的速度
        // 函数需要返回猴子在k的情况下，所需要的时间是多少
        long hours = 0;
        for(int num: nums){
            hours += num/k;
            if(num%k > 0)
                hours++;
        }
        return hours;        
    }
    public int maxNumber(int[] nums){
        int res = -1;
        for(int num: nums){
            res = Math.max(res, num);
        }
        return res;
    }
}
```





















