# 1760-袋子里最少数目的球

[1760-袋子里最少数目的球](https://leetcode.cn/problems/minimum-limit-of-balls-in-a-bag/)，难度中等

延伸：这道题和力扣 410、1011、1482、1552、1760、2187、2226 属于同一类题

![image-20230823171515734](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308231715909.png)

题目的要求是：在指定操作次数的情况下，求单个袋子最大值的最小值；

也就是说，在操作次数允许的情况下，让袋子里的球的个数尽量低。

题目让我们求最小化开销，其实也就是球的个数，因此自变量为球的个数，在操作次数允许的情况下，单个袋子里的球的个数最少为1，假如操作次数特别少，那么球的个数，也就是开销最多为数组的最大值减一，极端情况下，开销为$10^9$，但是并不足$10^9$，也就是$10^9-1$。

与自变量存在单调关系的就是操作次数，操作次数越多，那么开销其实就越小，操作次数越少，那么开销就越大。而操作次数是题目中的一个已知量，所以适合做因变量。

target就是题目中给出来已知量。

由于求的是最大之中的最小值，因此求左侧边界。

```java
class Solution {
    public int minimumSize(int[] nums, int maxOperations) {
		// 自变量开销，极端情况下最低为1，最高为10^9-1，或者数组的最大值减一也行
        int left = 1, right = 1000000000-1 + 1;
        while(left < right){
            int mid = left + (right - left)/2;
            if(f(nums, mid) <= maxOperations)
                right = mid;
            else
                left = mid+1;
        }
        return left;
    }
    
    public int f(int[] nums, int v){// v表示开销
        // 函数返回操作次数
        // 看每个数的开销是多少，然后累加
        int n = 0;// 表示开销
        for(int i=0; i<nums.length; i++){
            if(nums[i]<=v)
                continue;
            int tmp = nums[i];
            while(tmp>v){
                tmp -= v;
                n++;
            }
        }
        return n;
    }
}
```

提交代码，发现超时，因此需要优化：

发现`f函数`可以进一步优化：先排序，然后找刚好比v大的索引，最后使用双指针同时遍历

```java
class Solution {
    public int minimumSize(int[] nums, int maxOperations) {
        // 先排序
        Arrays.sort(nums);
        
		// 自变量开销，极端情况下最低为1，最高为10^9-1，或者数组的最大值减一也行
        int left = 1, right = 1000000000-1 + 1;
        while(left < right){
            int mid = left + (right - left)/2;
            if(f(nums, mid) <= maxOperations)
                right = mid;
            else
                left = mid+1;
        }
        return left;
    }
    
    public int f(int[] nums, int v){// v表示开销
        // 函数返回操作次数
        // 看每个数的开销是多少，然后累加
        
        // 找刚好比v大的索引
        int left = 0, right = nums.length;
        while(left < right){
            int mid = left + (right - left)/2;
            if(nums[mid] >= v) right = mid;
            else left = mid+1;
        }
        int index = left;// 找到了刚好比v大的索引
        
        int n = 0;// 表示开销
        for(int i=index; i<nums.length; i++){
            if(nums[i]<=v)
                continue;
            int tmp = nums[i];
            while(tmp>v){
                tmp -= v;
                n++;
            }
        }
        return n;
    }
}
```

艹，md，还是超时，想想怎么优化？

我靠，还有一段代码可以优化，那就是求 n 的那段：

```java
class Solution {
    public int minimumSize(int[] nums, int maxOperations) {
        // 先排序
        Arrays.sort(nums);
        
		// 自变量开销，极端情况下最低为1，最高为10^9-1，或者数组的最大值减一也行
        int left = 1, right = 1000000000-1 + 1;
        while(left < right){
            int mid = left + (right - left)/2;
            if(f(nums, mid) <= maxOperations)
                right = mid;
            else
                left = mid+1;
        }
        return left;
    }
    
    public int f(int[] nums, int v){// v表示开销
        // 函数返回操作次数
        // 看每个数的开销是多少，然后累加
        
        // 找刚好比v大的索引
        int left = 0, right = nums.length;
        while(left < right){
            int mid = left + (right - left)/2;
            if(nums[mid] >= v) right = mid;
            else left = mid+1;
        }
        int index = left;// 找到了刚好比v大的索引
        
        int n = 0;// 表示开销
        for(int i=index; i<nums.length; i++){
            if(nums[i]<=v)
                continue;
            int tmp = nums[i];
            n += (tmp/v - 1);
            if(tmp%v > 0)n++;
        }
        return n;
    }
}
```

代码通过！！！nice。

时间复杂度：$O(nlogC)$，其中n是数组的长度，C是数组的最大值，并且不少过$10^9$。

空间复杂度：$O(1)$

