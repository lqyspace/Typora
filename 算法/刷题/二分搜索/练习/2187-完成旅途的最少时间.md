# 2187-完成旅途的最少时间

[2187-完成旅途的最少时间](https://leetcode.cn/problems/minimum-time-to-complete-trips/)，难度中等

延伸：这道题和力扣 410、1011、1482、1552、1760、2187、2226 属于同一类题

![image-20230824124715155](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308241247225.png)

解题思路：

- 题目让我求最少时间，即把最少时间作为自变量
- 与时间存在单调关系的是旅行次数，且旅行次数是已知量，因此把旅行次数作为因变量
- 时间与旅行次数之间存在正相关
- 求最少旅行次数，即左侧边界

代码如下：

```java
class Solution {
    public long minimumTime(int[] time, int totalTrips) {
        long left = 1;
         // 计算最大用时
         int w = -1;
         for(int nu: time)
            w = Math.max(w, nu);
        long right = w * totalTrips + 1;

        while(left < right){
            long mid = left + (right - left)/2;
            if(f(time, mid) >= totalTrips)
                right = mid;
            else left = mid+1;
        }
        return left;
    }

    public long f(int[] nums, long time){
        // time是自变量，函数返回最少旅途数
        // 极端情况下，只有一趟旅行，一辆公交用时1，所以总用时1
        // 极端情况下，只有一辆公交，每辆公交用时10^7，总共有10^7趟旅行，所以总用时10^14
        // 注意完成的旅途数，极端情况下,可以完成的最大旅途数为 10^12
        // 防止溢出，tours用long类型，返回结果用long
        long tours = 0;
        for(int i=0; i<nums.length; i++){
            tours += time/nums[i];
        }
        return tours;
    }
}
```

**这版代码会出现解答错误，是因为有一个地方整型溢出了。**

改进版：

```java
class Solution {
    public long minimumTime(int[] time, int totalTrips) {
        long left = 1;
         // 计算最大用时
         long w = -1;
         for(int nu: time)
            w = Math.max(w, nu);
        long right = w * totalTrips + 1;

        while(left < right){
            long mid = left + (right - left)/2;
            if(f(time, mid) >= totalTrips)
                right = mid;
            else left = mid+1;
        }
        return left;
    }

    public long f(int[] nums, long time){
        // time是自变量，函数返回最少旅途数
        // 极端情况下，只有一趟旅行，一辆公交用时1，所以总用时1
        // 极端情况下，只有一辆公交，每辆公交用时10^7，总共有10^7趟旅行，所以总用时10^14
        // 注意完成的旅途数，极端情况下,可以完成的最大旅途数为 10^12
        // 防止溢出，tours用long类型，返回结果用long
        long tours = 0;
        for(int i=0; i<nums.length; i++){
            tours += time/nums[i];
        }
        return tours;
    }
}
```

这版代码可以顺利解出答案，相信你也已经看出来了，在`w=-1`那儿，==应该将`int`改为`long`，==这是因为int类型和int类型相乘得到的答案还是int类型，即使你是用long来接受的，但是int类型和int类型乘积会先用int空间大小来临时存储结果，所以是会溢出的。而用int和long相乘，得到的答案是long类型，然后再用long类型来接受，所以不会出错。