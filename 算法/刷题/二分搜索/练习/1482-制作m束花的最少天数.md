# 1482-制作m束花的最少天数

[1482-制作m束花的最少天数](https://leetcode.cn/problems/minimum-number-of-days-to-make-m-bouquets/)，难度中等

延伸：这道题和力扣 410、1011、1482、1552、1760、2187、2226 属于同一类题

![image-20230823015319810](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308230153924.png)

解题思路：

每束花需要k朵，需要制作m束花，因此一共需要m*k多花。如果花园中的花的数量小于m*k朵花，即数组bloomDay的长度小于mk，那么就一定无法制作出m个花束，返回-1。如果数组的长度大于等于mk，那么就一定可以制作成m个花束。

为了计算制作指定数量的花束的最少天数，首先需要实现一个辅助函数用于判断在给定的天数内能否制作出指定数量的花束，辅助函数的参数除了bloomDay，m，k还有一个days，例如：当bloomDay=[1,  10,  3,  10, 2]、m=3、k=1时，如果days=3，那么函数返回true，如果days=2，那么函数返回false。

对于辅助函数的实现，可以遍历数组bloomDay，计算其中的长度k且最大元素不超过days的不重合的连续子数组的数量，如果符合要求的连续子数组的数量大于或等于m，则返回true，说明在days天的情况下一定可以制作成m束花，则返回true，否则返回false。

我们知道，当days很小的时候，辅助函数的返回值是false，因为天数太少，无法收齐m个花束；当days很大时，辅助函数总是可以返回true。如果给定的序列可以制作出m束花，那么在days慢慢变大的过程中，辅助函数的返回值由false变为true，所以我们可以认为这个辅助函数是关于days递增的，因此可以使用二分搜索来快速查找最少天数。

在确保可以制作出m束花的前提下，所需的最少天数一定大于等于数组bloomDay的最小值，最大天数一定小于等于数组的最大值。

官方题解：

```java
class Solution {
    public int minDays(int[] bloomDay, int m, int k) {
        if (m > bloomDay.length / k) {
            return -1;
        }
        int low = Integer.MAX_VALUE, high = 0;
        int length = bloomDay.length;
        for (int i = 0; i < length; i++) {
            low = Math.min(low, bloomDay[i]);
            high = Math.max(high, bloomDay[i]);
        }
        while (low < high) {
            int days = (high - low) / 2 + low;
            if (canMake(bloomDay, days, m, k)) {
                high = days;
            } else {
                low = days + 1;
            }
        }
        return low;
    }

    public boolean canMake(int[] bloomDay, int days, int m, int k) {
        int bouquets = 0;
        int flowers = 0;
        int length = bloomDay.length;
        for (int i = 0; i < length && bouquets < m; i++) {
            if (bloomDay[i] <= days) {
                flowers++;
                if (flowers == k) {
                    bouquets++;
                    flowers = 0;
                }
            } else {
                flowers = 0;
            }
        }
        return bouquets >= m;
    }
}
```



我自己写的代码：

```java
class Solution {
    public int minDays(int[] bloomDay, int m, int k) {
        if(m > bloomDay.length/k) return -1; // 不能写成m*k，因为可能会整形溢出
		// 制作所需要数量的花的最少天数一定大于等于数组的最小值，所需最大天数一定小于等于数组的最大值
        int low = Integer.MAX_VALUE, high = 0;
        for(int nu: bloomDay){
            low = Math.min(low, nu);
            high = Math.max(high, nu);
        }
        
        while(low <= high){
            int mid = low + (high - low)/2;
            if(f(bloomDay, k, mid) >= m)// 只要这个序列能够做出至少m束花，那么就适当减少天数days，以求最少天数。
                high = mid-1;
            else
                low = mid+1;                
        }
        // 只要花的数量够，就一定可以包成m束花
        return low;
    }
    
    public int f(int[] nums, int k, int days){
        // 这个函数用于判断是否可以做成m束花，因为即使在指定天数的情况下，不同的数组仍然可以做成不同数量m的花，我们要求的是做成m束花需要的最少天数。
        // 只要这个序列能做出至少m束花，那么我就适当减少days以求 最少的天数
        int m = 0;
        int flowers = 0;
        int len = nums.length;
        for(int i=0; i<len; i++){
            if(nums[i] <= days){
                flowers++;
                if(flowers == k){
                    m++;
                    flowers=0;
                }
            } else {
                flowers = 0;
            }
        }
        return m;
    }
}
```
