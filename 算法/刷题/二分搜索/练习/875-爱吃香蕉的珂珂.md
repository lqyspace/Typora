# 爱吃香蕉的珂珂

[力扣875-爱吃香蕉的珂珂](https://leetcode.cn/problems/koko-eating-bananas/description/)，难度中等

延伸：这道题和力扣 410、1011、1482、1552、1760、2187、2226 属于同一类题

![image-20230822182334507](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308221823560.png)

由于珂珂吃香蕉的速度和用时具有单调关系，因此可以采用二分搜索来解题：

自己最开始写的代码：==珂珂最少每小时可以吃1根香蕉；由于珂珂每次只能吃一堆香蕉，即使还能再多吃，也只能等下一小时，所以珂珂的最大每小时可以吃 数组的最大值。==

```java
class Solution {
    public int minEatingSpeed(int[] piles, int h) {
        // int left = 1, right = 1000000000;
        int left = 1, right = maxNumber(piles);
        if(piles.length == h) return right;

        while(left <= right){
            int mid = left + (right - left)/2;
            if(f(piles, mid) > h){
                // 想办法降低小时数
                left = mid + 1;
            } else if(f(piles, mid) < h){
                // 想办法提高小时数
                right = mid-1;
            } else {
                // 求最小速度，就是求左边界
                right = mid-1;
            }
        }
        return left;
    }
    public long f(int[] nums, int k){
        long total = 0;
        for(int i=0; i<nums.length; i++){
            total += nums[i] / k;
            if(nums[i] % k>0)
                total++;
        }
        return total;
    }
    public int maxNumber(int[] nums){
        int max = -1;
        for(int i = 0; i<nums.length; i++)
            max = Math.max(max, nums[i]);
        return max;
    }
}
```

**注意：**有一个地方自己总是出错，那就是f函数的返回值类型，题目中给的piles的长度最大为$10^4$，且预计用时最大为$10^9$，如果珂珂每小时吃一根香蕉的话，那么用时$10^13$，这将超过int的最大值（大概$2\times 10^9$）导致整型溢出，所以要将**f的返回值设置为long类型**，**同时total的类型也要连同一起设置为long**（你自己因为忘记将total设置为long，导致错误提交了好几遍）。

**注意，也可以将right的值直接设置为题目给的最大值，也是可以得到正确结果的。**

将以上代码优化：

```java
class Solution {
    public int minEatingSpeed(int[] piles, int h) {
        // int left = 1, right = 1000000000;
        int left = 1, right = maxNumber(piles);
        if(piles.length == h) return right;

        while(left <= right){
            int mid = left + (right - left)/2;
            if(f(piles, mid) > h){
                // 想办法降低小时数
                left = mid + 1;
            } else {
                // 求最小速度，就是求左边界
                right = mid-1;
            }
        }
        return left;
    }
    public long f(int[] nums, int k){
        long total = 0;
        for(int i=0; i<nums.length; i++){
            total += nums[i] / k;
            if(nums[i] % k>0)
                total++;
        }
        return total;
    }
    public int maxNumber(int[] nums){
        int max = -1;
        for(int i = 0; i<nums.length; i++)
            max = Math.max(max, nums[i]);
        return max;
    }
}
```

```java
class Solution {
    public int minEatingSpeed(int[] piles, int h) {
        int left = 1, right = 1000000000;
        // int left = 1, right = maxNumber(piles);
        // if(piles.length == h) return right;

        while(left <= right){
            int mid = left + (right - left)/2;
            if(f(piles, mid) > h){
                // 想办法降低小时数
                left = mid + 1;
            } else {
                // 求最小速度，就是求左边界
                right = mid-1;
            }
        }
        return left;
    }
    public long f(int[] nums, int k){
        long total = 0;
        for(int i=0; i<nums.length; i++){
            total += nums[i] / k;
            if(nums[i] % k>0)
                total++;
        }
        return total;
    }
    // public int maxNumber(int[] nums){
    //     int max = -1;
    //     for(int i = 0; i<nums.length; i++)
    //         max = Math.max(max, nums[i]);
    //     return max;
    // }
}
```

```java
class Solution {
    public int minEatingSpeed(int[] piles, int h) {
        int left = 1, right = 1000000000 + 1;
        // int left = 1, right = maxNumber(piles);
        // if(piles.length == h) return right;

        while(left < right){
            int mid = left + (right - left)/2;
            if(f(piles, mid) > h){
                // 想办法降低小时数
                left = mid + 1;
            } else {
                // 求最小速度，就是求左边界
                right = mid;
            }
        }
        return left;
    }
    public long f(int[] nums, int k){
        long total = 0;
        for(int i=0; i<nums.length; i++){
            total += nums[i] / k;
            if(nums[i] % k>0)
                total++;
        }
        return total;
    }
    // public int maxNumber(int[] nums){
    //     int max = -1;
    //     for(int i = 0; i<nums.length; i++)
    //         max = Math.max(max, nums[i]);
    //     return max;
    // }
}
```

