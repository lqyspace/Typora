# 410-分割数组的最大值

[410-分割数组的最大值](https://leetcode.cn/problems/split-array-largest-sum/description/)，难度困难

延伸：这道题和力扣 410、1011、1482、1552、1760、2187、2226 属于同一类题

![image-20230822234125958](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308222341017.png)

分析：

> **分的堆数越多，最大值的最小值越小吗？**

是。分的堆数越多，最大值的最小值一定越小。

因为这个最小值是 在给定的分成m堆的情况下，所有的分堆情况中最大子数组和中的最小值。随着堆数的增加，该最小值一定越小，因此成反相关关系。

> **假设该最小值为k**

我们知道，如果这个最小值为k的话，那么在这种分堆情况下，m堆的子数组，每个子数组的和都应该小于等于k。

> **问题的转化**

在已知分成m堆的情况下，我们需要求这个最小值k。相当于 [力扣1011-在D天内送到包裹的能力](https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/description/) 这道题，相当于我们需要在m天运输完这堆包裹，同样也是连续子数组的包裹进行运输。现在让我们求船的运输能力k。

而且一定要注意，分成m堆的情况纵然有很多，但是我们的目的是求这么多情况中最大子数组和是最小的情况，因此一些极端的分堆情况肯定无法满足要求，举个例子：[1,  2,  3,  4,  5]   分成 3 堆，所有的分堆情况为：

```java
1\2\3 4 5——>最大值：12;
1\2 3\4 5——>最大值：9;
1\2 3 4\5——>最大值：9;
1 2\3\4 5——>最大值：9;
1 2\3 4\5——>最大值：7;
1 2 3\4\5——>最大值：6;
```

我们可以看出：像第一种这种分堆情况，最大值是最大的，而最后一种情况是最大值最小的，我们可以得知，最小的分堆情况一定是这m堆的子数组和足够平均的情况下，只有在这种情况下，才能保证子数组的和最小。

==话说回来，我们将问题转化为：在m天的情况下，运输完这些包裹，问船的荷载能力最少是多少能保证在m天运输完成？==

```java
class Solution{
    public int splitArray(int[] nums, int k) {// k是堆数
        int left = maxNumber(nums), right = 1000000 * 1000 + 1;
        while(left < right){
            int mid = left + (right - left)/2;
            if(f(nums, mid) <= k)// 堆数比较少，想办法提高堆数，则减少子数组和
                right = mid;
            else // 堆数比较大，想办法减少堆数，则增加子数组和
                left = mid+1;
        }
        return left;
    }
    
    public int f(int[] nums, int v){// 这个v相当于船的荷载能力，也就是子数组的最大值的最小值
        // 函数的输出是：在最小值是v的情况下，可以分多少堆
        int m = 0;
        int tmp = 0;
        for(int i=0; i<nums.length; i++){
            if(tmp + nums[i] <= v){
                tmp += nums[i];
            } else {
                m++;
                tmp = nums[i];
            }
        }
        if(tmp>0) m++;// 万一最后一轮tmp不为0，所以还需要再分一堆
        return m;        
    }
    
    public int maxNumber(int[] nums){
        int res = -1;
        for(int num: nums)
            res = Math.max(res, num);
        return res;
    }
    
}
```
