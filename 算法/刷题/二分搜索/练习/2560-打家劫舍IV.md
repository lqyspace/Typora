# 2560-打家劫舍IV

[2560-打家劫舍IV](https://leetcode.cn/problems/house-robber-iv/?envType=daily-question&envId=2023-09-19)，难度中等

![image-20230919012837765](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202309190128197.png)

题解：这道题妥妥二分搜索，思路如下：

首先需要找到小偷的**偷窃能力**和房屋个数之间的单调关系，又由题意我们可以知道：设x为小偷的偷窃能力，k为小偷在这个偷窃能力的范围下最多能够偷窃的房屋个数。如果小偷的偷窃能力越大的话，那么小偷能够偷窃的房屋个数也就越多，因此小偷的偷窃能力与房屋个数存在正相关性。

解释一下为什么要求最大的房屋个数？

首先，如果求最小的房屋个数，极端情况下，小偷最小的偷窃的房屋个数可以为0，因为可以存在小偷的偷窃能力比每家的金币个数都小的情况，因此求最小的房屋个数是不对的。

那么为什么偷最大的房屋个数是对的呢，因为在x确定的情况下，小偷最大能够偷k间房子，那么反过来考虑的话，小偷偷k间房子的最小的能力就是x，正好符合题目让我们求的值，因为x可以越大，x越大的话，能够偷的房子也就越多，所以我们只需要求x的情况下，能够偷的最大k是多少。

代码如下：

```java
class Solution {
    public int minCapability(int[] nums, int k) {
        if(nums.length==1) return nums[0];
        int left = 1, right = 1000000001;
        while(left<right){
            int mid = left + (right - left)/2;
            if(f(nums, mid) >= k){
                right = mid;
            }else{
                left = mid+1;
            }
        }
        if(left<0 || left>= 1000000001)
            return 0;
        return left;
    }
    
    public int f(int[] nums, int x){
        // 第一家开始偷
        int count = 0;
        for(int i=0; i<nums.length;){
            if(nums[i]<=x){
                count++;
                i+=2;
            }else{
                i++;
            }
        }
        // 第一家不偷
        int tmp = 0;
        for(int i=1; i<nums.length;){
            if(nums[i]<=x){
                tmp++;
                i+=2;
            }else{
                i++;
            }
        }
        return count>tmp? count: tmp;
    }
}
```

优化：

```java
class Solution {
    public int minCapability(int[] nums, int k) {
        if(nums.length==1) return nums[0];
        int left = 1, right = 1000000001;
        while(left<right){
            int mid = left + (right - left)/2;
            if(f(nums, mid) >= k){
                right = mid;
            }else{
                left = mid+1;
            }
        }
        if(left<0 || left>= 1000000001)
            return 0;
        return left;
    }

    public int f(int[] nums, int x){
        // f0第一家开始偷, f1第一家不偷
        int f0 = 0, f1 = 0;
        for(int i=0; i<nums.length;){
            if(nums[i]<=x){
                f0++;
                if(i>0) f1++;
                i+=2;
            }else{
                i++;
            }
        }
        return f0>f1? f0: f1;
    }
}
```

