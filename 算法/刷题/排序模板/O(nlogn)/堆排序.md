# 堆排序

数组、链表都是一维的数据结构，相对来说比较容易理解，而堆是二维的数据结构，对抽象思维的要求更高，所以许多程序员「谈堆色变」。但堆又是数据结构进阶必经的一步，我们不妨静下心来，将其梳理清楚。

> 堆：符合以下两个条件之一的完全二叉树：
>
> 根节点的值 ≥ 子节点的值，这样的堆被称之为最大堆，或大顶堆；
> 根节点的值 ≤ 子节点的值，这样的堆被称之为最小堆，或小顶堆。



堆排序过程如下：

- 用数列构建出一个大顶堆，取出堆顶的数字；
- 调整剩余的数字，构建出新的大顶堆，再次取出堆顶的数字；
- 循环往复，完成整个排序。

整体的思路就是这么简单，我们需要解决的问题有两个：

- 如何用数列构建出一个大顶堆；
- 取出堆顶的数字后，如何将剩余的数字调整成新的大顶堆。



在介绍堆排序具体实现之前，我们先要了解完全二叉树的几个性质。将根节点的下标视为 0，则完全二叉树有如下性质：

- 对于完全二叉树中的第 `i` 个数，它的左子节点下标：`left = 2i + 1`

- 对于完全二叉树中的第 `i` 个数，它的右子节点下标：`right = left + 1`
- 对于有 `n` 个元素的完全二叉树`(n≥2)`，它的最后一个非叶子结点的下标：`n/2 - 1`

```java
public static void heapSort(int[] arr){
    // 构建大顶堆
    buildMaxHeap(arr);
    for (int i=arr.length-1; i>0; i--){
        swap(arr, 0, i);// 将最大值交换到数组最后
        maxHeapify(arr, 0, i); // 调整剩余数组， 使其满足大顶堆
    }
}

// 构建大顶堆
private static void buildMaxHeap(int[] arr) {
    // 从最后一个非叶子节点开始调整大顶堆，最后一个非叶子节点的下标是 arr.length/2-1
    for (int i=arr.length/2-1; i>=0; i--){
        maxHeapify(arr, i, arr.length);
    }
}

// 调整大顶堆
private static void maxHeapify(int[] arr, int i, int heapSize) {
    // 左子节点下标
    int left = 2*i + 1;
    int right = left + 1;// 右子节点下标
    // 记录根节点，左子节点，右子节点三者中的最大值下标
    int largest = i;
    // 与左子树节点比较
    if (left < heapSize && arr[left] > arr[largest])
        largest = left;
    // 与右子树节点比较
    if (right < heapSize && arr[right] > arr[largest])
        largest = right;

    if (largest != i){
        // 将最大值作为根节点
        swap(arr, i, largest);
        // 再次调整交换数字后的大顶堆
        maxHeapify(arr, largest, heapSize);
    }
}
private static void swap(int[] arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
```





**注：**

**堆排序是不稳定的排序算法！**

**初始化建堆时间复杂度O(n)，重建堆的时间复杂度O(nlogn)，所以总的时间复杂度：O(nlogn)**

**空间复杂度：O(1)**

