# 选择排序

选择排序的思想是：双重循环遍历数组，每经过一轮比较，找到最小元素的下标，将其交换至首位。

**注意：时间复杂度O(n^2)，空间复杂度O(1)**

**算法不稳定！**

**选择排序比冒泡排序有更少的交换次数。**



## 第一种写法

```java
//    1. 双重循环遍历数组，每经过一轮比较，找到最小元素的下标，将其交换至首位
public static void selectedSort1(int[] arr){
    int minIndex = 0;
    for (int i=0; i<arr.length-1; i++){
        minIndex = i;
        for (int j=i+1; j<arr.length; j++){
            if (arr[minIndex]>arr[j])
                minIndex = j;
        }
        //交换
        int tmp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = tmp;
    }
}
```



## 背：二元选择排序

选择排序算法也是可以优化的，既然每轮遍历时找出了最小值，何不把最大值也顺便找出来呢？这就是二元选择排序的思想。

使用二元选择排序，每轮选择时记录最小值和最大值，可以把数组需要遍历的范围缩小一倍。

```java
// 二元选择排序：同时找到最大值和最小值
public static void selectedSort2(int[] arr){
    int minIndex, maxIndex;
    for (int i=0; i<arr.length/2;i++){
        minIndex = i;
        maxIndex = i;
        for (int j=0; j<arr.length-i; j++){
            if (arr[minIndex] > arr[j]){
                minIndex = j;// 找到最小值的索引
            }
            if (arr[maxIndex]<arr[j]){
                maxIndex = j;// 找到最大值的索引
            }
        }
        // 如果 minIndex 和 maxIndex 相等，说明他们必定都等于 i，且后面的所有数字都相等，因此此时排序已经完成
        if (minIndex == maxIndex) break;
        // 将最小值移到首位
        int tmp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = tmp;
        
        // 如果最大值的下标刚好是 i，又因为 i 和 minIndex 交换了位置，因此需要更新 maxIndex
        if (maxIndex==i) maxIndex = minIndex;
        
        // 将最大值移到末尾
        int lastIndex = arr.length - 1 - i;
        tmp = arr[lastIndex];
        arr[lastIndex] = arr[maxIndex];
        arr[maxIndex] = tmp;
    }
}
```



**二元选择排序的速度比选择排序快一点点，它的速度提升的主要原因有两点：**

- 在选择排序的外层 for 循环中，`i` 需要加到 `arr.length - 1` ，二元选择排序中 i 只需要加到 `arr.length / 2`

- 在选择排序的内层 for 循环中，`j` 需要加到 `arr.length` ，二元选择排序中 j 只需要加到 `arr.length - i`

























