# 冒泡排序

冒泡排序是入门级的算法，但也有一些有趣的玩法。通常来说，冒泡排序有三种写法：

- 一边比较一边向后两两交换，将最大值 / 最小值冒泡到最后一位；

- 经过优化的写法：使用一个变量记录当前轮次的比较是否发生过交换，如果没有发生交换表示已经有序，不再继续排序；
- 进一步优化的写法：除了使用变量记录当前轮次是否发生交换外，再使用一个变量记录上次发生交换的位置，下一轮排序时到达上次交换的位置就停止比较。



**注意：时间复杂度O(n^2)，空间复杂度O(1)**

**算法稳定！**



## 冒泡排序的第一种写法

```java
// 第一种写法：n个数，需要比较n-1轮，每一轮进行两两交换，将最大值或最小值放在最后一位，每比较完一轮，就会少一个数
public static void bubbleSort(int[] arr){
    for (int i=0; i<arr.length-1; i++){
        for (int j=0; j< arr.length-1-i; j++){
            if (arr[j]>arr[j+1])
                swap(arr, j, j+1);
        }
    }
}

public static void swap(int[] arr, int i, int j){
        // 如何在不引入第三变量的方式进行交换，但该方法存在边界溢出的情况
//        arr[j] = arr[i] + arr[j];
//        arr[i] = arr[j] - arr[i];
//        arr[j] = arr[j] - arr[i];

        // 异或运算，注意 i和j不能相等
        if (i!=j && arr[i]!=arr[j]){
            arr[i] = arr[i] ^ arr[j];
            arr[j] = arr[j] ^ arr[i];
            arr[i] = arr[i] ^ arr[j];
        }
    }
```



## 冒泡排序的第二种写法

```java
// 第二种写法：对第一种写法的优化，如果当前的轮次没有发生交换，则说明不必继续比较
public static void bubbleSort1(int[] arr){
    boolean swapped = true;
    for (int i=0; i<arr.length-1; i++){
        if (!swapped) break;// 如果没有被交换，说明剩余的部分已经有序，所以没有必要继续比较
        swapped = false;
        for (int j=0; j<arr.length-1-i; j++){
            if (arr[j] > arr[j+1]){
                swapped = true;
                swap(arr, j, j+1);
            }
        }
    }
}

public static void swap(int[] arr, int i, int j){
        // 如何在不引入第三变量的方式进行交换，但该方法存在边界溢出的情况
//        arr[j] = arr[i] + arr[j];
//        arr[i] = arr[j] - arr[i];
//        arr[j] = arr[j] - arr[i];

        // 异或运算，注意 i和j不能相等
        if (i!=j && arr[i]!=arr[j]){
            arr[i] = arr[i] ^ arr[j];
            arr[j] = arr[j] ^ arr[i];
            arr[i] = arr[i] ^ arr[j];
        }
    }
```



## 背：冒泡排序的第三种写法

```java
// 第三种写法：对第二种写法的优化，如果发生了交换，则记录发生交换的位置，下一轮直接遍历到该位置就行
    // 背诵
    public static void bubbleSort3(int[] arr){
        boolean swapped = true; // 最开始，说明交换过，需要往下继续比较
        int indexOfLastUnsortedElement = arr.length-1; // 最后一个没有经过排序的元素的下标
        int swappedIndex = -1; // 上次发生交换的位置

        while (swapped){
            swapped = false;
            for (int i=0; i<indexOfLastUnsortedElement; i++){
                if (arr[i] > arr[i+1]){
                    swap(arr, i, i+1);
                    swapped = true;
                    swappedIndex = i;// 记录上次发生元素交换的位置
                }
            }
            indexOfLastUnsortedElement = swappedIndex;
        }
    }

    public static void swap(int[] arr, int i, int j){
        // 如何在不引入第三变量的方式进行交换，该方法存在边界溢出的情况
//        arr[j] = arr[i] + arr[j];
//        arr[i] = arr[j] - arr[i];
//        arr[j] = arr[j] - arr[i];

        // 异或运算，注意 i和j不能相等
        if (i!=j && arr[i]!=arr[j]){
            arr[i] = arr[i] ^ arr[j];
            arr[j] = arr[j] ^ arr[i];
            arr[i] = arr[i] ^ arr[j];
        }
    }
```