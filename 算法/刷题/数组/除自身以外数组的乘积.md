# 除自身以外数组的乘积

## 前言

这似乎是一个简单的问题，可以在线性时间和空间内解决。先计算给定数组所有元素的的乘积，然后对数组中的每个元素 `x`，将总的乘积除以 `x`来求得除自身外的数组的乘积。

然后这个做法有一个问题，如果输入数组中出现0，那么这个方法就失效了。而且在问题中也说明了不允许使用除法，这也就加大了问题的难度。



## 方法一

我们不必计算所有数字的乘积然后除以给定索引处的数字得到相应的答案，而是利用索引左侧所有数字的乘积和索引右侧所有数字的乘积相乘得到答案。

对于给定的索引 `i`，我们将使用它左边所有数字的乘积乘以它右边所有数字的乘积。

下面是具体的算法过程：

1、初始化两个空数组 `L`和 `R`。对于给定的索引 `i`，`L[i]`代表的是 `i`左侧所有数字的乘积，`R[i]`代表的是 `i`所有右侧数字的乘积。

2、我们需要使用两个循环来填充 `L`和 `R`两个数组的值。对于数组 `L`，`L[0]`应该是 1，因为第一个元素的左边没有元素。对于其他的元素：`L[i]=L[i-1]*nums[i-1]`。

3、同理，对于数组 `R`，`R[length-1]`应为1，其他的元素为：`R[i]=R[i+1]*nums[i+1]`。

4、当 `R`和 `L`填充完成，我们只需要在数组上迭代即可，索引 `i`处的值为：`L[i]*R[i]`。

代码：

```java
public int[] productExceptSelf(int[] nums) {
    int n = nums.length;
    int[] L = new int[n], R = new int[n];
    L[0] = 1; R[n-1] = 1;
    for(int i=1; i<n; i++)
        L[i] = L[i-1] * nums[i-1];
    for(int i=n-2; i>=0; i--)
        R[i] = R[i+1] * nums[i+1];
    int[] ans = new int[n];
    for(int i=0; i<n; i++)
        ans[i] = L[i] * R[i];
    return ans;
}
```

这个解法的时间复杂度为 `O(N)`，但是空间复杂度偏高，空间上额外声明了 `L`和 `R`两个数组（答案`ans`的数组排外）。



下面有一个改善空间复杂度的算法，那就是之声明一个数组 `ans`，只不过需要进行两边循环，第一遍向左循环得到左数组的效果值，第二遍以此为基础向右遍历得到最终的结果值。

```java
public int[] productExceptSelf(int[] nums) {
    int n = nums.length;
    int[] res = new int[n];
    res[0] = 1;
    int right = 1;
    // 第一遍循环得到索引i左边的数乘积结果
    for(int i=1; i<n; i++)
        res[i] = res[i-1] * nums[i-1];
    // 第二遍循环，在第一遍的基础上，乘以i右边的索引值
    for(int i=n-1; i>=0; i--){
        res[i] = right * res[i];
        right = nums[i] * right;
    }
    return res;        
}
```

此代码的时间复杂度 `O(N)`，空间复杂度：`O(1)`。