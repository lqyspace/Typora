# 710-黑名单中的随机数

[力扣710-黑名单中的随机数](https://leetcode.cn/problems/random-pick-with-blacklist/)，难度困难

![image-20230824171713204](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308241717268.png)

解题思路：==利用数组结构 + 哈希表==，解题思路和 710道题类似

- 核心思想：假设黑名单映射到数组的末尾
- 具体的细节：已经处于末尾的黑名单数字保持不变，而处于前列的黑名单数字映射到正常的数字

具体看代码：

```java
class Solution {
	int sz;// 用于确定范围
    Map<Integer, Integer> mapping;
    public Solution(int n, int[] blacklist) {
		sz = n - blacklist.length;
        mapping = new HashMap<>();
        // 将黑名单的数字添加进mapping
        for(int b: blacklist){
            mapping.put(b, 666);
        }
        
        int last = n - 1;
        for(int b: blacklist){
            //如果b处于[sz, n)范围内，那就不要管，我的目的就是为了让黑名单的数字处于[sz, n)中
            if(b>=sz) continue;
            
            // 将b映射到末尾
            while(mapping.containsKey(last)){
                last--;
                // 如果黑名单里包含这个last，那就自减，看下一个last是不是不在黑名单里
                // 我的目的是将b映射到一个正常的数
            }
            mapping.put(b, last);
            last--;
        }
    }
    
    public int pick() {
		// 产生随机数
        Random r = new Random();
        // 之所有是sz，是因为[sz, n)大部分已经是黑名单的数了
        // 就算[0, sz)里面有一些黑名单里面的数字，也被映射到了正常的数字
        int index = r.nextInt(sz);
        // 如果这个索引是黑名单里面的数字，那就返回映射的数字
        if(mapping.containsKey(index))
            return mapping.get(index);
        return index;        
    }
}

/**
 * Your Solution object will be instantiated and called as such:
 * Solution obj = new Solution(n, blacklist);
 * int param_1 = obj.pick();
 */
```

