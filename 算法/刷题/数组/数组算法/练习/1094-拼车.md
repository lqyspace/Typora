# 1094-拼车

[力扣1094-拼车](https://leetcode.cn/problems/car-pooling/description/)，难度中等

![image-20230819110925268](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308200932638.png)

~~可以使用线性扫描解决此题：~~==nonono==，这道题用线性扫描是解决不了的，你看下面的代码，你对start和end排完序后，导致start和end与每次上车的人数不对应，所以出错了。你可能会说，可以声明一个HashMap来解决这个问题，用start，end和每次上车的人数组合起来当做一个键，用上车的人数作为值，但是！！！后期你在使用的时候，你该怎么获取这个值呢？仔细想想，用线性扫描的方法不妥。下面是线性扫描的代码，是一个错误的范例，以此铭记。

```java
class Solution {
    public boolean carPooling(int[][] trips, int capacity) {
		int m = trips.length;
        int[] start = new int[m], end = new int[m];
        for(int i=0; i<m; i++){
            start[i] = trips[i][1];
            end[i] = trips[i][2];
        }
        // 对start 和 end 排序
        Arrays.sort(start);
        Arrays.sort(end);
        
        int i = 0, j = 0;
        while(i<m && j<m){
            if(start[i] < end[j]){
                capacity-=trips[i][0];
                i++;
            } else if(start[i] > end[j]){
                capacity += trips[j][0];
                j++;
            } else {
                capacity += trips[j][0];
                capacity-=trips[i][0];
                i++; j++;
            }
            if(capacity<0)
                return false;
        }
        return true;
    }
}
```



接下来使用 **差分数组：**

```java
class Solution {
    public boolean carPooling(int[][] trips, int capacity) {
		// 初始化
        int[] nums = new int[1001];
        Difference diff = new Difference(nums);
        for(int[] row: trips)
            diff.increment(row[1], row[2]-1, row[0]);
        int[] res = diff.result();
        
        for(int i=0; i<res.length; i++)
            if(res[i]>capacity)
                return false;
        return true;
    }
}

class Difference{
    private int[] diff;
    public Difference(int[] nums){
        diff = new int[nums.length];
        diff[0] = nums[0];
        for(int i=1; i<nums.length; i++)
            diff[i] = nums[i] - nums[i-1];
    }
    
    public void increment(int i, int j, int val){
        diff[i] += val;
        if(j+1<diff.length)
            diff[j+1] -= val;
    }
    
    public int[] result(){
        int[] res = new int[diff.length];
        res[0] = diff[0];
        for(int i=1; i<diff.length; i++)
            res[i] = res[i-1] + diff[i];
        return res;
    }
}
```



记录2023-12-02的题解：

```java
class Solution {
    public boolean carPooling(int[][] trips, int capacity) {
        int n = trips.length;
        int[][] start = new int[n][2], end = new int[n][2];
        for(int i=0; i<n; i++){
            start[i][0] = trips[i][1]; start[i][1] = trips[i][0];
            end[i][0] = trips[i][2]; end[i][1] = trips[i][0];
        }
        Comparator<int[]> mc = new Comparator<int[]>(){
            public int compare(int[] a, int[] b){
                return a[0]-b[0];
            }
        };
        Arrays.sort(start, mc);
        Arrays.sort(end, mc);

        int max = -1;
        int l = 0, i=0, j=0;
        while(i<n && j<n){
            if(start[i][0]<end[j][0]){
                l += start[i][1];
                i++;
            }else if(start[i][0] > end[j][0]){
                l -= end[j][1];
                j++;
            }else{
                l = l + start[i][1] - end[j][1];
                i++;
                j++;
            }
            if(l>capacity)
                return false;
        }
        return true;
    }
}
```
