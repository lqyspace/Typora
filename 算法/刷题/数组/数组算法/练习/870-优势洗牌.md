# 870-优势洗牌

[870-优势洗牌](https://leetcode.cn/problems/advantage-shuffle/description/)，难度中等

![image-20230824143422767](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308241434852.png)

解题思路：

- 现将两个数组进行排序，升序排序，用nums1的最大值和nums2的最大值去比拼，如果nums1能胜过nums2的最大值，那么就用nums1的最大值去对付nums2的最大值。
- 如果nums1的最大值比不过nums2的最大值，就用nums1的最小值去对付nums2的最大值，因为nums1中没有比nums2的最大值更大的了，只能送人头
- 有人也许会问，也许nums1的第二大的值比nums2的最大值大，那完全可以用nums1的第二大的值去和nums2的最大值比较。我想说这个是没问题的，但是没必要，因为nums1的第二大的值已经比nums2的最大值要大，那你把nums1的最大值留着去对付谁呢？所以说没必要留着，如果nums1的最大值打得过nums2的最大值，那就直接对付就行。如果nums1的最大值的确打不过nums2的最大值，那就只能用nums1的最小值去送人头了。



第一版代码：

```java
class Solution {
    public int[] advantageCount(int[] nums1, int[] nums2) {
        List<int[]> nu1 = new LinkedList<>();
        List<int[]> nu2 = new LinkedList<>();
        for(int i=0; i<nums1.length; i++){
            nu1.add(new int[]{i, nums1[i]});
            nu2.add(new int[]{i, nums2[i]});
        }
        
        Collections.sort(nu1, new Comparator<int[]>(){
            public int compare(int[] a, int[] b){
                return a[1] - b[1];
            }
        });
        Collections.sort(nu2, new Comparator<int[]>(){
            public int compare(int[] a, int[] b){
                return a[1] - b[1];
            }
        });
        int[] res = new int[nums1.length];

        while(!nu1.isEmpty()){
            // 最大值和最大值比
            int[] cur = nu1.get(nu1.size()-1);
            if(cur[1] > nu2.get(nu2.size()-1)[1]){
                // 如果大于
                res[nu2.get(nu2.size()-1)[0]] = cur[1];
                nu1.remove(nu1.size()-1);
            } else {
                // 如果小于，直接把最小值对上最大值
                res[nu2.get(nu2.size()-1)[0]] = nu1.get(0)[1];
                nu1.remove(0);
            }
            nu2.remove(nu2.size()-1);
        }
        return res;
    }
}
```

第二版代码：

```java
class Solution {
    public int[] advantageCount(int[] nums1, int[] nums2) {
        List<int[]> nu2 = new LinkedList<>();
        for(int i=0; i<nums1.length; i++){
            nu2.add(new int[]{i, nums2[i]});
        }
        Arrays.sort(nums1);// 对数组1排序
        Collections.sort(nu2, new Comparator<int[]>(){
            public int compare(int[] a, int[] b){
                return a[1] - b[1];
            }
        });
        int[] res = new int[nums1.length];
        // 双指针
        int left = 0, right = nums1.length-1;
        while(!nu2.isEmpty()){
            // 最大值和最大值比
            int[] cur = nu2.remove(nu2.size()-1);
            if(cur[1] < nums1[right]){
                // 如果大于
                res[cur[0]] = nums1[right];
                right--;
            } else {
                // 如果小于，直接把最小值对上最大值
                res[cur[0]] = nums1[left];
                left++;
            }
        }
        return res;
    }
}
```

lubuladong代码：

```java
int[] advantageCount(int[] nums1, int[] nums2) {
    int n = nums1.length;
    // 给 nums2 降序排序
    PriorityQueue<int[]> maxpq = new PriorityQueue<>(
        (int[] pair1, int[] pair2) -> { 
            return pair2[1] - pair1[1];
        }
    );
    for (int i = 0; i < n; i++) {
        maxpq.offer(new int[]{i, nums2[i]});
    }
    // 给 nums1 升序排序
    Arrays.sort(nums1);

    // nums1[left] 是最小值，nums1[right] 是最大值
    int left = 0, right = n - 1;
    int[] res = new int[n];

    while (!maxpq.isEmpty()) {
        int[] pair = maxpq.poll();
        // maxval 是 nums2 中的最大值，i 是对应索引
        int i = pair[0], maxval = pair[1];
        if (maxval < nums1[right]) {
            // 如果 nums1[right] 能胜过 maxval，那就自己上
            res[i] = nums1[right];
            right--;
        } else {
            // 否则用最小值混一下，养精蓄锐
            res[i] = nums1[left];
            left++;
        }
    }
    return res;
}
```

