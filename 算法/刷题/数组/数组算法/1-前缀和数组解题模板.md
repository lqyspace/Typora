# 前缀和

前缀和技巧适用于快速，频繁地计算一个索引区间内的元素之和。



## 一维数组的前缀和

先看一道例题，力扣第 303 题「[区域和检索 - 数组不可变](https://leetcode.cn/problems/range-sum-query-immutable/)」，让你计算数组区间内元素的和，这是一道标准的前缀和问题：

![img](https://labuladong.github.io/algo/images/前缀和/title1.png)

题目要求我们实现这样的一个类：

```java
class NumArray {

    public NumArray(int[] nums) {}
    
    /* 查询闭区间 [left, right] 的累加和 */
    public int sumRange(int left, int right) {}
}
```

`sumRange`函数需要计算并返回一个索引区间之内的元素和，没学过前缀和的人可能写出这样的代码：

```java
class NumArray {

    private int[] nums;

    public NumArray(int[] nums) {
        this.nums = nums;
    }
    
    public int sumRange(int left, int right) {
        int res = 0;
        for (int i = left; i <= right; i++) {
            res += nums[i];
        }
        return res;
    }
}
```

这样达到的效果很差，因为 `sumRange`函数会被频繁的调用，而它的时间复杂度 `O(N)`，其中 `N`代表数组的长度。

这道题的最优解法使用前缀和的技巧，将 `sumRange`的函数的时间复杂度降为 `O(1)`，说白了就是不要在 `sumRange`里面用 `for`循环。

代码如下：

```java
class NumArray{
    // 前缀和数组
    private int[] preNums;
    public NumArray(int[] nums){
        // preNums[0] = 0，便于计算累加和
        preNums = new int[nums.length + 1];
        // 计算preNums的前缀和
        for(int i=1; i<preNums.length; i++){
            preNums[i] = preNums[i-1] + nums[i-1];
        }
    }
    // 查看闭区间 [left, right] 的累加和
    public int sumRange(int left, int right){
        return preNums[right + 1] - preNums[left];
    }
}
```

核心思路就是声明一个新的前缀和数组，`preNums[i]`记录 `nums[0...i-1]`的累加和，看图 10=3+5+2：

![img](https://labuladong.github.io/algo/images/差分数组/1.jpeg)

因此，`sumRange`函数只需要做一次减法运算即可，避免了每次进行 `for`循环调用，最坏的时间复杂度为常数 `O(1)`。





## 二维矩阵中的前缀和

这是力扣第 304 题「[二维区域和检索 - 矩阵不可变](https://leetcode.cn/problems/range-sum-query-2d-immutable/)」，其实和上一题类似，上一题是让你计算子数组的元素之和，这道题让你计算二维矩阵中子矩阵的元素之和：

![img](https://labuladong.github.io/algo/images/前缀和/title2.png)

比如说输入的 `matrix`如下图：

![img](https://labuladong.github.io/algo/images/前缀和/4.png)

按照题目的要求，矩阵的左上角是 `(0, 0)`，那么 `sumRegion([2,1,4,3])`就是图中红色的子矩阵，你需要返回该子矩阵的元素和8。

当然，你可以用一个嵌套的 `for`循环去遍历这个矩阵，但这样的话，`sumRegion`的函数的复杂度就高了，你算法的格局就低了。

注意，任意子矩阵的元素和可以转化成它周边几个大矩阵的元素和的运算：

![img](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202307132155407.jpeg)

这四个大矩阵都有一个共同的特点，就是左上角都是 `(0, 0)`原点。

那么做这道题更好的思路和一维数组中的前缀和是非常的类似的，我们可以维护一个二维 `preSum`数组，专门记录以原点为顶点的矩阵的元素之和，就可以用几次加减运算算出任何一个子矩阵的元素和：

```java
class NumMatrix {
	private int[][] preSum;
    public NumMatrix(int[][] matrix) {
		int m = matrix.length, n = matrix[0].length;
        preSum = new int[m+1][n+1];
        // preSum[0][0] = 0 方便累加
        for(int i=1; i<=m; i++){
            for(int j=1; j<=n; j++){
                preSum[i][j] = preSum[i-1][j] + preSum[i][j-1] - preSum[i-1][j-1] + matrix[i-1][j-1];
            }
        }
    }
    
    public int sumRegion(int row1, int col1, int row2, int col2) {
		return preSum[row2+1][col2+1] - preSum[row2+1][col1+1-1] - preSum[row1+1-1][col2+1] + preSum[row1+1-1][col1+1-1];
    }
}

/**
 * Your NumMatrix object will be instantiated and called as such:
 * NumMatrix obj = new NumMatrix(matrix);
 * int param_1 = obj.sumRegion(row1,col1,row2,col2);
 */
```

这样， `sumRegion`函数的时间复杂度也用前缀和技巧又划到了 `O(1)`，这是典型的空间换时间的思路。











