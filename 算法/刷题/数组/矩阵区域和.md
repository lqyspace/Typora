# 矩阵区域和

[力扣1314题](https://leetcode.cn/problems/matrix-block-sum/)，难度中等

![image-20230714105629316](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202307141056380.png)

这道题的解题思路是：**利用二维的前缀和进行解题**，这里对解题思想不再进行阐述，不熟悉的请看 [前缀和解题](https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-48c1d/xiao-er-me-03265/)。

本题在解题的时候，主要声明了两个数组：一个 `preSum[][]`数组用于统计矩阵的 `mat[i][j]`到原点的前缀和，而 `ans[][]`则是需要返回的结果。

根据题目中给的条件，我们可以计算出区域矩阵的左上角 `(i-k, j-k)` 和右下角 `(i+k, j+k)`，同时需要注意 **不能超过数组的最大索引。**

```java
class Solution {
    private int[][] preSum;
    public int[][] matrixBlockSum(int[][] mat, int k) {
        int m = mat.length, n = mat[0].length;
        preSum = new int[m+1][n+1];
        int[][] ans = new int[m][n];

        for(int i=1; i<=m; i++){
            for(int j=1; j<=n; j++){
                preSum[i][j] = preSum[i][j-1] + preSum[i-1][j] - preSum[i-1][j-1] + mat[i-1][j-1];
            }
        }

        for(int i=0; i<m; i++){
            for(int j=0; j<n; j++){
                int maxRow = i + k>=m? m-1: i+k, minRow = i-k<0?0:i-k;
                int maxCol = j + k>=n? n-1: j+k, minCol = j - k<0? 0: j-k;
                ans[i][j] = getAns(minRow, minCol, maxRow, maxCol);
            }
        }
        return ans;
    }

    public int getAns(int x1, int y1, int x2, int y2){
        return preSum[x2+1][y2+1] - preSum[x2+1][y1] - preSum[x1][y2+1] + preSum[x1][y1];
    }
}
```

