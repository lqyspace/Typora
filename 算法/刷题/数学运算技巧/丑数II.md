# 丑数II

力扣264.[丑数II](https://leetcode.cn/problems/ugly-number-ii/)，难度中等

![image-20230616140731140](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306161407187.png)

函数签名如下：

```java
int nthUglyNumber(int n)
```

比如输入`n = 10`，函数应该返回 12，因为从小到大的丑数序列为`1, 2, 3, 4, 5, 6, 8, 9, 10, 12`，第 10 个丑数是 12（注意我们把 1 也算作一个丑数）。

这道题很精妙，你看着它好像是道数学题，实际上它却是一个合并多个有序链表的问题，同时用到了**筛选素数**的思路。

首先，我在前文 [如何高效寻找质数](https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484472&idx=1&sn=ab8e97d0211de37bf6770a63caacc630&scene=21#wechat_redirect) 中也讲过高效筛选质数的「筛数法」：一个质数和除 1 以外的其他数字的乘积一定不是质数，把这些数字筛掉，剩下的就是质数。

Wikipedia 的这幅图很形象：

![图片](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306161639681.gif)

基于筛数法的思路和丑数的定义，我们不难想到这样一个规律：**如果一个数`x`是丑数，那么`x * 2, x * 3, x * 5`都一定是丑数**。

如果我们把所有丑数想象成一个从小到大排序的链表，就是这个样子：

```java
1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 8 -> ...
```

然后，我们可以把丑数分为三类：2 的倍数、3 的倍数、5 的倍数。这三类丑数就好像三条有序链表，如下：

能被 2 整除的丑数：

```java
1 -> 1*2 -> 2*2 -> 3*2 -> 4*2 -> 5*2 -> 6*2 -> 8*2 ->...
```

能被 3 整除的丑数：

```java
1 -> 1*3 -> 2*3 -> 3*3 -> 4*3 -> 5*3 -> 6*3 -> 8*3 ->...
```

能被 5 整除的丑数：

```java
1 -> 1*5 -> 2*5 -> 3*5 -> 4*5 -> 5*5 -> 6*5 -> 8*5 ->...
```

我们如果把这三条「有序链表」合并在一起并去重，得到的就是丑数的序列，其中第`n`个元素就是题目想要的答案：

```java
1 -> 1*2 -> 1*3 -> 2*2 -> 1*5 -> 3*2 -> 4*2 ->...
```

代码如下：

```java
int nthUglyNumber(int n) {
    // 可以理解为三个指向有序链表头结点的指针
    int p2 = 1, p3 = 1, p5 = 1;
    // 可以理解为三个有序链表的头节点的值
    int product2 = 1, product3 = 1, product5 = 1;
    // 可以理解为最终合并的有序链表（结果链表）
    int[] ugly = new int[n + 1];
    // 可以理解为结果链表上的指针
    int p = 1;

    // 开始合并三个有序链表，找到第 n 个丑数时结束
    while (p <= n) {
        // 取三个链表的最小结点
        int min = Math.min(Math.min(product2, product3), product5);
        // 将最小节点接到结果链表上
        ugly[p++] = min;
        // 接下来的解释，一个丑数可以乘以2,3,5，如果这个丑数乘以2的结果被选作丑数，那么这个丑数就不能
        // 再次乘以2，只有ugly数组中的下一个丑数才可以乘以2.
        // 以下的代码，相当于将ugly中的每个数都经历了一遍*2，*3，*5
        // pi的含义是有资格同i相乘的最小丑数的位置
        
        // 前进对应有序链表上的指针
        if (min == product2) {
            product2 = 2 * ugly[p2];
            p2++;
        }
        if (min == product3) {
            product3 = 3 * ugly[p3];
            p3++;
        }
        if (min == product5) {
            product5 = 5 * ugly[p5];
            p5++;
        }
    }
    // 返回第 n 个丑数
    return ugly[n];
}
```





















