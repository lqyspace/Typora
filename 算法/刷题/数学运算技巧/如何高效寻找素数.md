# 如何高效寻找素数

素数的定义看起来很简单，如果一个只能被1和它本身整除，那么他就是一个素数。

比如力扣204.[计算质数](https://leetcode.cn/problems/count-primes/)，让你写一个这样的函数：

```java
int countPrimes(int n) /// 返回区间[2, n)中有几个素数
    
// 比如 countPrimes(10) 返回4
// 因为 2,3，5,7 是素数
```

传统的代码应该是这样写的：

```java
int countPrimes(int n){
    int count = 0;
    for(int i=2; i<n; i++){
        if (isPrime(i)) count++;
    }
    return count;
}

boolean isPrime(int n){
    for (int i=2; i<n; i++)
        if(n%i)
            return false;
    return true;
}
```

这个代码时间复杂度是 `O(n^2)`，问题很大。**首先你用 isPrime 函数来辅助的思路就不够高效；而且就算你要用 isPrime 函数，这样写算法也是存在计算冗余的**。

先来简单说下**如果你要判断一个数是不是素数，应该如何写算法**。只需稍微修改一下上面的 isPrime 代码中的 for 循环条件：

```java
boolean isPrime(int n) {
    for (int i = 2; i * i <= n; i++)
        ...
}
```

换句话说，`i`不需要遍历到 `n`，而只需要遍历到 `sqrt(n)`即可。举个例子：

```java
12 = 2 × 6
12 = 3 × 4
12 = sqrt(12) × sqrt(12)
12 = 4 × 3
12 = 6 × 2
```

可以看到，后两个乘积就是前面两个反过来，反转临界点就在 `sqrt(n)`。

换句话说，如果在 `[2,sqrt(n)]` 这个区间之内没有发现可整除因子，就可以直接断定 `n` 是素数了，因为在区间 `[sqrt(n),n]` 也一定不会发现可整除因子。

现在，`isPrime` 函数的时间复杂度降为 O(sqrt(N))，**但是我们实现 `countPrimes` 函数其实并不需要这个函数**，以上只是希望读者明白 `sqrt(n)` 的含义，因为等会还会用到。



# 高效实现 `countPrimes`

接下来介绍的方法叫做「**素数筛选法**」，这个方法是古希腊一位名叫埃拉托色尼的大佬发明的，我们在中学的教课书上见过他的大名，因为他就是第一个通过物体的影子正确计算地球周长的人，被推崇为「地理学之父」。

回到正题，素数筛选法的核心思路是和上面的常规思路反着来：

首先从 2 开始，我们知道 2 是一个素数，那么 2 × 2 = 4, 3 × 2 = 6, 4 × 2 = 8… 都不可能是素数了。

然后我们发现 3 也是素数，那么 3 × 2 = 6, 3 × 3 = 9, 3 × 4 = 12… 也都不可能是素数了。

`Wikipedia` 的这个 `GIF` 很形象：

![img](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306161508848.gif)



看到这里，你是否明白了排除法的逻辑了呢？先看第一版的代码，后期继续优化！

```java
int countPrimes(int n){
    int count = 0;
    boolean[] isPrime = new boolean[n];
    // 将数组初始化为 true
    Arrays.fill(isPrime, true);
    
    for(int i=2; i<n; i++){
        if(isPrime[i])
            // i的整数倍一定不是素数
            for(int j=2*i; j<n; j+=i)
                isPrime[j] = false;
    for(int i=2; i<n; i++)
        if(isPrime[i])count++;
    
    return count;
    }
}
```

如果上面这段代码你能够理解，那么你已经掌握了整体思路，但是还有两个细微的地方可以优化。

首先，回想刚才判断一个数是否是素数的 `isPrime` 函数，由于因子的对称性，其中的 for 循环只需要遍历 `[2,sqrt(n)]` 就够了。这里也是类似的，我们外层的 for 循环也只需要遍历到 `sqrt(n)`：

```java
for (int i = 2; i * i < n; i++) 
    if (isPrime[i]) 
        ...
```

除此之外，很难注意到内层的 for 循环也可以优化。我们之前的做法是：

```java
for (int j = 2 * i; j < n; j += i) 
    isPrime[j] = false;
```

这样可以把 `i` 的整数倍都标记为 `false`，但是仍然存在计算冗余。

比如可知：

```java
2*2 2*3 2*4 2*5 2*6 2*7 2*8 2*9
(3*2) 3*3 3*4 3*5 3*6 3*7 3*8 3*9
(4*2 4*3) 4*4 4*5 4*6 4*7 4*8 4*9
(5*2 5*3 5*4) 5*5 5*6 5*7 5*8 5*9
```

因此为了避免计算冗余，我们可以让 `j`不从2开始，而是从 `i`开始。

```java
for (int j = i * i; j < n; j += i) 
    isPrime[j] = false;
```

这样，素数计数的算法就高效实现了，其实这个算法有一个名字，叫做 Sieve of Eratosthenes。看下完整的最终代码：

```java
int countPrimes(int n){
    int count = 0;
    boolean[] isPrime = new int[n];
    Arrays.fill(iPrime, true);
    for (int i=2; i*i<n; i++){
        if(isPrime[i]){
            for(int j=i*i; j<n; j+=i){
                isPrime[j] = false;
            }
        }
    }
    
    for(int i=2; i<n; i++)
        if(isPrime[i])
        	count++;
    
    return count;
}
```

