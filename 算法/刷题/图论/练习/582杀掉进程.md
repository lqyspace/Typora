# 582杀掉进程

[力扣582杀掉进程](https://leetcode.cn/problems/kill-process/description/?show=1)，难度中等

![image-20230729112932701](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202307291129792.png)

说实话，这道题感觉没什么技术含量，只要能想到如何构建一个邻接表，然后使用BFS进行遍历即可。

官方代码：

```java
class Solution {
    public List<Integer> killProcess(List<Integer> pid, List<Integer> ppid, int kill) {
        int n = pid.size();
        // 有向图，邻接表
        HashMap<Integer, List<Integer>> graph = new HashMap<>();
        for(int i=0; i<n; i++){
            int father = ppid.get(i);
            int son = pid.get(i);
            graph.putIfAbsent(father, new ArrayList<>());
            graph.get(father).add(son);
        }

        // 删除
        List<Integer> res = new ArrayList<>();
        // BFS：对列
        Queue<Integer> q = new LinkedList<>();
        q.offer(kill);
        while(!q.isEmpty()){
            int cur = q.poll();
            res.add(cur);
            // 获取子进程
            if(graph.containsKey(cur))
                q.addAll(graph.get(cur));
        }
        return res;
    }
}
```

我自己写的代码：

```java
class Solution {
    public List<Integer> killProcess(List<Integer> pid, List<Integer> ppid, int kill) {
        int n = pid.size();
        // 有向图，邻接表
        HashMap<Integer, List<Integer>> graph = new HashMap<>();
        for(int i=0; i<n; i++)
            graph.put(pid.get(i), new ArrayList<>());
        
        for(int i=0; i<n; i++){
            int father = ppid.get(i);
            int son = pid.get(i);
            if(father != 0)
            	graph.get(father).add(son);
        }

        // 删除
        List<Integer> res = new ArrayList<>();
        // BFS：对列
        Queue<Integer> q = new LinkedList<>();
        q.offer(kill);
        while(!q.isEmpty()){
            int cur = q.poll();
            res.add(cur);
            // 获取子进程
            List<Integer> tmp = graph.get(cur);
            for(int id : tmp)
                q.offer(id);
        }
        return res;
    }
}
```

注意：**我自己的写法 和 官方的写法 有细微的差别：**

1、我在构建邻接表的时候，给pid中的每个节点，都声明了一个空链表；而官方的写法是：如果存在father与son的对应关系，则添加到map中。

2、我的写法：在后续使用for遍历tmp时不会报错，但是如果我将构建邻接表的方式换成官方的，然后使用for进行遍历时会报空指针异常，这是因为末端子进程已经没有子进程了，所以并不存在末端子进程的father与son的对应关系，当使用graph.get(末端子进程id)时得到的是一个null。

3、之所以说我的写法不会报错，是因为我在构建邻接表时，给每个子进程都声明了一个空链表，所以当使用graph.get(末端子进程id)时得到的是一个空链表，因此并不会报错。