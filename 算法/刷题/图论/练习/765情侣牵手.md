# 765情侣牵手

[力扣765情侣牵手](https://leetcode.cn/problems/couples-holding-hands/description/?show=1)，难度困难

![image-20230729171402730](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202307291714794.png)

说说解题思路：

这道题主要是利用并查集的原理。那是怎么办到的呢？

我们知道，坐在一起的两个情侣，编号肯定是一奇一偶，比如0,1或者2,3；而这两对情侣的编号，在每对情侣中，用情侣的编号除以2，结果是一样的，比如0/2=0, 1/2=0；因此我们可以说，每对情侣实际上是在一个连通分量里。

但是，如果情侣坐错了位置，比如0号和2号坐到了一起，1号和4号坐到了一起，3号和五号坐到了一起，那么还利用并查集的原理，0/2=0, 2/2=1，因此0和1被分到一个连通分量里。而1/2=0,4/2=2，因此0和2被分到一个连通分量里；而3/2=1，5/2=2，因此1和2被分到一个连通分量里，由此可以，这三对情侣都是相互连通的，都在一个连通分量里。

因此，我们如果将`N`对情侣看做图中`N`个节点；对于每对相邻的位置，如果是第`i`对与第`j`对坐到了一起，则在`i`号节点与`j`号节点之间连接了一条边，代表需要交换这两对情侣的位置。

如果图中形成了一个大小为`k`的环：$i->j->k->...->l->i$，则我们沿着环的方向，先交换 `i，j` 的位置，再交换 `j，k` 的位置，以此类推。在进行了 `k-1`次交换后，这`k`对情侣就能够彼此牵手了。

要求最少交换次数。假设一共有N对情侣，逻辑上连在一起的情侣，包括坐错位置和坐对位置，分别有 $N_1,N_2,...,N_n$对，这里n是并查集连通分量的个数，代表有n个连通分量。并且$N_1+N_2+\cdots +N_n=N$。在每一个连通分量里，我们都需要至少 $N_1-1,N_2-1,\cdots ,N_n-1$次交换才能彼此牵手。

![image.png](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202307291739218.png)

这种规律对于初始的时候就正确做在一起的情侣也是有效的，因为已经坐在一起的情侣的并查集的连通分量里就只有一个节点，无需交换，此时1-1=0。综上所述：让所有情侣都能牵手成功的的次数至少为：

$(N_1-1)+(N_2-1)+\cdots +(N_n-1)=N-n$

故：至少交换次数=所有情侣的对数-并查集里连通分量的个数

代码如下：

```java
class Solution {
    public int minSwapsCouples(int[] row) {
		// 情侣的对数
        int N = row.length / 2;
        UF uf = new UF(N);
        for(int i=0; i<row.length; i+=2){
            uf.union(row[i]/2, row[i+1]/2);
        }
        return N - uf.count();
    }
}

class UF{
    private int count;
    private int[] parent;
    public UF(int n){
        this.count = n;
        this.parent = new int[n];
        for(int i=0; i<n; i++)
            this.parent[i] = i;
    }
    
    public void union(int p, int q){
        int rootP = find(p);
        int rootQ = find(q);
        if(rootP == rootQ)
            return;
        this.parent[rootP] = rootQ;
        this.count--;
    }
    
    public boolean connected(int p, int q){
        int rootP = find(p);
        int rootQ = find(q);
        return rootP == rootQ;
    }
    
    public int find(int x){
        if(this.parent[x] != x)
            this.parent[x] = find(this.parent[x]);
        return this.parent[x];
    }
    
    public int count(){
        return this.count;
    }
}
```

时间复杂度：由于find函数的路径压缩，导致时间降为O(1)，所以union函数的时间复杂度为O(1)，

所以总的时间复杂度是O(N)

空间复杂度：并查集底层使用数组长度为$N/2$，所以O(N)。





当然，这道题还可以使用广度优先搜索遍历：

起初，我们将每个节点都标记为未访问，并遍历图中的每个节点。如果发现一个为访问的节点，就从该节点出发，沿着图中的边，将其余的未访问的节点都标记为已访问，并同时统计标记的次数。当遍历终止时，标记的数量就是连通分量的大小。

```java
class Solution{
    public int minSwapsCouples(int[] row) {
    	int n = row.length;
        int tot = n/2;
        List<Integer> graph = new LinkedList[tot];
        for(int i=0; i<tot; i++)
            graph[i] = new LinkedList<>();
        for(int i=0; i<n; i+=2){
            int l = row[i]/2;
            int r = row[i+1]/2;
            if(l!=r){
                graph[l].add(r);
                graph[r].add(l);
            }
        }
        
        boolean[] visited = new boolean[tot];
        int res = 0;
        for(int i=0; i<tot; i++){
            if(visited[i])
                continue;
            Queue<Integer> q = new LinkedList<>();
            visited[i] = true;
            q.offer(i);
            int cnt = 0;
            
            while(!q.isEmpty()){
                int cur = q.poll();
                cnt++;
                
                for(int y : graph[cur]){
                    if(!visited[y]){
                        visited[y] = true;
                        q.offer(y);
                    }
                }
            }
            res += (cnt-1);
        }
        return res;
    }
}
```















