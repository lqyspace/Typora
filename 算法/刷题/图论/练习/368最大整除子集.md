# 368最大整除子集

[力扣368](https://leetcode.cn/problems/largest-divisible-subset/description/?show=1)，难度中等

![image-20230728204952871](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202307282049936.png)



**基本思路：**

看到这个题目，我的第一思路就是用 **Union_Find** 代码，把所有可以相互整除的数字放进一个连通分量里，最后看看哪个连通分量的数字最多。不过仔细想想，比如：[1, 2, 3] 这些数字都放在一个连通分量里，因为都可以整除1，当时2并不能整除3，所以这个思路是错的。

这道题说到底就是一个穷举问题，所以我的第二个思路是复用 [一文秒杀所有排列组合子集问题](https://labuladong.github.io/article/fname.html?fname=子集排列组合) 中讲过的元素可重不可复选的组合问题，只要把代码复制过来稍加修改判定逻辑即可完成这道题。不过看到数据规模比较大，阶乘级别的复杂度肯定扛不住，所以也只能作罢。

再想想，在数组中寻找一个符合特定条件的子集，其实就是找一个子序列，那么如果我把数组排序，这道题就变成了 [动态规划设计：最长递增子序列](https://labuladong.github.io/article/fname.html?fname=动态规划设计：最长递增子序列)。

排序很重要，假设一个符合题目要求的子集 `[1,2,4]`，那么由于我排了序，如果想扩充这个集合，接下来我只要到一个能够整除 4 的数就行了，比如 8。我不用考虑前面的数字了，因为只要能整除最大的 4 就一定能整除别的。

这样一来，题目就变成了：**寻找一个最长递增子序列，且要求每个元素都能够整除前面那个元素**。

然后按照 [动态规划设计：最长递增子序列](https://labuladong.github.io/article/fname.html?fname=动态规划设计：最长递增子序列) 中定义 `dp` 数组的方式，用`dp[i]` 记录以 `nums[i]` 结尾的最长递增子序列，就能解决这道题了。

```java
class Solution {
    public List<Integer> largestDivisibleSubset(int[] nums) {
        int n = nums.length;
        // 定义：dp[i] 表示以 nums[i] 这个数结尾的最长符合要求子序列的长度
        List<Integer>[] dp = new LinkedList[n];
        // 排序
        Arrays.sort(nums);
        // 初始化
        for(int i=0; i<n; i++)
            dp[i] = new LinkedList<>();
        // base case
        dp[0].add(nums[0]);

        for(int i=1; i<n; i++){
            int maxLen = 0, index = -1;
            // 在 nums[0..i-1] 中寻找那个 nums[i] 能接到结尾的最长子序列
            for(int j=0; j<i; j++){
                if(nums[i] % nums[j] == 0 && dp[j].size() > maxLen){
                    maxLen = dp[j].size();
                    index = j;
                }
            }
            // nums[0..i-1] 中最长的那个子序列，再加上 nums[i]，
            // 就是 nums[0..i] 最长的子序列
            if(index != -1)
                dp[i].addAll(dp[index]);
            dp[i].add(nums[i]);
        }
        
        List<Integer> res = dp[0];
        for(int i=1; i<n; i++)
            if(res.size() < dp[i].size())
                res = dp[i];
        return res;
    }
}
```

