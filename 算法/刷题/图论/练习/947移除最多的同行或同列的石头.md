# 947移除最多的同行或同列的石头

[力扣947移除最多同行或同列的石头](https://leetcode.cn/problems/most-stones-removed-with-same-row-or-column/description/?show=1)，难度中等

![image-20230730125132317](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202307301251420.png)

这道题的思路和 [765情侣牵手](https://leetcode.cn/problems/couples-holding-hands/description/?show=1) 的思路差不多：

**连通同行或者同列的石头到一个连通分量里，可以发现，用总石头数减去连通分量个数=需要移除的石头的个数**

> 我们知道，在一个连通分量里，所有的石头都是连通的，也就是说，这些石头要么处于同行，要么处于同列，因此最后移除肯定只剩下1个石头，也就是说需要移除k-1个石头（假设k为一个连通分量里的节点个数）。
>
> 如果有m个连通分量的话，那么就有 `n-m`个石头需要移除

代码如下：

```java
class Solution {
    public int removeStones(int[][] stones) {
        int n = stones.length;
        UF uf = new UF(n);

        // 分别记录同一行同一列各有多少节点
        HashMap<Integer, ArrayList<Integer>> rowsTree = new HashMap<>();
        HashMap<Integer, ArrayList<Integer>> colsTree = new HashMap<>();

        for(int[] edge : stones){
            int from = edge[0], to = edge[1];
            rowsTree.putIfAbsent(from, new ArrayList<>());
            colsTree.putIfAbsent(to, new ArrayList<>());

            rowsTree.get(from).add(to);
            colsTree.get(to).add(from);
        }
        // 记录同一行同一列的点的坐标
        HashMap<Integer, Integer> codeToIndex = new HashMap<>();
        for(int i=0; i<n; i++)
            codeToIndex.put(stones[i][0]*10001+stones[i][1], i);

        for(int[] edge : stones){
            int row = edge[0], col = edge[1];
            // 获取当前节点的编号
            int curID = codeToIndex.get(row*10001+col);
            //查看同一行有哪些节点
            for(int colNum : rowsTree.get(row)){
                // 获取同一行的其他节点
                if(colNum == col)
                    continue;
                // 获取同行相邻接点的编号
                int neiID = codeToIndex.get(row*10001+colNum);
                uf.union(curID, neiID);
            }

            // 查看同列的节点
            for(int rowNum : colsTree.get(col)){
                if(rowNum == row)
                    continue;
                // 获取同列节点的编号
                int neiCol = codeToIndex.get(rowNum*10001+col);
                uf.union(curID, neiCol);                               
            }
        }
        return n - uf.count();            
    }
}

class UF{
    private int count;
    private int[] parent;
    public UF(int n){
        this.count = n;
        this.parent = new int[n];
        for(int i=0; i<n; i++)
            this.parent[i] = i;
    }

    public void union(int p, int q){
        int rootP = find(p);
        int rootQ = find(q);
        if(rootP == rootQ)
            return;
        this.parent[rootP] = rootQ;
        this.count--;
    }

    public boolean connected(int p, int q){
        int rootP = find(p);
        int rootQ = find(q);
        return rootP == rootQ;
    }

    public int find(int x){
        if(this.parent[x] != x)
            this.parent[x] = find(this.parent[x]);
        return this.parent[x];
    }

    public int count(){
        return this.count;
    }
}
```

这道题可能还有其他的变体，比如如果询问最少移除的石头数，那么我们要移除的就不是同行或同列的石头，而是相邻的石头。