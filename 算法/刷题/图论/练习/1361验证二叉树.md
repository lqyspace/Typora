# 验证二叉树

[力扣1361验证二叉树](https://leetcode.cn/problems/validate-binary-tree-nodes/)，难度中等

![image-20230724221930014](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202307242219098.png)

解决本题时，关键点：

1、要查看每个节点的入度，入度为0的节点即为根节点，判断根节点的个数，如果根节点的个数大于1，则说明不是一颗合法的数

2、树实则是一个无环的连通图，我们需要检测图中是否存在环，以及看图的连通分量的个数。

3、判断一棵树中是否存在环，即需要检测一个子节点是否存在多个父节点，或者是一个父节点存在两个相同的孩子

4、如果连通分量的个数大于1，说明也不是一颗合法的树。

因此有以下代码：

```java
class Solution {
    /**
        要想成为一颗合法的树，需满足下面三个条件：
        1、连通分量为1
        2、根的个数为1，即入度为1的节点只能有一个
        3、不能出现环
     */
    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {
        UF uf = new UF(n);
        // 判断每个节点的入度，找出根节点，只有根节点的入度为0
        int[] indegree = new int[n];
        for(int i=0; i<n; i++){
            int left = leftChild[i];
            int right = rightChild[i];
            if(left!=-1)
                indegree[left]++;
            if(right!=-1)
                indegree[right]++;
        }
        
        int rootCount = 0;
        for(int i=0; i<n; i++)
            if(indegree[i] == 0)
                rootCount++;
        if(rootCount>1)// 如果根的个数大于1，那么一定不是一颗合法的数
            return false;

        for(int i=0; i<n; i++){
            int left = leftChild[i];
            int right = rightChild[i];
            if(right!=-1){
                // 如果i和right已经连通，此时再将i和right进行连通，则说明存在一个子节点两个父节点的现象
                if(uf.connected(right, i))
                    return false;
                uf.union(i, right);
            }
            if(left!=-1){
                // 如果i和right已经连通，此时再将i和right进行连通，则说明存在一个子节点两个父节点的现象
                if(uf.connected(left, i))
                    return false;
                uf.union(i, left);
            }
        }
        // 如果连通分量大于1，则说明不是一颗合法的树
        if(uf.count()>1)
            return false;
        return true;
    }
}

class UF{
    private int count;
    private int[] parent;
    public UF(int n){
        this.count = n;
        parent = new int[n];
        for(int i=0; i<n; i++)
            parent[i] = i;
    }

    public void union(int q, int p){
        int rootP = find(p);
        int rootQ = find(q);
        if(rootP == rootQ)
            return;
        parent[rootP] = rootQ;
        this.count--;
    }

    public boolean connected(int p, int q){
        int rootP = find(p);
        int rootQ = find(q);
        return rootP == rootQ;
    }

    public int find(int x){
        if(parent[x] != x)
            parent[x] = find(parent[x]);
        return parent[x];
    }

    public int count(){
        return this.count;
    }
}
```