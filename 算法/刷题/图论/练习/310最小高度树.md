# 310最小高度数

[力扣310最小高度树](https://leetcode.cn/problems/minimum-height-trees/)，难度中等

![image-20230728181055272](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202307281810422.png)

这道题其实没有用上动态连通性来做。

解题思路：

1、首先，将题中的 edges 转换成邻接表

2、然后，我们从叶子节点开始，一层一层的删除叶子结点（每删除一层叶子结点，就会产生新的叶子节点），直到剩下的节点数小于等于2，之所以是2而不是1个，是因为如果输入的这幅图两边完全对称，可能出现两个节点都作为根的情况。

![img](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202307281820992.jpeg)

注意：其实这种图并不算严格意义上的树，只不过题目是这么规定的：只要是一颗不存在环的连通图就是一棵树。

3、最后剩下的节点，就是我们要找的最小高度树的根节点。

如何一层一层删除所有的叶子节点呢，只需要借助 **BFS算法** ，借助一个队列即可。

肯定有读者会问了，这种题目是怎么想出来的？实际上这种题可以理解为类似冒泡排序这种套路的题：==找最近叶子节点就从根节点开始BFS，找根节点就从叶子结点开始BFS==，你记住这两种处理方式就好，一般不会有什么变体。

代码解法：

```java
class Solution{
    public List<Integer> findMinHeightTrees(int n, int[][] edges) {
        // 1.把edges转成邻接表
        List<List<Integer>> graph = new ArrayList<>();
        for(int i=0; i<n; i++)
            graph.add(new ArrayList<>());
        
        for(int[] edge : edges){
            graph.get(edge[0]).add(edge[1]);
            graph.get(edge[1]).add(edge[0]);
        }
        
        // 2. 收集叶子结点
        List<Integer> leaves = new ArrayList<>();
        for(int i=0; i<n; i++)
            if(graph.get(i).size()==1)
                leaves.add(i);
        
        if(n==1){
            List<Integer> t = new ArrayList<>();
            t.add(0);
            return t;
        } 
        if(n==0) return new ArrayList<>();
        
        // 3.删除叶子结点，更新大小
        int remainNodeNum = n;
        // 记住：这个地方不能用leaves.size()>2来判断，加入一课多层树恰好由两个叶子结点呢，那这个条件就是错的
        while(remainNodeNum > 2){
            // 删除叶子结点数
            remainNodeNum -= leaves.size();
            // 存储新的叶子结点
            List<Integer> newLeaves = new ArrayList<>();
            for(Integer leaf: leaves){// 注意这个地方得用引用类型，因为ArrayList<>()的接口中有remove()方法重载，传入int类型表索引，传入引用类型表对象。
                // 将这个叶子结点的邻居节点的度数-1
                int neighbor = graph.get(leaf).get(0);
                graph.get(neighbor).remove(leaf);
                // 如果邻居节点的度数为1，说明此时它也是叶子节点
                if(graph.get(neighbor).size()==1)
                    newLeaves.add(neighbor);
            }
            // 将新的叶子结点替换一下
            leaves = new ArrayList<>(newLeaves);
        }
        return leaves;
    }
}
```

















