# 1926迷宫中离入口最近的出口

[力扣1926迷宫中离入口最近的出口](https://leetcode.cn/problems/nearest-exit-from-entrance-in-maze/description/)，难度中等

![image-20230801225223332](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308012252418.png)

这个题跟 [力扣286墙与门](https://leetcode.cn/problems/walls-and-gates/description/?show=1)，有点相像。

解题思路一样，使用BFS算法即可：

我自己的解题代码如下：

```java
class Solution {
    public int nearestExit(char[][] maze, int[] entrance) {
        int m = maze.length, n = maze[0].length;
        int[][] dirs = new int[][]{{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
        Queue<State> q = new LinkedList<>();
        q.offer(new State(entrance[0], entrance[1], 0));

        int steps = Integer.MAX_VALUE;
        while(!q.isEmpty()){
            State curNode = q.poll();
            int curX = curNode.x;
            int curY = curNode.y;
            int curDepth = curNode.depth;

            if((curX==m-1 || curY==n-1 || curX==0 || curY==0) && !(curX==entrance[0] && curY==entrance[1]))
                steps = Math.min(steps, curDepth);

            for(int k=0; k<4; k++){
                int x = curX + dirs[k][0];
                int y = curY + dirs[k][1];
                if(x<0 || y<0 || x>=m || y>=n || maze[x][y] != '.')
                    continue;
                maze[x][y] = '+';
                q.offer(new State(x, y, curDepth+1));
            }
        }
        return steps==Integer.MAX_VALUE? -1: (steps==0? -1: steps);
    }
}

class State{
    int x, y;
    int depth;
    public State(int x, int y, int depth){
        this.x = x;
        this.y = y;
        this.depth = depth;
    }
}
```

总结：

- 在我的代码中，我做了如下处理：
  - 我声明了一个State对象，用于存储点坐标以及该点的深度；其实后期想想，完全没有必要
- 其实，该题已经给了起点，所以我是靠这个起点往四周遍历，同时我为了不让他走回头路，我将 `maze[x][y]='+'`处理。我这个处理方式其实适合单起点问题，对于多起点问题（比如：286墙与门），我的方法并不适合。因为多起点问题，多个起点可能会走部分相同的路径，如果某个起点把 `maze[x][y]`设置为 `+`，就会导致后期其他的起点节点可能走不了这条路径。



接下来看看官方的解法：

```java
class Solution {
    public int nearestExit(char[][] maze, int[] entrance) {
        int m = maze.length, n = maze[0].length;
        int[][] dirs = new int[][]{{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
        Queue<int[]> q = new LinkedList<>();
        q.offer(new int[]{entrance[0], entrance[1]});
        boolean[][] visited = new boolean[m][n];
		visited[entrance[0]][entrance[1]] = true;
        
        int steps = 0;
        while(!q.isEmpty()){
            int sz = q.size();
            steps++;
			// 扩散当前队列中的所有节点
            for(int i=0; i<sz; i++){
                int[] cur = q.poll();
                // 将每个节点都向四周进行扩散
                for(int[] dir: dirs){
                    int x = cur[0] + dir[0];
                    int y = cur[1] + dir[1];
                    if(x<0 || y<0 || x>=m || y>=n || visited[x][y] || maze[x][y] == '+')
                        continue;
                    if(x == 0 || y==0 || x==m-1 || y==n-1)
                        return steps;// 说明已经走到出口
                    visited[x][y] = true;
                    q.offer(new int[]{x, y});
                }
            }
        }
        return -1;
    }
}
```

