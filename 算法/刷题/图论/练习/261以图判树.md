# 261以图判树

[力扣261以图判树](https://leetcode.cn/problems/graph-valid-tree/description/)，难度中等

![image-20230728154757718](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202307281547871.png)

这道题其实很简单，但是做起来我们往往不能全部都AC通过。主要是有一些细节问题需要我们仔细把握。

我们知道，如果需要将一个图判定是否为一颗合法的树，那么就一定要满足下面三个条件：

1、图中不能存在环，如果存在环，则一个不是一颗合法的树

2、运用动态连通性，得到的连通分量一个是1

3、因为父节点一定是指向子节点的，所以根节点只能有一个，即入度为0的节点只能有一个

比如[力扣1361验证二叉树](https://leetcode.cn/problems/validate-binary-tree-nodes/)，就很好运用了这三个条件。

但是这个题与 [力扣1361验证二叉树](https://leetcode.cn/problems/validate-binary-tree-nodes/) 的题还有一些区别，因为这个题里面的边并没有明确指定方向，即我们并不能确定谁是父节点，谁是子节点，比如：n=3, [[1, 0], [2, 0]]这张图其实也是符合条件的，它是一颗倒树，也是一棵合法的树。

因此对于本题而言，只需要满足前两个条件即可。

以后遇到类似的题一定要千万注意。

代码如下：

```java
class Solution {
    /**
        一般情况：判断一颗合法的树的条件如下：
        1、入度为0的节点只能有一个
        2、连通分量只能有一个
        3、不能存在环

        但是此题有一个需要注意，这道题给的示例里面并没有指明方向。正常来说，一棵树肯定是父节点指向子节点，但是本题中并没有指明边的方向，
        对于没有指明方向的题，只有满足是一棵合法的树即可：1、没有环；2、连通分量为1，至于找入度为0的点用不上。因为本体并没有指明方向，不用找根节点，比如：n=3，[[1, 0], [2, 0]]也是符合条件的。所以以后做题需要注意
     */
    public boolean validTree(int n, int[][] edges) {
        // 注意：题目给的边的个数 和 节点的个数n不一定相等
        // 使用动态连通性来做：并查集
        UF uf = new UF(n);
        for(int[] edge : edges){
            if(uf.connected(edge[0], edge[1]))
                return false;
            uf.union(edge[0], edge[1]);
        }
        if(uf.count()>1)
            return false;
        return true;
    }
}

class UF{
    private int count;
    private int[] parent;
    public UF(int n){
        this.count = n;
        this.parent = new int[n];
        for(int i=0; i<n; i++)
            parent[i] = i;
    }

    public void union(int p, int q){
        int rootP = find(p);
        int rootQ = find(q);
        if(rootP == rootQ)
            return;
        parent[rootP] = rootQ;
        this.count--;
    }

    public boolean connected(int p, int q){
        int rootP = find(p);
        int rootQ = find(q);
        return rootP == rootQ;
    }

    public int find(int x){
        if(parent[x] != x)
            parent[x] = find(parent[x]);
        return parent[x];
    }

    public int count(){
        return this.count;
    }
}
```

