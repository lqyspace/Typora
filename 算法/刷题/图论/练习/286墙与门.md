# 286墙与门

[力扣286墙与门](https://leetcode.cn/problems/walls-and-gates/?show=1)，难度中等

![image-20230801222327796](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308012223883.png)

这道题，典型的可以用BFS算法框架解题。

我们知道BFS可以解决节点所在层数问题，以及最小高度问题，因此，这道题便是最小高度问题的演化。

BFS算法的特色就是一旦遍历到了一个点，那么BFS执行的步数就是最近距离。

本题可以理解为每一个门都是一个起点，所以我们要把门的坐标都放在队列里开始执行BFS算法，当第一次遍历到房间时，所走的步数就是该房间到最近的的门的距离。

代码详情如下：

```java
class Solution{
    public void wallsAndGates(int[][] rooms) {
        final int ROOM = Integer.MAX_VALUE;
        final int GATE = 0;
        
        int m = rooms.length, n = rooms[0].length;
        Queue<int[]> q = new LinkedList<>();
        for(int i=0; i<m; i++)
            for(int j=0; j<n; j++)
                if(rooms[i][j] == GATE)
                    q.offer(new int[]{i, j});
        int[][] dirs = new int[][]{{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
        // 对所有进行遍历，相当于所有的门都是起点
        while(!q.isEmpty()){
            int[] cur = q.poll();
            int curX = cur[0], curY = cur[1];
            for(int k=0; k<4; k++){
                int nx = curX + dirs[k][0];
                int ny = curY + dirs[k][1];
                if(nx<0 || ny<0 || nx>=m || ny>=n || rooms[nx][ny]!=ROOM)
                    continue;
                // 这个地方注意一下，为什么说这个地方是合理的呢？
                // 第一，这个加法可以有效避免走回头路
                // 第二，根据队列的遍历规则，会让每个门都先向前走一格，不会出现一个门连着走好几格的现象
                rooms[nx][ny] = rooms[curX][curY] + 1;
                q.offer(new int[]{nx, ny});
            }
        }
    }
}
```

