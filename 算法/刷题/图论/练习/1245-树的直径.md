# 1245-树的直径

[1245-树的直径](https://leetcode.cn/problems/tree-diameter/description/?show=1)，难度中等

![image-20231115170501718](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202311151705704.png)



![image-20231115170557044](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202311151705099.png)

题解1：使用**两次BFS**算法。首先，可以肯定的是，从图中的任何节点开始，如果我们进行BFS遍历，我们最后访问的节点一定是极端节点之一。

作为极端节点，它应该是远离图中任何其他节点的节点之一。

给定任何节点，从该节点开始的最长距离必须以一个外围极端节点结束。

![image-20231115220644738](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202311152206798.png)

一旦我们确定了极端外围节点之一，然后我们可以再次应用BFS算法遍历。先从已确定的极端外围节点开始。在第二次BFS遍历结束时，我们将登陆在另一个极端外围节点上。根据定义，我们遍历的距离就是图的直径。

```java
class Solution {
    public int treeDiameter(int[][] edges) {
		int n = edges.length;
        List<Integer>[] graph = new ArrayList[n+1];
        for(int i=0; i<=n; i++){
            graph[i] = new ArrayList<>();
        }
        for(int[] edge: edges){
            graph[edge[0]].add(edge[1]);
            graph[edge[1]].add(edge[0]);
        }
        // 找到第一个极端外围点
        int[] f_node = bfs(0, graph);
        // 找到第二个外围点
        int[] s_node = bfs(f_node[0], graph);
        return s_node[1];
    }
    public int[] bfs(int start, List<Integer>[] graph){
        int n = graph.length;
        boolean[] visited = new boolean[n];
        Queue<Integer> queue = new ArrayDeque<>();
        queue.offer(start); visited[start] = true;
        int lastNode = start, distance = -1;
        while(!queue.isEmpty()){
            Queue<Integer> q = new ArrayDeque<>();
            while(!queue.isEmpty()){
                int curNode = queue.poll();
                for(int neighbor: graph[curNode]){
                    if(!visited[neighbor]){
                        visited[neighbor] = true;
                        q.offer(neighbor);
                        lastNode = neighbor;
                    }
                }
            }
            distance += 1;
            queue = q;
        }
        return new int[]{lastNode, distance};
    }
}
```

