# 542-01矩阵

[力扣542-01矩阵](https://leetcode.cn/problems/01-matrix/description/?show=1)，难度中等

![image-20230802070339716](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308020703784.png)

这道题有两种思路：第一种解法是把1全放进一个队列里，然后运用BFS算法框架向四周扩散，寻找该点四周离得最近的一个0。

代码如下：

```java
class Solution{
    public int[][] updateMatrix(int[][] mat){
        int m = mat.length, n = mat[0].length;
        int[][] res = new int[m][n];
        for(int i=0; i<m; i++)
            Arrays.fill(res[i], -1);
        Queue<int[]> q = new LinkedList<>();
        int[][] dirs = new int[][]{{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
        
        for(int i=0; i<m; i++){
            for(int j=0; j<n; j++){
                if(mat[i][j] == 1)
                    q.offer(new int[]{i, j});
                else
                    res[i][j] = 0;
            }
        }
        int steps = -1;
        while(!q.isEmpty()){
            int[] cur = q.poll();
            steps++;
            int x = cur[0], y = cur[1];
            for(int k=0; k<4; k++){
                int nx = x + dirs[k][0];
                int ny = y + dirs[k][1];
                if(nx<0 || ny<0 || nx>=m || ny>=n || res[nx][ny]==0)
                    continue;
                if(mat[nx][ny]==0){
                    // 很有问题，这种做法有点麻烦
                    // 所以换一个思路
                    // 从0开始向四周扩散
                }
            }
        }       
    }
}
```

另一种解法：从0开始向四周扩散，好处是每一个格子都可以利用四周的格子进行+1

```java
class Solution{
    public int[][] updateMatrix(int[][] mat){
        int m = mat.length, n = mat[0].length;
        int[][] res = new int[m][n];
        for(int i=0; i<m; i++) // 初始化，可以避免走回头，也可以存储值
            Arrays.fill(res[i], -1);
        Queue<int[]> q = new LinkedList<>();
        int[][] dirs = new int[][]{{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
        
        for(int i=0; i<m; i++){
            for(int j=0; j<n; j++){
                if(mat[i][j] == 0){
                    q.offer(new int[]{i, j});
                    res[i][j] = 0;
                }
            }
        }
        
        while(!q.isEmpty()){
            int[] cur = q.poll();
            int x = cur[0], y = cur[1];
            for(int k=0; k<4; k++){
                int nx = x + dirs[k][0];
                int ny = y + dirs[k][1];
                if(nx<0 || ny<0 || nx>=m || ny>=n || res[nx][ny]!=-1)
                    // 这个地方应该写 res[nx][ny]!=-1，说明这个地方（nx，ny）有数了，那你还更新个屁呀
                    // 不用再更新值了，只有res[nx][ny]==-1的时候，说明这个地方还没值，所以需要更新
                    // 如果这个你写了res[nx][ny]==0，那就说明除了0以外的其他情况都可以往下执行，这样很容易导致走回头路。
                    continue;
                res[nx][ny] = res[x][y] + 1;
                q.offer(new int[]{nx, ny});
            }
        } 
        return res;
    }
}
```

看看官方是咋写的：

```java
class Solution {
    public int[][] updateMatrix(int[][] mat) {
        int m = mat.length, n = mat[0].length;
        int[][] res = new int[m][n];
        int[][] dirs = new int[][]{{1, 0}, {0, 1}, {0, -1}, {-1, 0}};
        // 初始化填充 -1，代表为计算
        // 待会可以用来判断坐标是否已经计算过，避免重复遍历
        for(int i=0; i<m; i++)
            Arrays.fill(res[i], -1);
        
        // 将元素为0的加入队列
        Queue<int[]> q = new LinkedList<>();
        for(int i=0; i<m; i++)
            for(int j=0; j<n; j++)
                if(mat[i][j] == 0){
                    q.offer(new int[]{i, j});
                    res[i][j] = 0;
                }
        
        // BFS算法框架，从值为0的坐标开始向四周扩散
        while(!q.isEmpty()){
            int[] cur = q.poll();
            int curX = cur[0], curY = cur[1];
            for(int k=0; k<4; k++){
                int x = curX + dirs[k][0];
                int y = curY + dirs[k][1];
                // 确保相邻的这个左表没有越界且之前并未计算过
                if(x<m && x>=0 && y<n && y>=0 && res[x][y]==-1){
                    res[x][y] = res[curX][curY] + 1;
                    q.offer(new int[]{x, y});
                }
            }
        }
        return res;
    }
}
```

人家只有在 `x<m && x>=0 && y<n && y>=0 && res[x][y]==-1`成立的时候才更新，也就是说，只有**下一个位置**，更新的地方没有值的时候才回去更新，有值的话就略过。

可以看官方的解题思路，讲得很好：[542-01矩阵](https://leetcode.cn/problems/01-matrix/solutions/202012/01ju-zhen-by-leetcode-solution/?show=1)



**第二种解法：动态规划**

对于矩阵中的任意一个1以及一个0，我们如何从这个1到达这个0并且距离最短呢？根据上面的做法，我们可以从1开始，先在水平法向移动，直到与0在同一列，然后在竖直方向移动到达这个0.这样一来，从一个固定位置的1到任意一个0，在最短距离的前提下可能有四种解法：

- 只有**水平向左移动**和**竖直向上移动**
- 只有**水平向左移动**和**竖直向下移动**
- 只有**水平向右移动**和**竖直向上移动**
- 只有**水平向右移动**和**竖直向下移动**

例如下面这一个矩阵包含四个 0。从中心位置的 1 移动到这四个 0，就需要使用四种不同的方法：

```
0 _ _ _ 0
_ _ _ _ _
_ _ 1 _ _
_ _ _ _ _
0 _ _ _ 0
```

这样以来，我们就可以使用动态规划解决这个问题了。我们用 `f(i,j)`表示位置 `(i,j)`到最近的 0 的距离。如果我们只能「水平向左移动」和「竖直向上移动」，那么我们可以向上移动一步到达`（i-1，j）`，再移动 `f(i−1,j)`步到达某一个 0，也可以向左移动一步到达`（i，j-1）`，再移动 `f(i,j−1)`步到达某一个 0。因此我们可以写出如下的状态转移方程：

$$
f(i,j)=\left\{
\begin{aligned}
& 1+min\{f(i-1, j),f(i,j-1)\} &，位置(i,j)的元素为1 \\
& 0 &，位置(i,j)的元素为0 \\
\end{aligned}
\right.
$$

对于另外三种移动方法，我们也可以写出类似的状态转移方程，得到四个 `f(i,j)`的值，那么其中最小的值就表示位置 `(i,j)`到最近的 0 的距离。

```java
class Solution{
    public int[][] updateMatrix(int[][] matrix) {
        int[][] dirs = new int[][]{{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
        int m = matrix.length, n = matrix[0].length;
        // 初始化动态规划的数组，所有的距离都设置为一个很大的数
        int[][] dist = new int[m][n];
        for(int i=0; i<m; i++)
            Arrays.fill(dist[i], Integer.MAX_VALUE-100000);
        // 如果（i，j）的元素为0，那么距离为0
        for(int i=0; i<m; i++){
            for(int j=0; j<n; j++){
                if(matrix[i][j] == 0)
                    dist[i][j] = 0;
            }
        }
        
        // 只有 水平向左移动 和 竖直向上移动,注意动态规划的计算顺序
        for(int i=0; i<m; i++)
            for(int j=0; j<n; j++){
                if(i-1>=0)
                    dist[i][j] = Math.min(dist[i][j], dist[i-1][j]+1);
                if(j-1>=0)
                    dist[i][j] = Math.min(dist[i][j], dist[i][j-1]+1);
            }
        
        // 只有 水平向左移动 和 竖直向下移动，注意动态规划计算的顺序
        for(int i=m-1; i>=0; --i)
            for(int j=0; j<n; j++){
                if(i+1<m)
                    dist[i][j] = Math.min(dist[i][j], dist[i+1][j]+1);
                if(j-1>=0)
                    dist[i][j] = Math.min(dist[i][j], dist[i][j-1]+1);
            }
        
        // 只有 水平向右移动 和 竖直向上移动，注意动态规划的计算顺序
        for(int i=0; i<m; i++)
            for(int j=n-1; j>=0; j--){
                if(i-1>=0)
                    dist[i][j] = Math.min(dist[i][j], dist[i-1][j]+1);
                if(j+1<n)
                    dist[i][j] = Math.min(dist[i][j], dist[i][j+1]+1);
            }
        
        // 只有 水平向右移动 和 竖直向下移动，注意动态规划的计算顺序
        for(int i=m-1; i>=0; i--)
            for(int j=n-1; j>=0; j--){
                if(i+1<m)
                    dist[i][j] = Math.min(dist[i][j], dist[j+1][j]+1);
                if(j+1<n)
                    dist[i][j] = Math.min(dist[i][j], dist[i][j+1]+1);
            }
        return dist;        
    }
}
```

时间复杂度：$O(mn)$

空间复杂度：如果出去答案数组之外，空间复杂度就是 $O(1)$



其实这个动态规划还能继续优化：我们发现只有进行对象的遍历就行了，可以避免重复的计算，比如：

- 只有 **水平向左移动** 和 **竖直向上移动**
- 只有 **水平向下移动** 和 **竖直向下移动**

给个图看一下：

![image-20230802101739833](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308021017977.png)

很明显，如果只对一个对角进行遍历，那么另一个对角就会被遗漏，因此需要一对对角进行遍历。而且一对对角进行遍历即可遍历完全部。不信的话，你自己手动画一遍就知道了。

```java
class Solution{
    public int[][] updateMatrix(int[][] matrix) {
        int m = matrix.length, n = matrix[0].length;
        int[][] dist = new int[m][n];   
        for(int i=0; i<m; i++)
        	Arrays.fill(dist[i], Integer.MAX_VALUE-100000);
        // 先将元素为0的位置填充完毕
        for(int i=0; i<m; i++)
            for(int j=0; j<n; j++){
                if(matrix[i][j] == 0)
                    dist[i][j] = 0;
            }
        
        // 只有 水平向左移动 和 竖直向上移动
        for(int i=0; i<m; i++)
            for(int j=0; j<n; j++){
                if(i-1>=0)
                    dist[i][j] = Math.min(dist[i][j], dist[i-1][j]+1);
                if(j-1>=0)
                    dist[i][j] = Math.min(dist[i][j], dist[i][j-1]+1);
            }
        
        // 只有 水平向下移动 和 竖直向下移动
        for(int i=m-1; i>=0; i--)
            for(int j=n-1; j>=0; j--){
                if(i+1<m)
                    dist[i][j] = Math.min(dist[i][j], dist[i+1][j]+1);
                if(j+1<n)
                    dist[i][j] = Math.min(dist[i][j], dist[i][j+1]+1);
            }
        
        return dist;
    }
}
```

时间复杂度：$O(mn)$

空间复杂度：如果不计算答案数组空间，那空间复杂度就是$O(1)$