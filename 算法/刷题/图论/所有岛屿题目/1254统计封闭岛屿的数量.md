# 统计封闭岛屿的数量

力扣第 1254 题「[统计封闭岛屿的数目](https://leetcode.cn/problems/number-of-closed-islands/)」，难度中等

解题思路：

1、考边界的0一定不算封闭岛屿，将他全部淹没（置为1）

2、内部的岛屿才算是封闭岛屿

```java
class Solution {
    int[][] dirs = new int[][]{{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
    public int closedIsland(int[][] grid) {
        int m = grid.length, n = grid[0].length;
        // 首列和尾列的0都变为1
        for(int i=0; i<m; i++){
            if(grid[i][0] == 0)
                dfs(grid, i, 0);
            if(grid[i][n-1] == 0)
                dfs(grid, i, n-1);
        }
        // 首行和尾行的0都变为1
        for(int j=0; j<n; j++){
            if(grid[0][j] == 0)
                dfs(grid, 0, j);
            if(grid[m-1][j] == 0)
                dfs(grid, m-1, j);
        }
        int res = 0;
        // 计算内部岛屿的数量
        for(int i=1; i<m-1; i++){
            for(int j=1; j<n-1; j++){
                if(grid[i][j] == 0){
                    res++;
                    dfs(grid, i, j);
                }
            }
        }
        return res;
    }

    public void dfs(int[][] grid, int i, int j){
        int m = grid.length, n = grid[0].length;
        if(i<0 || j<0 || i>=m || j>=n){
            return;
        }
        if(grid[i][j] == 1)
            return;
        grid[i][j] = 1;
        for(int k=0; k<4; k++){
            int x = i + dirs[k][0];
            int y = j + dirs[k][1];
            dfs(grid, x, y);
        }
    }
}
```

