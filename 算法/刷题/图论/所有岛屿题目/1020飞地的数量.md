# 1020飞地的数量

[1020飞地的数量](https://leetcode.cn/problems/number-of-enclaves/description/)，难度中等

![image-20230725131947662](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202307251319734.png)

解题思路：

1、先把边界的陆地淹没掉

2、然后去数剩下的陆地数即可

```java
class Solution {
    int[][] dirs = new int[][]{{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
    public int numEnclaves(int[][] grid) {
        int m = grid.length, n = grid[0].length;
        // 将首行和尾行的数字1全都变为0
        for(int j=0; j<n; j++){
            if(grid[0][j]==1)
                dfs(grid, 0, j);
            if(grid[m-1][j]==1)
                dfs(grid, m-1, j);
        }
        // 将首列和尾列的数字1变为0
        for(int i=0; i<m; i++){
            if(grid[i][0] == 1)
                dfs(grid, i, 0);
            if(grid[i][n-1] == 1)
                dfs(grid, i, n-1);
        }
        int res = 0;
        //计算内部有多少块
        for(int i=1; i<m-1; i++){
            for(int j=1; j<n-1; j++){
                if(grid[i][j] == 1)
                    res++;
            }
        }
        return res;
    }

    public void dfs(int[][] grid, int i, int j){
        int m=grid.length, n = grid[0].length;
        if(i<0 || j<0 || i>=m || j>=n)
            return;
        if(grid[i][j] == 0)
            return;
        grid[i][j] = 0;
        for(int k=0; k<4; k++){
            int x = i + dirs[k][0];
            int y = j + dirs[k][1];
            dfs(grid, x, y);
        }
    }
}
```

