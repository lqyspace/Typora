# 200岛屿数量

[力扣200岛屿数量](https://leetcode.cn/problems/number-of-islands/)，难度中等

![image-20230725073801153](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202307250738241.png)

**岛屿系列题目的核心就是用DFS/BFS遍历二维数组。**

根据 [学习数据结构和算法的框架思维](https://labuladong.github.io/algo/di-ling-zh-bfe1b/xue-xi-sua-01220/)，完全可以根据二叉树的遍历框架改写出二维矩阵的 DFS 代码框架：

```java
// 二叉树遍历框架
void traverse(TreeNode root){
    traverse(root.left);
    traverse(root.right);
}

// 二维矩阵遍历框架
void dfs(int[][] grid, int i, int j, boolean[][] visited){
    int m=grid.length, n = grid[0].length;
    if(i<0 || j<0 || i>=m || j>= n)
        return;
    if(visited[i][j])
        return;
    
    // 进入节点(i, j)
    dfs(grid, i-1, j, visited);// 上
    dfs(grid, i+1, j, visited);// 下
    dfs(grid, i, j-1, visited);// 左
    dfs(grid, i, j+1, visited);// 右
}
```

当然，我们也可以使用方向数组来处理上下左右的遍历：

```java
int[][] dirs = new int[][]{{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
void dfs(int[][] grid, int i, int j, boolean[][] visited){
    int m=grid.length, n = grid[0].length;
    if(i<0 || j<0 || i>=m || j>=n)
        return;
    if(visited[i][j])
        return;
    for(int k=0; k<4; k++){
        int x = i + dirs[k][0];
        int y = j + dirs[k][1];
        dfs(grid, x, y, visited);
    }
    //离开节点（i, j）
}
```

对于这道题，==我最开始考虑的是使用图的连通性来做，即一行一行的遍历，遍历到有1的位置，就将其附近的1的点进行连通==，~~但是联通之后，如何判断有多少个为1的连通分量是一个问题。如果提前遍历一遍数组，判断有多少个1，然后计算最后的连通分量，但是此方法存在一些问题，难以找到一个参考点将图中的点进行二分类，尝试了一次，代码复杂。~~    **这道题是完全可以用并查集来做的，思路如下：**

1、先用动态连通性，将是一个岛屿的1全部都连接到一起，这个工作完成了以后，图中会形成几个数字是1的连通分量，当然里面还有数字是0的连通分量，数字是0的连通分量我们不用管。

2、**计算每一个数字是1的连通分量的根即可，同一个岛屿的根一定是相同的**，并使用 `HashSet`进行保存，路过的1以及与它相连的1都置为0，这样可以提高效率。

代码如下：

```java
class Solution {
    /**
        1、先用连通性，把一个岛屿的1都连接起来，这样会形成若干个连通分量
        2、计算每一个1的根不就行了嘛，路过的1变为0，提升效率
     */
    public int numIslands(char[][] grid) {
        int m = grid.length, n = grid[0].length;
        UF uf = new UF(m*n);
        int [][] dirs = new int[][]{{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
        // 连通
        for(int i=0; i<m; i++)
            for(int j=0; j<n; j++)
                if(grid[i][j] == '1'){
                    for(int k=0; k<4; k++){
                        int x = i + dirs[k][0];
                        int y = j + dirs[k][1];
                        if(x<0 || y<0 || x>=m || y>=n)
                            continue;
                        if(grid[x][y] == '1')
                            uf.union(i*n+j, x*n+y);
                    }
                }
        
        
        Set<Integer> sc = new HashSet<>();
        // 计算每一个1的根不就行了嘛，路过的1变为0，提升效率
        for(int i=0; i<m; i++)
            for(int j=0; j<n; j++)
                if(grid[i][j] == '1'){
                    int rootCur = uf.find(i*n+j);
                    sc.add(rootCur);
                    grid[i][j] = '0';
                    for(int k=0; k<4; k++){
                        int x = i + dirs[k][0];
                        int y = j + dirs[k][1];
                        if(x<0 || y<0 || x>=m || y>=n)
                            continue;
                        if(grid[x][y] == '1' && uf.connected(i*n+j, x*n+y))
                            grid[x][y] = '0';
                    }
                }
        return sc.size();
    }
}

class UF{
    private int count;
    private int[] parent;
    public UF(int n){
        this.count = n;
        this.parent = new int[n];
        for(int i=0; i<n; i++)
            parent[i] = i;
    }

    public void union(int p, int q){
        int rootP = find(p);
        int rootQ = find(q);
        if(rootP == rootQ)
            return;
        parent[rootP] = rootQ;
        this.count--;
    }

    public boolean connected(int p, int q){
        int rootP = find(p);
        int rootQ = find(q);
        return rootP == rootQ;
    }

    public int find(int x){
        if(parent[x] != x)
            parent[x] = find(parent[x]);
        return parent[x];
    }

    public int count(){
        return this.count;
    }
}
```

那么就换一种思路，遍历二维数组，对遍历到的1进行计数，与此同时，将该位置1的上下左右的数字为1的点都改为0，这样就节省了效率。

```java
class Solution {
    int[][] dirs = new int[][]{{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
    // 主函数，计算岛屿数量
    int numIslands(char[][] grid) {
		int res = 0;
        int m = grid.length, n = grid[0].length;
        //遍历grid
        for(int i=0; i<m; i++){
            for(int j=0; j<n; j++){
                if(grid[i][j] == '1'){
                    // 每发现一个岛屿，岛屿数量+1
                    res++;
                    // 然后使用dfs将岛屿淹没
                    dfs(grid, i, j);
                }
            }
        }
        return res;
    }
    
    public void dfs(char[][] grid, int i, int j){
        int m = grid.length, n = grid[0].length;
        if(i<0 || j<0 || i>=m || j>=n || grid[i][j]=='0')
            return;// 超出索引边界
        //if(grid[i][j] == '0')
            //return;// 已经是海水了
        // 将（i，j）淹没为海水
        grid[i][j] = '0';
        // 将与 （i，j）相邻的陆地也变为海水
        for(int k=0; k<4; k++){
            int x = i + dirs[k][0];
            int y = j + dirs[k][1];
            dfs(grid, x, y);
        }
    }
}
```

**之所以每次遇到一个岛屿就用DFS把岛屿给淹没了，是因为为了省事儿，避免维护visited数组。**

因为dfs函数遍历到的值为0的位置会直接返回，所以只要把经过的位置设为0，就可以不用再走回头路。

> Tip
>
> 这类 DFS 算法还有个别名叫做 [FloodFill 算法open in new window](https://labuladong.github.io/article/fname.html?fname=FloodFill算法详解及应用)，现在有没有觉得 FloodFill 这个名字还挺贴切的~

这个最最基本的算法问题就说到这，我们来看看后面的题目有什么花样。



