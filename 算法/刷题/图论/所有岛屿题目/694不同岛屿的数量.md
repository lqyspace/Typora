# 694不同岛屿的数量

[力扣694不同岛屿的数量](https://leetcode.cn/problems/number-of-distinct-islands/)，难度中等

![image-20230726105039788](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202307261050854.png)

力扣第 694 题「[不同的岛屿数量open in new window](https://leetcode.cn/problems/number-of-distinct-islands/)」，题目还是输入一个二维矩阵，`0` 表示海水，`1` 表示陆地，这次让你计算 **不同的 (distinct)** 岛屿数量，函数签名如下：

java 🟢cpp 🤖python 🤖go 🤖javascript 🤖



```java
int numDistinctIslands(int[][] grid)
```

比如题目输入下面这个二维矩阵：

![img](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202307261052247.jpeg)

其中有四个岛屿，但是左下角和右上角的岛屿形状相同，所以不同的岛屿共有三个，算法返回 3。

很显然我们得想办法把二维矩阵中的「岛屿」进行转化，变成比如字符串这样的类型，然后利用 HashSet 这样的数据结构去重，最终得到不同的岛屿的个数。

如果想把岛屿转化成字符串，说白了就是序列化，序列化说白了就是遍历嘛，前文 [二叉树的序列化和反序列化](https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-66994/dong-ge-da-d14d3/) 讲了二叉树和字符串互转，这里也是类似的。

**首先，对于形状相同的岛屿，如果从同一起点出发，`dfs` 函数遍历的顺序肯定是一样的**。

因为遍历顺序是写死在你的递归函数里面的，不会动态改变：

java 🟢cpp 🤖python 🤖go 🤖javascript 🤖



```java
void dfs(int[][] grid, int i, int j) {
    // 递归顺序：
    dfs(grid, i - 1, j); // 上
    dfs(grid, i + 1, j); // 下
    dfs(grid, i, j - 1); // 左
    dfs(grid, i, j + 1); // 右
}
```

所以，遍历顺序从某种意义上说就可以用来描述岛屿的形状，比如下图这两个岛屿：

![img](https://labuladong.github.io/algo/images/岛屿/6.png)

假设它们的遍历顺序是：

> 下，右，上，撤销上，撤销右，撤销下

如果我用分别用 `1, 2, 3, 4` 代表上下左右，用 `-1, -2, -3, -4` 代表上下左右的撤销，那么可以这样表示它们的遍历顺序：

> 2, 4, 1, -1, -4, -2

**你看，这就相当于是岛屿序列化的结果，只要每次使用 `dfs` 遍历岛屿的时候生成这串数字进行比较，就可以计算到底有多少个不同的岛屿了**。

> info
>
> 这个地方我们是一定要记录撤销操作的，举个例子，比如 **下，右，撤销右，撤销下** 和 **下，撤销下，右，撤销右** 这两个不同的遍历顺序，如果把撤销操作去掉的话，那么他两就都是 **下，右**  ，成了相同的遍历顺序，这显然是不对的，比如下图：

<img src="https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202307261101521.png" alt="示例" style="transform:rotate(180deg)" />

如果取消了撤销操作，在使用`dfs`时，那么这两个岛屿就会被判定为相同的岛屿。

因此我们需要稍微修改 `dfs` 函数，添加一些函数功能以便记录遍历顺序：

```java
void dfs(int[][] grid, int i, int j, StringBuilder sb, int dir){
    int m = grid.length, n = grid[0].length;
    if(i<0 || j<0 || i>=m || j>=n || grid[i][j] == 0)
        return;
    
    grid[i][j] = 0;
    sb.append(dir).append(',');
    dfs(grid, i-1, j, sb, 1);// 上
    dfs(grid, i+1, j, sb, 2);// 下
    dfs(grid, i, j-1, sb, 3);// 左
    dfs(grid, i, j+1, sb, 4);// 右
    
    // 后序遍历：离开（i，j）
    sb.sppend(-dir).append(',');
}
```

> Note
>
> 仔细看这段代码，在递归之前做选择，在递归之后取消选择，它像不像[回溯算法框架](https://labuladong.github.io/algo/di-ling-zh-bfe1b/hui-su-sua-c26da/)？实际上它就是回溯算法，因为它关注的是树枝（岛屿的遍历顺序），而不是节点（岛屿的格子）

`dir` 记录方向，`dfs` 函数递归结束后，`sb` 记录着整个遍历顺序。有了这个 `dfs` 函数就好办了，我们可以直接写出最后的解法代码：

```java
class Solution {
    public int numDistinctIslands(int[][] grid) {
 		int m = grid.length, n = grid[0].length;
        // 记录所有的岛屿的序列化结果
        HashSet<String> hs = new HashSet<>();
        for(int i=0; i<m; i++)
            for(int j=0; j<n; j++)
                if(grid[i][j] == 1){
                    StringBuilder sb = new StringBuilder();
                    // 初始化放心不影响结果
                    dfs(grid, i, j, sb, 666);
                    hs.add(sb.toString());
                }
        return hs.size();
    }
}
```

这样，这道题就解决了，至于为什么初始调用 `dfs` 函数时的 `dir` 参数可以随意写，因为这个 `dfs` 函数实际上是回溯算法，它关注的是「树枝」而不是「节点」，前文 [图算法基础](https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-03a72/tu-lun-ji--d55b2/) 有写具体的区别，这里就不赘述了。
