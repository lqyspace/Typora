# 1905统计子岛屿

如果说前面的题目都是模板题，那么力扣第 1905 题「[统计子岛屿](https://leetcode.cn/problems/count-sub-islands/)」可能得动动脑子了：

![img](https://labuladong.github.io/algo/images/岛屿/4.jpg)

什么情况下 `grid2`中的岛屿B是 `grid1`中的一个岛屿A的子岛屿。

当岛屿B中的所有陆地在岛屿A中也是陆地的时候，岛屿B就是岛屿A的子岛屿。

**反过来说，如果岛屿 `B` 中存在一片陆地，在岛屿 `A` 的对应位置是海水，那么岛屿 `B` 就不是岛屿 `A` 的子岛**。

那么，我们只要遍历 `grid2` 中的所有岛屿，把那些不可能是子岛的岛屿排除掉，剩下的就是子岛。

依据这个思路，可以直接写出下面的代码：

```java
class Solution {
    int countSubIslands(int[][] grid1, int[][] grid2) {
 		int m = grid1.length, n = grid1[0].length;
        // 先排除一定不是子岛屿的       
        for(int i=0; i<m; i++)
            for(int j=0; j<n; j++)
                // 此处不用管grid2[i][j]==0的情况，因此这一定不是子岛屿
                if(grid1[i][j] == 0 && grid2[i][j] == 1)
                    dfs(grid2, i, j);
        
        // 现在grid2中剩下的一定都是子岛屿，计算岛屿数量
        int res = 0;
        for(int i=0; i<m; i++)
            for(int j=0; j<n; j++)
                if(grid2[i][j] == 1){
                    res++;
                    dfs(grid2, i, j);
                }
        return res;
    }
    
    public void dfs(int[][] grid, int i, int j){
        int m = grid.length, n = grid[0].length;
        if(i<0 || j<0 || i>=m || j>=n)
            return;
        if(grid[i][j] == 0)
            return;
        grid[i][j] = 0;
        dfs(grid, i+1, j);
        dfs(grid, i-1, j);
        dfs(grid, i, j+1);
        dfs(grid, i, j-1);
    }
}
```

这道题的思路和计算「封闭岛屿」数量的思路有些类似，只不过后者排除那些靠边的岛屿，前者排除那些不可能是子岛的岛屿。

























