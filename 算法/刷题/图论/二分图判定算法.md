# 二分图判定

## 二分图判定思路

判定二分图的算法很简单，就是用代码解决「双色问题」。

**说白了就是遍历一遍图，一边遍历一边染色，看看能不能用两种颜色给所有节点染色，且相邻节点的颜色都不相同**。

既然说到遍历图，也不涉及最短路径之类的，当然是 DFS 算法和 BFS 皆可了，DFS 算法相对更常用些，所以我们先来看看如何用 DFS 算法判定双色图。

首先，基于 [学习数据结构和算法的框架思维](https://labuladong.github.io/algo/di-ling-zh-bfe1b/xue-xi-sua-01220/) 写出图的遍历框架：

```java
// 二叉树遍历框架
void traverse(TreeNode root){
    if (root == null) return;
    traverse(root.left);
    traverse(root.right);
}

// 多叉树遍历框架
void traverse(Node root) {
    if(root == null) return;
    for(Node child: root.children)
        traverse(child);
}

// 图遍历框架
boolean[] visited;
void traverse(Graph graph, int v){
    // 防止走回头路
    if(visited[v]) return;
    // 前序遍历位置，标记节点 v 已访问
    for(Vertex neighbor: graph.neighbor(v))
        traverse(graph, neighbor);
}
```

因为图中可能存在环，所以用 `visited`数据防止走回头路。

**这里可以看到我们习惯把 return 语句放在函数开头，因为一般return语句都是以base case，集中放在一起可以让算法结构更清晰。**

其实如果你愿意，也可以把if语句移动到其他的地方，比如图遍历框架可以稍微改改：

```java
/* 图遍历框架 */
boolean[] visited;
void traverse(Graph graph, int v) {
    // 前序遍历位置，标记节点 v 已访问
    visited[v] = true;
    for (int neighbor : graph.neighbors(v)) {
        if (!visited[neighbor]) {
            // 只遍历没标记过的相邻节点
            traverse(graph, neighbor);
        }
    }
}
```

这种写法把对 `visited` 的判断放到递归调用之前，和之前的写法唯一的不同就是，你需要保证调用 `traverse(v)` 的时候，`visited[v] == false`。

为什么要特别说这种写法呢？因为我们判断二分图的算法会用到这种写法。

**回顾一下二分图怎么判断，其实就是让 `traverse` 函数一边遍历节点，一边给节点染色，尝试让每对相邻节点的颜色都不一样**。

所以，判定二分图的代码逻辑可以这样写：

```java
void traverse(Graph graph, boolean[] visited, int v){
    visited[v] = true;
    // 遍历节点v的所有邻居节点
    for(int neighbor : grapg.neighbor(v)){
        if(!visited[neighbor]) {
            // 相邻接点 neighbor 没有被访问过
            // 那么应该给节点 neighbor 涂上和 v 不同的颜色
            traverse(graph, visited, neighbor);
        } else {
            // 相邻节点 neighbor已经访问过
            // 那么应该比较节点 neighbor 和 节点v的颜色
            // 若相同，则此图不是二分图
        }
    }
}
```



## 题目实践

力扣第 785 题「[判断二分图](https://leetcode.cn/problems/is-graph-bipartite/)」就是原题，题目给你输入一个 [邻接表](https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-03a72/tu-lun-ji--d55b2/) 表示一幅无向图，请你判断这幅图是否是二分图。

函数签名如下：

```java
boolean isBipartite(int[][] graph);
```

比如题目给的例子，输入的邻接表 `graph = [[1,2,3],[0,2],[0,1,3],[0,2]]`，也就是这样一幅图：

![img](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202307231721301.png)

显然无法对节点着色使得每两个相邻节点的颜色都不相同，所以算法返回 false。

但如果输入 `graph = [[1,3],[0,2],[1,3],[0,2]]`，也就是这样一幅图：

![img](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202307231721160.png)

如果把节点 `{0, 2}` 涂一个颜色，节点 `{1, 3}` 涂另一个颜色，就可以解决「双色问题」，所以这是一幅二分图，算法返回 true。

结合之前的代码框架，我们可以额外使用一个 `color` 数组来记录每个节点的颜色，从而写出解法代码：

```java
class Solution {
    // 记录图是否符合二分图性质
    private boolean ok = true;
    // 记录图中节点的颜色，false 和 true 代表两种不同颜色
    private boolean[] color;
    // 记录图中节点是否被访问过
    private boolean[] visited;

    // 主函数，输入邻接表，判断是否是二分图
    public boolean isBipartite(int[][] graph) {
        int n = graph.length;
        color = new boolean[n];
        visited = new boolean[n];
        // 因为图不一定是联通的，可能存在多个子图
        // 所以要把每个节点都作为起点进行一次遍历
        // 如果发现任何一个子图不是二分图，整幅图都不算二分图
        for (int v = 0; v < n; v++) {
            if (!visited[v]) {
                traverse(graph, v);
            }
        }
        return ok;
    }

    // DFS 遍历框架
    private void traverse(int[][] graph, int v) {
        // 如果已经确定不是二分图了，就不用浪费时间再递归遍历了
        if (!ok) return;

        visited[v] = true;
        for (int w : graph[v]) {
            if (!visited[w]) {
                // 相邻节点 w 没有被访问过
                // 那么应该给节点 w 涂上和节点 v 不同的颜色
                color[w] = !color[v];
                // 继续遍历 w
                traverse(graph, w);
            } else {
                // 相邻节点 w 已经被访问过
                // 根据 v 和 w 的颜色判断是否是二分图
                if (color[w] == color[v]) {
                    // 若相同，则此图不是二分图
                    ok = false;
                    return;
                }
            }
        }
    }
}
```

我自己写的代码：

```java
class Solution {
    Set<Integer> A = new HashSet<>();
    Set<Integer> B = new HashSet<>();
    boolean flag = true;
    public boolean isBipartite(int[][] graph) {
        int n = graph.length;
        boolean[] visited = new boolean[n];
        for(int i=0; i<n; i++){
            if(!visited[i])
                traverse(graph, visited, i);
        }
        return flag;
    }

    public void traverse(int[][] graph, boolean[] visited, int v){
        if(!flag) return;
        visited[v] = true;
        for(int neighbor : graph[v]){
            if(!visited[neighbor]){
                if(A.contains(v))
                    B.add(neighbor);
                else if(B.contains(v))
                    A.add(neighbor);
                else{
                    A.add(v);
                    B.add(neighbor);
                }
                traverse(graph, visited, neighbor);
            }else{
                if(A.contains(v) && A.contains(neighbor) || B.contains(v) && B.contains(neighbor)){
                    flag = false;
                    return;
                }
            }
        }
    }
}
```

这就是解决「双色问题」的代码，如果能成功对整幅图染色，则说明这是一幅二分图，否则就不是二分图。

接下来看一下 BFS 算法的逻辑：

```java
class Solution {
    // 记录图是否符合二分图性质
    private boolean ok = true;
    // 记录图中节点的颜色，false 和 true 代表两种不同颜色
    private boolean[] color;
    // 记录图中节点是否被访问过
    private boolean[] visited;

    public boolean isBipartite(int[][] graph) {
        int n = graph.length;
        color =  new boolean[n];
        visited =  new boolean[n];
        
        for (int v = 0; v < n; v++) {
            if (!visited[v]) {
                // 改为使用 BFS 函数
                bfs(graph, v);
            }
        }
        
        return ok;
    }

    // 从 start 节点开始进行 BFS 遍历
    private void bfs(int[][] graph, int start) {
        Queue<Integer> q = new LinkedList<>();
        visited[start] = true;
        q.offer(start);
        
        while (!q.isEmpty() && ok) {
            int v = q.poll();
            // 从节点 v 向所有相邻节点扩散
            for (int w : graph[v]) {
                if (!visited[w]) {
                    // 相邻节点 w 没有被访问过
                    // 那么应该给节点 w 涂上和节点 v 不同的颜色
                    color[w] = !color[v];
                    // 标记 w 节点，并放入队列，表明此时已经访问过
                    visited[w] = true;
                    q.offer(w);
                } else {
                    // 相邻节点 w 已经被访问过
                    // 根据 v 和 w 的颜色判断是否是二分图
                    if (color[w] == color[v]) {
                        // 若相同，则此图不是二分图
                        ok = false;
                        return;
                    }
                }
            }
        }
    }
}
```

核心逻辑和刚才实现的 `traverse` 函数（DFS 算法）完全一样，也是根据相邻节点 `v` 和 `w` 的颜色来进行判断的。关于 BFS 算法框架的探讨，详见前文 [BFS 算法框架](https://labuladong.github.io/algo/di-ling-zh-bfe1b/bfs-suan-f-463fd/) 和 [Dijkstra 算法模板](https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-03a72/dijkstra-s-6d0b2/)，这里就不展开了。

最后再来看看力扣第 886 题「[可能的二分法](https://leetcode.cn/problems/possible-bipartition/)」：

![img](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202307231737210.png)

函数签名如下：

```java
boolean possibleBipartition(int n, int[][] dislikes);
```

**其实这题考察的就是二分图的判定**：

如果你把每个人看做图中的节点，相互讨厌的关系看做图中的边，那么 `dislikes` 数组就可以构成一幅图；

又因为题目说互相讨厌的人不能放在同一组里，相当于图中的所有相邻节点都要放进两个不同的组；

那就回到了「双色问题」，如果能够用两种颜色着色所有节点，且相邻节点颜色都不同，那么你按照颜色把这些节点分成两组不就行了嘛。

所以解法就出来了，我们把 `dislikes` 构造成一幅图，然后执行二分图的判定算法即可：

```java
class Solution {
    boolean flag = true;
    boolean[] visited;
    boolean[] color;
    public boolean possibleBipartition(int n, int[][] dislikes) {
        List<Integer>[] graph = new LinkedList[n];
        visited = new boolean[n];
        color = new boolean[n];
        for(int i=0; i<n; i++)
            graph[i] = new LinkedList<>();
        for(int[] a : dislikes){
            int num1 = a[0], num2 = a[1];
            graph[num1-1].add(num2-1);
            graph[num2-1].add(num1-1);
        }

        for(int v=0; v<n; v++)
            if(!visited[v])
                traverse(graph, v);

        return flag;
    }

    public void traverse(List<Integer>[] graph, int v){
        if(!flag) return;
        visited[v] = true;

        for(int w : graph[v]){
            if(!visited[w]){
                color[w] = !color[v];
                traverse(graph, w);
            } else {
                if(color[w] == color[v]){
                    flag = false;
                    return;
                }
            }
        }
    }
}
```

接下来是BFS逻辑：

```java
class Solution {
    boolean flag = true;
    boolean[] visited;
    boolean[] color;
    public boolean possibleBipartition(int n, int[][] dislikes) {
        List<Integer>[] graph = new LinkedList[n];
        visited = new boolean[n];
        color = new boolean[n];
        for(int i=0; i<n; i++)
            graph[i] = new LinkedList<>();
        for(int[] a : dislikes){
            int num1 = a[0], num2 = a[1];
            graph[num1-1].add(num2-1);
            graph[num2-1].add(num1-1);
        }

        for(int i=0; i<n; i++){
            if(!visited[i])
                bfs(graph, i);
            if(!flag)
                return false;
        }

        return flag;
    }

    public void bfs(List<Integer>[] graph, int s){
        if(!flag) return;
        visited[s] = true;
        Queue<Integer> q = new LinkedList<>();
        q.offer(s);
        
        while(!q.isEmpty()){
            int v = q.poll();
            for(int w : graph[v]){
                if(!visited[w]){
                    color[w] = !color[v];
                    visited[w] = true;
                    q.offer(w);
                } else {
                    if(color[w] == color[v]){
                        flag = false;
                        return;
                    }
                }
            }
        }
        
    }
}
```



总结：

解决二分图的思路，一般就是 DFS 和 BFS都可以用，主要是现在把题目中给的边的关系转化成图（邻接表或邻接矩阵，邻接表用的多一些），**一边遍历一遍染色**，在遍历的时候看访问的邻居节点是否之前访问过，如果访问，那就需要比较这个邻居节点和当前的节点是否存在颜色不一致，如果颜色不一致则可以继续遍历（以邻居节点继续遍历），如果颜色一致，说明不是二分图。





