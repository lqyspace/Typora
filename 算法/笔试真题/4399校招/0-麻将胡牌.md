# 2019年字节算法笔试题

## 题意

小包最近迷上了一款叫做雀魂的麻将游戏，但是这个游戏规则太复杂，小包玩了几个月了还是输多赢少。

于是生气的小包根据游戏简化了一下规则发明了一种新的麻将，只留下一种花色，并且去除了一些特殊和牌方式（例如七对子等），具体的规则如下：

1. 总共有36张牌，每张牌是1~9。每个数字4张牌。
2. 你手里有其中的14张牌，如果这14张牌满足如下条件，即算作和牌

- 14张牌中有2张相同数字的牌，称为雀头。
- 除去上述2张牌，剩下12张牌可以组成4个顺子或刻子。顺子的意思是递增的连续3个数字牌（例如234,567等），刻子的意思是相同数字的3个数字牌（例如111,777）

例如：

1 1 1 2 2 2 6 6 6 7 7 7 9 9 可以组成1,2,6,7的4个刻子和9的雀头，可以和牌

1 1 1 1 2 2 3 3 5 6 7 7 8 9 用1做雀头，组123,123,567,789的四个顺子，可以和牌

1 1 1 2 2 2 3 3 3 5 6 7 7 9 无论用1 2 3 7哪个做雀头，都无法组成和牌的条件。

现在，小包从36张牌中抽取了13张牌，他想知道在剩下的23张牌中，再取一张牌，取到哪几种数字牌可以和牌。

##### **输入描述:**

```javascript
输入只有一行，包含13个数字，用空格分隔，每个数字在1~9之间，数据保证同种数字最多出现4次。
```

##### **输出描述:**

```javascript
输出同样是一行，包含1个或以上的数字。代表他再取到哪些牌可以和牌。若满足条件的有多种牌，请按从小到大的顺序输出。若没有满足条件的牌，请输出一个数字0
```

### **样例**

##### **输入例子1:**

```javascript
1 1 1 2 2 2 5 5 5 6 6 6 9
```

##### **输出例子1:**

```javascript
9
```

##### **例子说明1:**

```javascript
可以组成1,2,6,7的4个刻子和9的雀头
```

##### **输入例子2:**

```javascript
1 1 1 1 2 2 3 3 5 6 7 8 9
```

##### **输出例子2:**

```javascript
4 7
```

##### **例子说明2:**

```javascript
用1做雀头，组123,123,567或456,789的四个顺子
```

##### **输入例子3:**

```javascript
1 1 1 2 2 2 3 3 3 5 7 7 9
```

##### **输出例子3:**

```javascript
0
```

##### **例子说明3:**

```javascript
来任何牌都无法和牌
```

## **题解**

如果会打麻将的小伙伴看到这题应该很熟悉，这不就是麻将3x+2的胡牌规则么？

所谓的3x即是可以组在一起的三张牌，也就是题目中说的顺子和刻子。而+2，加的是两张一样的牌，对应题目当中的雀头。这题要做的就是给定现在摸到的牌型，然后给出听胡的牌。

我们很容易可以想到我们可以用一个长度为10的数组来存储现在已经摸到的牌，比如我们令这个数组叫做cards。`cards[3]=2` 就说明我们有两张3，`cards[6]=3` 就说明我们有3张6。这样把牌和对应的数量关联起来，我们就可以很方便地判断顺子和刻子的情况了。

存储搞定了之后，我们接下来要搞定的是胡牌以及听牌。其中听牌比较简单，我们只需要额外增加一张牌判断是否胡牌就可以了。比如说我们多摸了一张3之后，判断可以胡牌了，那么说明当前我们听的牌当中就有3。由于一共只有10张牌，我们只需要枚举一下可以听的牌即可。这里有一个小trick不小心很容易忽略，因为麻将当中一种牌最多只有4张，所以我们**只需要考虑数量小于4的牌**。

胡牌的判断也很直观，可以分为雀头和刻子顺子两个部分。雀头好办，我们只需要枚举数量大于2的牌让它们成为雀头，判断剩下的牌能否全部组成顺子或者是刻子即可。全题唯一的难点就在这个组合的判断，虽然去掉雀头之后只有12张牌，也就是4个顺子或者是刻子，但由于**顺子和刻子之间可以各种组合**，尝试枚举是非常困难的，也是几乎不可能实现的。

如果看过我之前的文章，应该能反应过来，这里其实是一个经典的**搜索问题**。我们要枚举一下解是否成立，那么最好的办法就是尝试着把当前12张牌拆分成一个一个的顺子和刻子。如果能全部拆分完，那么就说明可以胡牌，否则则不行。搜索的情况只有两种，一种是组成顺子一种是组成刻子，倒是不复杂，但这里的代码却不好写。因为这是一个返回类型是boolean型的深度优先搜索，对于新手而言可能相对比较陌生。

关于这个问题没有什么太好的办法，只有加大训练量以及多思考。一定要从递归的原理上去理解，只是把代码记下来似懂非懂是不行的，如果面试白板编程的时候碰到，肯定是会露馅的。

只要能反应过来这是一个搜索问题，并且对相关的代码还熟练的话，这题还是挺简单的，没有太多的trick和弯弯绕，数据也比较弱不用担心超时的问题。

```java
class Solution{
    // 记录牌的数量
    int[] cards = new int[10];
    public List<Integer> mahJong(int[] nums){
        for(int num: nums){
            cards[num]++;
        }
        List<Integer> res = new ArrayList<>();
        // 开始听牌
        for(int i=1; i<10; i++){
            if(cards[i]==4)continue;
            cards[i]++;
            // 判断是否可以胡牌
            // 枚举雀头
            for(int j=1; j<10; j++){
                if(cards[j]>1){
                    cards[j] -= 2;
                    if(dfs()){// 胡牌成功，说明i可取，遍历下一个i
                        res.add(i);
                        cards[j] += 2;
                        break;
                    }
                    cards[j] += 2;
                }
            }
            cards[i]--;
        }
        if(res.isEmpty()){
            System.out.println(0);
            return;
        }
        Collections.sort(res);
        for(int nu: res){
            System.out.printf("%d ", nu);
        }
        return;
    }
    
    public void dfs(){
        boolean flag = true;
        // 遍历cards，看是否全部拆分完毕
        for(int i=1; i<10; i++){
            if(cards[i]!=0){
                flag = false;// 说明还有牌，不一定是没有分完，还需要继续分
                break;
            }
        }
        if(flag) return true;
        for(int i=1; i<10; i++){
            // 顺子
            if(i<8 && cards[i]!=0 && cards[i+1]!=0 && cards[i+2]!=0){
                cards[i]--;
                cards[i+1]--;
                cards[i+2]--;
                flag |= dfs();
                cards[i]++;
                cards[i+1]++;
                cards[i+2]++;
            }
            
            // 刻子
            if(cards[i] > 2){
                cards[i] -= 3;
                flag |= dfs();
                cards[i] += 3;
            }
        }
        return flag;
    }
}
```

参考：[字节跳动2019年算法笔试题](https://cloud.tencent.com/developer/article/1770749)