# 等频离散化

![image-20231013233729048](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310132337136.png)

```java
import java.util.*;


public class Solution {
    /**
     * 等频离散化
     * @param A int整型一维数组 从小到大已排序整数数列A
     * @param K int整型 划分段数
     * @return int整型二维数组
     */
     int K;
     int[] A;
     ArrayList<Integer> path = new ArrayList<>();
     double S = Double.MAX_VALUE;
     int e;
     List<Integer> res = new ArrayList<>();

    public int[][] discretize_by_frequency (int[] A, int K) {
        // write code here
        TreeMap<Integer, Integer> tm = new TreeMap<>();
        int[][] ans = new int[K][];
        for(int i=0; i<A.length; i++){
            tm.put(A[i], tm.getOrDefault(A[i], 0)+1);
        }
        List<Integer> nums = new ArrayList<>();
        for(Map.Entry<Integer, Integer> en: tm.entrySet()){
            nums.add(en.getValue());
        }

        // 为了避免每个子群有元素重叠，所以每一个簇都必须在一个群里
        // 每个群里至少一个簇
        this.K = K;
        this.A = A;
        this.e = A.length / K;

        dfs(nums, 1, 0);

        int m = 0;
        int index = 0;
        for(int i=0; i< res.size(); i++){
            int[] ab = new int[res.get(i)];
            for(int j=0; j<res.get(i); j++){
                 ab[j] = A[index++];
            }
            ans[m++] = ab;
        }
        return ans;
    }
    
    public void dfs(List<Integer> nums, int k, int i){
        if(k>K || i>nums.size() || k<K && i==nums.size()) return;
        if(k==K && i == nums.size()){
            double tmp = 0.0;
            // 计算方差
            for(int num: path){
                tmp += Math.pow(Math.abs(num - e), 2);
            }
            if(tmp / K < S){
                S = tmp / K;
                res = new ArrayList<>(path);
            }
            return;
        }
        // 两种可能：把下一簇加入到其中；下一簇作为一个新的群
        if(path.size()==0){
            path.add(nums.get(i));
        }else{
            int lastn = path.remove(path.size()-1);
            path.add(lastn + nums.get(i));
        }
        dfs(nums, k, i+1);
        int las = path.remove(path.size()-1);
        path.add(las - nums.get(i));

        path.add(nums.get(i));
        dfs(nums, k+1, i+1);
        path.remove(path.size()-1);
    }
}
```

