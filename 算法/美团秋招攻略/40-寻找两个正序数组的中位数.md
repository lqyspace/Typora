# 4-寻找两个正序数组的中位数

[4-寻找两个正序数组的中位数](https://leetcode.cn/problems/median-of-two-sorted-arrays/description/?envType=study-plan-v2&envId=meituan-2023-fall-sprint)，难度困难

![image-20230909104403233](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202309091044872.png)

题解1：使用归并排序，时间复杂度O(m+n)

```java
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int[] res = new int[nums1.length + nums2.length];
        int index1 = 0, index2 = 0;
        while(index1<nums1.length && index2<nums2.length){
            if(nums1[index1]<=nums2[index2]){
                res[index1+index2] = nums1[index1++];
            }else{
                res[index1+index2] = nums2[index2++];
            }
        }
        while(index1<nums1.length){
            res[index1+index2] = nums1[index1++];
        }
        while(index2<nums2.length)
            res[index1+index2] = nums2[index2++];
        return res.length%2==0? (res[res.length/2]+res[res.length/2-1])/2.0 : res[res.length/2];
    }
}
```

题解2：不使用归并排序，只需要找出中间的两个或一个数即可，时间复杂度还是O(m+n)

```java
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int len = nums1.length + nums2.length;
        int index1 = 0, index2 = 0;
        int m = 0, n = 0;
        for(int i=0; i<=len/2; i++){
            n = m;
            if(index1<nums1.length && index2<nums2.length){
                if(nums1[index1]<=nums2[index2]){
                    m = nums1[index1++];
                }else{
                    m = nums2[index2++];
                }
            }else if(index1<nums1.length){
                m = nums1[index1++];
            }else if(index2<nums2.length)
                m = nums2[index2++];
    	}
        return len%2==0? (m+n)/2.0 : m;
    }
}
```

题解3：二分搜索，详情看力扣[官方的题解](https://leetcode.cn/problems/median-of-two-sorted-arrays/solutions/8999/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-2/?envType=study-plan-v2&envId=meituan-2023-fall-sprint)

```java
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
		int len = nums1.length + nums2.length;
        if(len%2==1){
            int midIndex = len/2;
            double median = getKthElement(nums1, nums2, midIndex+1);
            return median;
        }else {
            int midIndex1 = len/2-1, midIndex2 = len/2;
            double median = (getKthElement(nums1, nums2, midIndex1+1) + getKthElement(nums1, nums2, midIndex2+1)) / 2.0;
            return median;
        }
    }
    
    public int getKthElement(int[] nums1, int[] nums2, int k){
        int len1 = nums1.length, len2 = nums2.length;
        int index1 = 0, index2 = 0;
        
        while(true){
            if(index1 == len1){
                return nums2[index2+k-1];
            }
            if(index2 == len2){
                return nums1[index1+k-1];
            }
            if(k==1){
                return Math.min(nums1[index1], nums2[index2]);
            }
            
            // 正常情况下
            int half = k/2;
            int newIndex1 = Math.min(index1+half, len1)-1;
            int newIndex2 = Math.min(index2+half, len2)-1;
            if(nums1[newIndex1]>nums2[newIndex2]){
                k -= (newIndex2 - index2 + 1);
                index2 = newIndex2 + 1;
            }else{
                k -= (newIndex1 - index1 + 1);
                index1 = newIndex1 + 1;
            }
        }
    }
}
```

