# 1 小美的加法

![image-20230923225332768](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202309232254904.png)

题解：这道题使用 ==模拟法==

模拟出两个数之间最大的乘数

代码如下：

```java
import java.util.*;

// 注意类名必须为 Main, 不要有任何 package xxx 信息
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        long[] nums = new long[n];// 避免溢出
        long sum = 0;
        for (int i = 0; i < n; i++) {
            nums[i] = in.nextInt();
            sum += nums[i];
        }
        // long res = Long.MIN_VALUE;
        // int f = -1;
        long max = 0;
        for(int i=1; i<nums.length; i++){
            long tmp = (long)(nums[i]*nums[i-1]) - (long)(nums[i]+nums[i-1]);
            max = Math.max(max, tmp);
        }

        // 这个思路有漏铜，乘积大并不代表乘积与求和的差值就大，一定要求差值
        // for (int i = 0; i < n - 1; i++) {
        //     if ((long)(nums[i] + nums[i + 1]) < (long)(nums[i] * nums[i + 1])) {
        //         if (res < (long) nums[i] * nums[i + 1]) {
        //             res = (long) nums[i] * nums[i + 1];
        //             f = i;
        //         }
        //     }
        // }
        // long sum = 0;
        // for (int i = 0; i < n; i++) {
        //     if (i == f) {
        //         sum += ((long)nums[i] * nums[i + 1]);
        //         i++;
        //     } else {
        //         sum += nums[i];
        //     }
        // }

        System.out.println(sum + max);
    }
}
```

