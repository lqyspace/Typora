# 3 小美的01串翻转

![image-20230924232548311](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202309242325374.png)

题解：通过题意，其实我们可以发现，最后的序列必然是10101...，或者 01010...，因此对于长度为n的序列，最后的结果只有2种可能。枚举其中的最小值即可。

本题使用的解法是 ==前缀和==

值得注意的是：题目给的实例是在原串的子串中求权值之和，而不是将其固定变成01010...或10101...这种序列之后再进行子串的求和。一定要理解题意！！！

```java
public class Main{
    public static void main(String[] args){
        Scanner in = new Scanner(System.in);
        String strs = in.nextLine();
        int n = strs.length();
        int[] s1 = new int[n];
        int[] s2 = new int[n];
        
        s1[0] = strs.charAt(0) - '0';
        s2[0] = s1[0] ^ 1;
        for(int i=1; i<n; i++){
            s1[i] = s1[i-1] ^ 1;
            s2[i] = s2[i-1] ^ 1;
        }
        
        int[] preSum1 = new int[n+1], preSum2 = new int[n+1];
        for(int i=1; i<=n; i++){
            preSum1[i] = preSum1[i-1];
            preSum2[i] = preSum2[i-1];
            
            if(strs.charAt(i-1)-'0' != s1[i-1]) preSum1[i] += 1;
            if(strs.charAt(i-1)-'0' != s2[i-1]) preSum2[i] += 1;
        }
        
        int res = 0;
        for(int i=0; i<n; i++){
            for(int j=i+1; j<n; j++){
                res += Math.min(preSum1[j+1] - preSum1[i], preSum2[j+1] - preSum2[i]);
            }
        }
        System.out.println(res);
    }
}
```

