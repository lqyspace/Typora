# 5-最长回文子串

[5-最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/description/?envType=study-plan-v2&envId=meituan-2023-fall-sprint)，难度中等

![image-20230828222649592](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308282226647.png)

```java
class Solution {
    public String longestPalindrome(String s) {
        if(s.length()==1) return s;
        int n = s.length();
        boolean[][] dp = new boolean[n][n];

        for(int i=0; i<n; i++){
            dp[i][i] = true;
        } 
        int start = 0, maxLen = 1;
        for(int i=n-2; i>=0; i--){
            for(int j=i+1; j<n; j++){
                dp[i][j] = s.charAt(i)==s.charAt(j) && (dp[i+1][j-1] || j-i<=2);
                if(dp[i][j] && (j-i+1)>maxLen){
                    start = i;
                    maxLen = j-i+1;
                }
            }
        }
        return s.substring(start, maxLen+start);
    }
}
```

其他解法：

```java
class Solution {
    public String longestPalindrome(String s) {
		int n = s.length();
        if(n==1) return s;
        boolean[][] dp = new boolean[n][n];// s[i...j]是否是回文串
        for(int i=0; i<n; i++)
            dp[i][i] = true;
        int start = 0, maxLen = 1;
        // 从长度2开始枚举
        for(int L = 2; L<=n; L++){
            for(int i=0; i<n; i++){
                // 获取右边界
                int j = i+L-1;
                // 如果右边界越界，退出当前循环
                if(j>=n) break;
                
                dp[i][j] = s.charAt(i)==s.charAt(j) && ((j-i<=2 || dp[i+1][j-1]));
                if(dp[i][j] && j-i+1>maxLen){
                    maxLen = j-i+1;
                    start = i;
                }
            }
        }
        return s.substring(start, maxLen+start);
    }
}
```