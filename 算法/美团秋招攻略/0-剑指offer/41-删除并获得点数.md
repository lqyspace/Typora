# 740-删除并获得点数

[740-删除并获得点数](https://leetcode.cn/problems/delete-and-earn/description/?envType=study-plan-v2&envId=meituan-2023-fall-sprint)，难度中等

![image-20230909164032762](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202309091640924.png)

题解：这道题有点类似 **打家劫舍** 的问题，可以使用动态规划解决问题，但重点仍然是如何定义dp数组的含义；根据题目中的关系，我们知道如果选择当前值为x的元素，则x-1和x+1都不能被选，同时我们应该选取x的所有元素。所以，我们可以定义一个dp[i]数组，含义为：**以nums[i]结尾的子数组的最大值** 或 **以nums[i]开始的子数组的最大值** 。这两个定义都可以，那么此时对应的状态转移方程为：

$dpp[i]=max(dp[i-1], dp[i-2]+nums[i]*count)  或  dp[i]=max(dp[i+1], dp[i+2]+nums[i]*count)$

代码为：

```java
class Solution {
    public int deleteAndEarn(int[] nums) {
        int maxVal = -1;
        for(int n: nums){
            maxVal = Math.max(maxVal, n);
        }
        int[] count = new int[maxVal+1];
        for(int n: nums){
            count[n]++;
        }
        // dp[i]表示以nums[i]结尾的子数组的最大值
        // dp[i]=max(dp[i-1], dp[i-2]+nums[i]*count)
        int[] dp = new int[maxVal+1];
        dp[0] = 0; dp[1] = count[1] * 1;
        for(int i=2; i<=maxVal; i++){
            dp[i] = Math.max(dp[i-1], dp[i-2]+count[i]*i);
        }
        return dp[maxVal];
    }
}
```

```java
class Solution {
    public int deleteAndEarn(int[] nums) {
        int maxVal = -1;
        for(int n: nums){
            maxVal = Math.max(maxVal, n);
        }
        int[] count = new int[maxVal+1];
        for(int n: nums){
            count[n]++;
        }
        // dp[i]表示从nums[i]开始选取的最大值
        // dp[i] = max(dp[i+1], dp[i+2]+ nums[i]*count);
        int[] dp = new int[maxVal+2];
        dp[maxVal+1] = 0;
        dp[maxVal] = count[maxVal]*maxVal;
        for(int i=maxVal-1; i>=1; i--){
            dp[i] = Math.max(dp[i+1], dp[i+2] + count[i]*i);
        }
        return dp[1];
    }
}
```