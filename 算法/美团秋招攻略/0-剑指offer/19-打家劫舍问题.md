# 198-打家劫舍

[198-打家劫舍](https://leetcode.cn/problems/house-robber/description/?envType=study-plan-v2&envId=meituan-2023-fall-sprint)，难度中等

![image-20230829153252185](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308291532277.png)

题解：

- 状态：每间房子的位置
- 选择：偷或不偷

![img](https://labuladong.github.io/algo/images/robber/1.jpg)

假想你就是这个专业强盗，从左到右走过这一排房子，在每间房子前都有两种**选择**：抢或者不抢。

如果你抢了这间房子，那么你**肯定**不能抢相邻的下一间房子了，只能从下下间房子开始做选择。

如果你不抢这件房子，那么你可以走到下一间房子前，继续做选择。

当你走过了最后一间房子后，你就没得抢了，能抢到的钱显然是 0（**base case**）。

以上的逻辑很简单吧，其实已经明确了「状态」和「选择」：**你面前房子的索引就是状态，抢和不抢就是选择**。

```java
class Solution {
    int[] memo;
    public int rob(int[] nums) {
        memo = new int[nums.length];
        Arrays.fill(memo, -666);
        return dp(nums, 0);// 从第0家开始判断要不要偷
    }

    public int dp(int[] nums, int start){
        // 如果你偷的位置大于等于数组长度，那肯定偷到的金额为0
        if(start>=nums.length)
            return 0;
        if(memo[start]!=-666)
            return memo[start];

        // 偷盗的金额
        memo[start] = Math.max(
            nums[start] + dp(nums, start+2),// 如果你偷了这一家你只能偷下下家
            dp(nums, start+1)
        );

        return memo[start];
    }
}
```

这个解法，用的是递归，每经过一个房子，都会判断要不要偷这间房子，但是真正要计算的结果确实从最后一间房子要不要偷判断出来的，也就是说：我当前这间房子偷不偷，取决于 **我不偷这间房子的收益** 和 **偷了这间房子但下一间房子不能偷** 的收益哪个更多。

所以当前的值取决于后面的值是多少。因此改成自底向上方法的代码就是，我需要倒着遍历，这样才能之后的值来判断当前的值，值不值得投。

```java
class Solution {
    public int rob(int[] nums) {
        // dp[i]表示从i间房子开始抢劫，能够抢到的钱数
        int[] dp = new int[nums.length+2];
        for(int i=nums.length-1; i>=0; i--){
            dp[i] = Math.max(
            	dp[i+2] + nums[i],// 如果偷了当前房子，则只能从下下间房子开始偷起
                dp[i+1]// 如果当前房子不偷，下一件房子可以再决定偷不偷
            );
        }
        return d
    }
}
```

```java
class Solution {
    public int rob(int[] nums) {
        // dp[i]表示从i间房子开始抢劫，能够抢到的钱数
        int dp_i_1 = 0, dp_i_2 = 0;
        int dp_i_0 = 0;
        for(int i = nums.length-1; i>=0; i--){
            dp_i_0 = Math.max(dp_i_1, dp_i_2+nums[i]);
            dp_i_2 = dp_i_1;
            dp_i_1 = dp_i_0;
        }
        return dp_i_0;
    }
}
```

