# 14-最长公共前缀

[14-最长公共前缀](https://leetcode.cn/problems/longest-common-prefix/description/?envType=study-plan-v2&envId=meituan-2023-fall-sprint)，难度简单

![image-20230831111359508](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308311113573.png)

暴力：

```java
class Solution {
    public String longestCommonPrefix(String[] strs) {
        int min_length = Integer.MAX_VALUE;
        for(String s: strs){
            min_length = Math.min(min_length, s.length());
        }
        HashMap<Integer, Character> hm = new HashMap<>();
        StringBuilder sb = new StringBuilder();
        for(int i=0; i<min_length; i++){
            boolean f = true;
            for(int j=0; j<strs.length; j++){
                if(hm.containsKey(i)){
                    if(hm.get(i)==strs[j].charAt(i)) continue;
                    else {
                        f = false;
                        break;// 没必要继续执行下去了
                    }
                } else {
                    hm.put(i, strs[j].charAt(i));
                }
            }
            if(!f) break;// 没必要继续执行下去了
            sb.append(strs[0].charAt(i));
        }
        return sb.toString();
    }
}
```

题解：

你看看，为什么人家写的代码那么简洁有力。

```java
class Solution {
    public String longestCommonPrefix(String[] strs) {
        int m = strs.length;
        int n = strs[0].length();// 以第一行的列数为准
        for(int col=0; col<n; col++){
            for(int row=1; row<m; row++){
                String thisStr = strs[row], preStr = strs[row-1];
                if(col>=thisStr.length() || col>=preStr.length() || thisStr.charAt(col)!=preStr.charAt(col))
                    return strs[0].substring(0, col);
            }
        }
        return strs[0];
    }
}
```

