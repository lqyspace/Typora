# 32-最长有效括号

[32-最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/description/?envType=study-plan-v2&envId=meituan-2023-fall-sprint)，难度困难

![image-20230831131041248](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308311310299.png)

```java
class Solution {
    public int longestValidParentheses(String s) {
		int n = s.length();
        int left = 0, right = 0;
        int res = Integer.MIN_VALUE;
        int sum = 0;
        HashMap<Character, Integer> hm = new HashMap<>();
        hm.put('(', 1);
        hm.put(')', -1);
        while(right<n){
            sum+=hm.get(s.charAt(right++));
            
            while(sum!=0 && right-left>=2){
                sum-=hm.get(s.charAt(left++));
            }
            if(right-left<2)continue;
            if(hm.get(left)=='('){
                res = Math.max(res, right - left);
            }
        }
        return res;
    }
}
```

这个做法是错误的。

用动态规划试试：

```java
class Solution {
    public int longestValidParentheses(String s) {
		int n = s.length();
        boolean[][] dp = new boolean[n][n];
        int start = 0, maxLen = Integer.MIN_VALUE;
        for(int i=n-2; i>=0; i--){
            for(int j=i+1; j<n; j++){
                dp[i][j] = s.charAt(i)=='(' && s.charAt(j)==')' && (dp[i+1][j-1] || j-i==1);
                if(dp[i][j] && j-i+1 > maxLen){
                    start = i;
                    maxLen = j-i+1;
                }
            }
        }
        return maxLen==Integer.MIN_VALUE? 0: maxLen;
    }
}
```

这个方法也是错的。

