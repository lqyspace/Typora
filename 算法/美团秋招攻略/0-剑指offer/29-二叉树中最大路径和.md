# 124-二叉树中最大路径和

[124-二叉树中最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/?envType=study-plan-v2&envId=meituan-2023-fall-sprint)，难度困难

![image-20230901103110821](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202309011031911.png)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int res = Integer.MIN_VALUE;
    public int maxPathSum(TreeNode root) {
		if(root==null) return 0;
        dfs(root);
        return res;
    }
    public int dfs(TreeNode root){
        if(root==null) return 0;
        int left = dfs(root.left);
        int right = dfs(root.right);
        res = Math.max(res, root.val+left+right);
        return left>right? left+root.val: right+root.val;
    }
}
```

这个代码是有问题的，注意理清题意：题目中说，该路径至少包含一个节点，说明可以没有左右子树，也就是左右路径可以选择不走；而且不一定经过根节点，因此在选择左右路径时还需要判断左右子树是否为负数，如果为负数就没必要走这条路径。

正确代码如下：

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int res = Integer.MIN_VALUE;
    public int maxPathSum(TreeNode root) {
		if(root==null) return 0;
        dfs(root);
        return res;
    }
    public int dfs(TreeNode root){
        if(root==null) return 0;
        // 就是说它的左子树和柚子树不一定走
        // 注意理解题意，题中说该路径至少包含一个节点，说明左右子树可以选择不走
        // 且不经过根节点
        // 要想实现路径最大化，如果左右子树为负值，可以选择不走
        int left = Math.max(dfs(root.left), 0);
        int right = Math.max(dfs(root.right), 0);
        res = Math.max(res, root.val+left+right);
        return left>right? left+root.val: right+root.val;
    }
}
```