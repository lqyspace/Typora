# 221-最大正方形

[221-最大正方形](https://leetcode.cn/problems/maximal-square/description/?envType=study-plan-v2&envId=meituan-2023-fall-sprint)，难度中等

![image-20230904180144732](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202309041801804.png)

题解1：暴力解

- 遍历每一个值为1的点，以该点为正方形的左上角，并假设以该点为左上角的正方形内部全部都是1，那么我们就可以得到一个正方形边长 $min(rows-i, cols-j)$
- 然后我们在遍历这个正方形的内部，看这个正方形的内部是否存在1的情况
- 在遍历正方形内部时，每次增加一行以及一列，判断内部的新的正方形是否全都是1

```java
class Solution {
    public int maximalSquare(char[][] matrix) {
        int maxEdge = 0;// 这个边是实际的最大正方形的最大边长
        if(matrix==null || matrix.length==0 || matrix[0].length==0)
            return maxEdge;
        // 遍历每一个点
        int rows = matrix.length, cols = matrix[0].length;
        for(int i=0; int i<rows; i++){
            for(int j=0; j<cols; j++){
                if(matrix[i][j]=='1'){
                    // 假设以该点为左上角的正方形最大
                    int curMax = Math.min(rows-i, cols-j);
                    // 由于正方形的实际边长初始值为0，所以这里可以更新一下
                    maxEdge = Math.max(maxEdge, 1);
                    
                    // 判断该正方形的内部是否存在0
                    for(int k=1; k<curMax; k++){
                        if(matrix[i+k][j+k]=='0') break;
                        boolean flag = true;
                        
                        for(int m=0; m<k; m++){
                            if(matrix[i+k][j+m]=='0' || matrix[i+m][j+k]=='0'){
                                flag = false;
                                break;
                            }
                        }
                        if(flag){
                            maxEdge = Math.max(maxEdge, k+1);
                        }else{
                            break;
                        }
                    }
                }
            }
        }
        return maxEdge*maxEdge;
    }
}
```

题解2：动态规划

设$dp[i][j]$表示以点$(i, j)$为右下角的正方形的最大边长，状态转移方程：

$dp[i][j]=min(dp[i-1][j], dp[j][j-1], dp[i-1][j-1])+1$

```java
class Solution {
    public int maximalSquare(char[][] matrix) {
        if(matrix==null || matrix.length==0 || matrix[0].length==0)
            return 0;
        int m = matrix.length, n = matrix[0].length;
        int[][] dp = new int[m][n];
        // base case
        for(int i=0; i<m; i++){
            dp[i][0] = matrix[i][0] - '0';
        }
        for(int j=0; j<n; j++){
            dp[0][j] = matrix[0][j] - '0';
        }
        int res = -1;
        for(int i=1; i<m; i++){
            for(int j=1; j<n; j++){
                if(matrix[i][j]=='1'){
                    dp[i][j] = Math.min(dp[i-1][j], Math.min(dp[i][j-1], dp[i-1][j-1]))+1;
                }
            }
        }
        for(int i=0; i<m; i++){
            for(int j=0; j<n; j++){
                if(matrix[i][j]=='1'){
                    res = Math.max(res, dp[i][j]);
                }
            }
        }
        return res*res;
    }
}
```

```java
class Solution {
    public int maximalSquare(char[][] matrix) {
        int maxSide = 0;
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return maxSide;
        }
        int rows = matrix.length, columns = matrix[0].length;
        int[][] dp = new int[rows][columns];
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < columns; j++) {
                if (matrix[i][j] == '1') {
                    if (i == 0 || j == 0) {
                        dp[i][j] = 1;
                    } else {
                        dp[i][j] = Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;
                    }
                    maxSide = Math.max(maxSide, dp[i][j]);
                }
            }
        }
        int maxSquare = maxSide * maxSide;
        return maxSquare;
    }
}
```

