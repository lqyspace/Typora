# 今日内容
	1. Junit单元测试
	2. 反射
	3. 注解


## Junit单元测试：
	* 测试分类：
		1. 黑盒测试：不需要写代码，给输入值，看程序是否能够输出期望的值。
		2. 白盒测试：需要写代码的。关注程序具体的执行流程。
	
	* Junit使用：白盒测试
		* 步骤：
			1. 定义一个测试类(测试用例)
				* 建议：
					* 测试类名：被测试的类名Test		CalculatorTest
					* 包名：xxx.xxx.xx.test		cn.itcast.test
	
			2. 定义测试方法：可以独立运行
				* 建议：
					* 方法名：test测试的方法名		testAdd()  
					* 返回值：void
					* 参数列表：空参
	
			3. 给方法加@Test
			4. 导入junit依赖环境
	
		* 判定结果：
			* 红色：失败
			* 绿色：成功
			* 一般我们会使用断言操作来处理结果
				* Assert.assertEquals(期望的结果,运算的结果);
	
		* 补充：
			* @Before:
				* 修饰的方法会在测试方法之前被自动执行
			* @After:
				* 修饰的方法会在测试方法执行之后自动被执行

代码实例：

```java
import cn.itcast.junit.Calculator;
import org.junit.Assert;
import org.junit.Test;

public class CalculatorTest {
    // 测试add方法
    @Test
    public void testAdd(){
//        System.out.println("vixk");
        Calculator c = new Calculator();
        int res = c.add(1,2);
//        System.out.println(res);// 一般不输出，主要是看断言

        // 断言操作，我断言这个结果是3
        Assert.assertEquals(3, res);
    }

    @Test
    public void testSub(){
        Calculator c = new Calculator();
        int res = c.sub(1,2);
        Assert.assertEquals(-1, res);
    }
}
```

总结：一般我们在测试里是主要看是红色还是绿色，一般是不使用输出语句的，而是看断言的结果，断言的结果如果是红色，说明输出的结果和预期的结果不一致，程序有问题；如果是绿色，说明输出的结果和程序的结果一致，程序没有问题。



代码实例：

```java
import cn.itcast.junit.Calculator;
import org.junit.After;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;

public class CalculatorTest {
    /**
     * 初始化方法：
     *  用于资源的申请：所有测试方法在执行之前都会先执行该方法
     */
    @Before
    public void init(){
        System.out.println("init...");
    }

    /**
     * 释放资源方法：
     *  在所有测试方法执行完了以后，都会自动执行该方法
     */
    @After
    public void close(){
        System.out.println("close...");
    }
    // 测试add方法
    @Test
    public void testAdd(){
//        System.out.println("vixk");
        Calculator c = new Calculator();
        int res = c.add(1,2);
        System.out.println("testAdd...");
//        System.out.println(res);// 一般不输出，主要是看断言

        // 断言操作，我断言这个结果是3
        Assert.assertEquals(3, res);
    }

    @Test
    public void testSub(){
        Calculator c = new Calculator();
        int res = c.sub(1,2);
        System.out.println("testSub...");
        Assert.assertEquals(-1, res);
    }
}
```

输出：

```java
init...
testAdd...
close...

java.lang.AssertionError: 
Expected :3
Actual   :-1
<Click to see difference>


	at org.junit.Assert.fail(Assert.java:89)
	at org.junit.Assert.failNotEquals(Assert.java:835)
	at org.junit.Assert.assertEquals(Assert.java:647)
	at org.junit.Assert.assertEquals(Assert.java:633)
	at cn.itcast.test.CalculatorTest.testAdd(CalculatorTest.java:29)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
```

总结：@After修饰的方法，即使在程序运行的过程中出现异常，也不影响@After修饰的方法的执行。



## 反射：框架设计的灵魂

	* 框架：半成品软件。可以在框架的基础上进行软件开发，简化编码
	* 反射：将类的各个组成部分封装为其他对象，这就是反射机制
		* 好处： 
			1. 可以在程序运行过程中，操作这些对象。
			2. 可以解耦，提高程序的可扩展性。


	* 获取Class对象的方式：
		1. Class.forName("全类名")：将字节码文件加载进内存，返回Class对象
			* 多用于配置文件，将类名定义在配置文件中。读取文件，加载类
		2. 类名.class：通过类名的属性class获取
			* 多用于参数的传递
		3. 对象.getClass()：getClass()方法在Object类中定义着。
			* 多用于对象的获取字节码的方式
	
		* 结论：
			同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个。


	* Class对象功能：
		* 获取功能：
			1. 获取成员变量们
				* Field[] getFields() ：获取所有public修饰的成员变量
				* Field getField(String name)   获取指定名称的 public修饰的成员变量
	
				* Field[] getDeclaredFields()  获取所有的成员变量，不考虑修饰符
				* Field getDeclaredField(String name)  
			2. 获取构造方法们
				* Constructor<?>[] getConstructors()  
				* Constructor<T> getConstructor(Class<?>... parameterTypes)  
	
				* Constructor<T> getDeclaredConstructor(Class<?>... parameterTypes)  
				* Constructor<?>[] getDeclaredConstructors()  
			3. 获取成员方法们：
				* Method[] getMethods()  
				* Method getMethod(String name, Class<?>... parameterTypes)  
	
				* Method[] getDeclaredMethods()  
				* Method getDeclaredMethod(String name, Class<?>... parameterTypes)  
	
			4. 获取全类名	
				* String getName()  


	* Field：成员变量
		* 操作：
			1. 设置值
				* void set(Object obj, Object value)  
			2. 获取值
				* get(Object obj) 
	
			3. 忽略访问权限修饰符的安全检查
				* setAccessible(true):暴力反射
	
	* Constructor:构造方法
		* 创建对象：
			* T newInstance(Object... initargs)  
	
			* 如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance方法


	* Method：方法对象
		* 执行方法：
			* Object invoke(Object obj, Object... args)  
	
		* 获取方法名称：
			* String getName:获取方法名



代码实例：获取成员变量

```java
public class ReflectDemo02 {
    public static void main(String[] args) throws Exception {
        Class c = Class.forName("cn.itcast.domain.Person");
        System.out.println("------------获取public修饰的成员变量");

        // 获取成员变量
        Field[] fields = c.getFields();
        for (Field f : fields) {
            System.out.println(f);
        }
        System.out.println("--------------获取所有的成员变量");
        Field[] fields1 = c.getDeclaredFields();
        for (Field f : fields1) {
            System.out.println(f);
        }
        System.out.println("----------------获取单个成员变量");
        Field a = c.getField("a");
        // 获取成员变量a的值
        Person p = new Person();
        Object value= a.get(p);
        System.out.println(value);

        System.out.println("--------------设置单个成员变量的值");
        a.set(p, "123");
        System.out.println(p);

        System.out.println("----------获取私有的d");
        Field dfield = c.getDeclaredField("d");
        System.out.println(dfield);
        dfield.setAccessible(true);
        Object val2 = dfield.get(p);
        System.out.println(val2);
    }
}
```

输出：

```java
------------获取public修饰的成员变量
public java.lang.String cn.itcast.domain.Person.a
--------------获取所有的成员变量
private java.lang.String cn.itcast.domain.Person.name
private int cn.itcast.domain.Person.age
public java.lang.String cn.itcast.domain.Person.a
protected java.lang.String cn.itcast.domain.Person.b
java.lang.String cn.itcast.domain.Person.c
private java.lang.String cn.itcast.domain.Person.d
----------------获取单个成员变量
null
--------------设置单个成员变量的值
Person{name='null', age=0, a='123', b='null', c='null', d='null'}
----------获取私有的d
private java.lang.String cn.itcast.domain.Person.d
null
```

代码实例：获取构造器

```java
public class ReflectDemo03 {
    public static void main(String[] args) throws Exception {
        Class personClass = Class.forName("cn.itcast.domain.Person");
        // 获取构造方法
        Constructor con = personClass.getConstructor(String.class, int.class);
        // 创建对象
        Object per = con.newInstance("张三",23);
        System.out.println(per);
        
        System.out.println("---------------");
//        Constructor con1 = personClass.getConstructor();
//        Object per1 = con1.newInstance();
//        System.out.println(per1);
        // 如果使用空参构造方法，可以简化：直接使用Class对象的newInstance方法
        Object per1 = personClass.newInstance();
        System.out.println(per1);
    }
}
```

输出：

```java
Person{name='张三', age=23, a='null', b='null', c='null', d='null'}
---------------
Person{name='null', age=0, a='null', b='null', c='null', d='null'}
```

代码实例：获取成员方法

```java
public class ReflectDemo04 {
    public static void main(String[] args) throws Exception {
        Class perClass = Class.forName("cn.itcast.domain.Person");

        Method[] ms = perClass.getDeclaredMethods();
        for (Method m : ms) {
            System.out.println(m);
        }

        System.out.println("-----------------");

        Method m = perClass.getMethod("eat", String.class);
        Constructor con = perClass.getConstructor();
        Object o = con.newInstance();
        m.invoke(o, "苹果");
        System.out.println(m.getName());// eat
        
        System.out.println("--------------------");
        // 获取类名
        String className = perClass.getName();
        System.out.println(className);
    }
}
```

输出：

```
public java.lang.String cn.itcast.domain.Person.toString()
public java.lang.String cn.itcast.domain.Person.getName()
public void cn.itcast.domain.Person.setName(java.lang.String)
public void cn.itcast.domain.Person.eat()
public void cn.itcast.domain.Person.eat(java.lang.String)
public int cn.itcast.domain.Person.getAge()
public void cn.itcast.domain.Person.setAge(int)
-----------------
中午你想吃什么？_-苹果
eat
--------------------
cn.itcast.domain.Person
```

---

* 案例：
	* 需求：写一个"框架"，不能改变该类的任何代码的前提下，可以帮我们创建任意类的对象，并且执行其中任意方法
		* 实现：
			1. 配置文件
			2. 反射
		* 步骤：
			1. 将需要创建的对象的全类名和需要执行的方法定义在配置文件中
			2. 在程序中加载读取配置文件
			3. 使用反射技术来加载类文件进内存
			4. 创建对象
			5. 执行方法

pro.properties文件：

```java
className =cn.itcast.domain.Person
methodName = eat
```

```java
public class ReflectDemo05 {
    public static void main(String[] args) throws IOException, ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException {
        Properties prop = new Properties();
        ClassLoader classLoader = ReflectDemo05.class.getClassLoader();
        InputStream resourceAsStream = classLoader.getResourceAsStream("pro.properties");
        prop.load(resourceAsStream);


        String className = prop.getProperty("className");
        String methodName = prop.getProperty("methodName");
        Class c = Class.forName(className);
        Object o = c.newInstance();
        Method m = c.getMethod(methodName);
        m.invoke(o);
    }
}
```

输出：

```
中午你想吃什么？
```





## 注解

	* 概念：说明程序的。给计算机看的
	* 注释：用文字描述程序的。给程序员看的
	
	* 定义：注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。
	* 概念描述：
		* JDK1.5之后的新特性
		* 说明程序的
		* 使用注解：@注解名称
	
	* 作用分类：
		①编写文档：通过代码里标识的注解生成文档【生成文档doc文档】
		②代码分析：通过代码里标识的注解对代码进行分析【使用反射】
		③编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】



**如何使用注解生成说明文档：**

1. 首先创建一个类中，类中有注解以及函数和参数的说明，如下图所示：

   ![image-20230629223655321](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306292236383.png)

2. 将Annotation.java单独复制到一个新建文件夹下，打开这个文件并将里面的package路径删掉，在当前文件夹中打开终端，输入如下指令：

   ![image-20230629223831765](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306292238820.png)

   ![image-20230629223903285](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306292239352.png)

3. 打开生成的文件夹下的index.html：

   ![image-20230629223958750](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306292239841.png)

   

4. 打开之后就可以看到如下的说明文档：

   ![image-20230629224055224](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306292240322.png)

   ---


	* JDK中预定义的一些注解
		* @Override	：检测被该注解标注的方法是否是继承自父类(接口)的
		* @Deprecated：该注解标注的内容，表示已过时
		* @SuppressWarnings：压制警告
			* 一般传递参数all  @SuppressWarnings("all")
	
	* 自定义注解
		* 格式：
			元注解
			public @interface 注解名称{
				属性列表;
			}
	
		* 本质：注解本质上就是一个接口，该接口默认继承Annotation接口
			* public interface MyAnno extends java.lang.annotation.Annotation {}
	
		* 属性：接口中的抽象方法
			* 要求：
				1. 属性的返回值类型有下列取值
					* 基本数据类型
					* String
					* 枚举
					* 注解
					* 以上类型的数组
	
				2. 定义了属性，在使用时需要给属性赋值
					1. 如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。
					2. 如果只有一个属性需要赋值，并且属性的名称是value，则value可以省略，直接定义值即可。
					3. 数组赋值时，值使用{}包裹。如果数组中只有一个值，则{}可以省略
		
		* 元注解：用于描述注解的注解
			* @Target：描述注解能够作用的位置
				* ElementType取值：
					* TYPE：可以作用于类上
					* METHOD：可以作用于方法上
					* FIELD：可以作用于成员变量上
			* @Retention：描述注解被保留的阶段
				* @Retention(RetentionPolicy.RUNTIME)：当前被描述的注解，会保留到class字节码文件中，并被JVM读取到
				* @Retention(RetentionPolicy.CLASS)：也会被保留到字节码文件中，但是不会被JVM读取到
				* @Retention(RetentionPolicy.SOURCE)：字节码文件夹都不会存在这个注解。
			* @Documented：描述注解是否被抽取到api文档中
				* 如果加了这个注解，那么在生成api文档时，会把注解也给添加上，如下图所示：
			* @Inherited：描述注解是否被子类继承
				* 如果一个类的注解里面包含@Inherited，那么这个类的子类继承这个类的时候，也会自动继承这个类上的注解

![image-20230630000118336](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306300001402.png)

![image-20230630000143593](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306300001652.png)

![image-20230630000210409](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306300002465.png)

使用以上代码生成了api文档 ，且MyAnno3.java的注解中加入了@Document，因此生成的api文档中包含注解。

![image-20230630000308897](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306300003980.png)

否则，不包含注解。

![image-20230630000416257](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306300004351.png)





**编译与反编译：**

![image-20230629225442279](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306292254335.png)

我们可以使用 `javac MyAnno.java`来编译我们的注解文件，然后再使用 `javap MyAnno.java`来反编译我们的注解文件（.class文件），之后的输出我们就可以看见源码了。



**给注解添加属性的方式：**

Person类：

```java
public enum Person {// 枚举类型
    P1,P2;
}
```

MyAnno类：

```java
public @interface MyAnno {
    int age();
    String name() default "张三";
}
```

![image-20230629233149972](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306292331034.png)

Work类：

```java
@MyAnno2(age = 12, per = Person.P1, anno1 = @MyAnno(age = 1), strs = {"abc", "bcb"})
public class Worker {
}

或者
    
@MyAnno2(age = 12, per = Person.P1, anno1 = @MyAnno(show1 = 1), strs = "abc")
public class Worker {
}
```

注意：

- 如果定义了属性，就需要给属性赋值。
- 如果有多个属性，就需要给多个属性同时赋值
- 如果一个属性用 default 定义了默认值，那么在使用注解的时候可以不给这个属性赋值。
- 如果只有一个属性需要赋值，并且属性的名称为value，那么在使用注解的时候可以不写value，直接写定义值即可。
- 数组赋值时，值使用 {} 包裹，如果数组中只有一个值，则 {} 省略。

---


	* 在程序使用(解析)注解：获取注解中定义的属性值
		1. 获取注解定义的位置的对象  （Class，Method,Field）
		2. 获取指定的注解
			* getAnnotation(Class)
			//其实就是在内存中生成了一个该注解接口的子类实现对象
	
		            public class ProImpl implements Pro{
		                public String className(){
		                    return "cn.itcast.annotation.Demo1";
		                }
		                public String methodName(){
		                    return "show";
		                }
		            }
		3. 调用注解中的抽象方法获取配置的属性值

注意：在后期，把配置文件的操作交给注解来完成，注解大多数是用来替换配置文件的。

实例代码：

```java
import java.lang.reflect.Method;

@MyProperties(className = "cn.itcast.annotation.Demo1", methodName = "show")
public class ReflectDemo01 {
    public static void main(String[] args) throws Exception {
        /**
         * 不能改变任何代码，可以创建任意类的对象，可以执行任意方法
         * */
        /**
         * 以前我们是通过配置文件来完成创建，现在我们来使用自定义注解@MyProperties
         */
        // 1. 解析注解
        // 1.1 获取该类的字节码文件对象
        Class<ReflectDemo01> reflectDemo01Class = ReflectDemo01.class;

        // 2. 获取上边的注解对象
        // 其实就是在内存中生成了一个该注解接口的子类实现对象
        /*
        * public class PropertiesImpl implements Properties {
        *   public String className(){
        *       return "cn.itcast.annotation.Demo1";
        *   }
        *
        *   public String show() {
        *       return "show";
        *   }
        * }
        *
        *
        * */
        MyProperties mp = reflectDemo01Class.getAnnotation(MyProperties.class);

        // 3. 调用注解中定义的抽象方法，获取返回值
        String className = mp.className();
        String methodName = mp.methodName();

        Class<?> c = Class.forName(className);
        Object o = c.newInstance();
        Method m = c.getMethod(methodName);
        m.invoke(o);
    }
}
```

**总结**：使用注解的步骤

- 获取注解定义的位置的字节码对象（Class，Method，Field）
- 获取该字节码对象上的指定的注解
  - getAnnotation(Class)
  - 实际上是在内存中生成一个该注解接口的子类实现类对象
- 调用注解中的抽象方法获取配置的属性值






	* 案例：简单的测试框架
	* 小结：
		1. 以后大多数时候，我们会使用注解，而不是自定义注解
		2. 注解给谁用？
			1. 编译器
			2. 给解析程序用
		3. 注解不是程序的一部分，可以理解为注解就是一个标签

代码实例：

注解类：

```java
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/*
* 定义@Check，用于检查程序是否出错
* */
@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface Check {
}
```

计算器类：

```java
public class Calculator {
    @Check
    public void add(){
        String str = null;
        str.toString();
        System.out.println("1 + 0 = " + (1+0));
    }
    @Check
    public void sub(){
        System.out.println("1 - 0 = "+ (1-0));
    }
    @Check
    public void mul(){
        System.out.println("1 * 0 = "+ (1 * 0));
    }
    @Check
    public void div(){
        System.out.println("1 / 0 = " + (1/0) );
    }

    public void show(){
        System.out.println("no bug...");
    }
}
```

测试类：

```java
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

public class CheckTest {
    public static void main(String[] args) throws IOException {
        // 获取Calcutor对象
        Calculator calcu = new Calculator();
        //获取对象的字节码对象
        Class<?> c = calcu.getClass();
        // 获取@Check的方法
        Method[] methods = c.getMethods();

        int number = 0;// 出现异常的次数
        BufferedWriter bw = new BufferedWriter(new FileWriter("bug.txt"));
        for (Method method : methods) {
            // 判断方法上是否有注解
            if (method.isAnnotationPresent(Check.class)){
                try {
                    // 如果方法上有@Check这个注解，那么就调用方法，出现的异常在这里捕获并处理
                    method.invoke(calcu);
                } catch (Exception e) {
                    // 说明出现异常
                    number++;
                    bw.write(method.getName()+ "方法出现异常了：");
                    bw.newLine();
                    bw.write("出现异常的名称："+e.getCause().getClass().getSimpleName());
                    bw.newLine();
                    bw.write("出现异常的原因："+e.getCause().getMessage());
                    bw.newLine();
                    bw.write("-----------------");
                    bw.newLine();
                }
            }
        }
        bw.write("本次测试一共出现了 " + number + " 此异常。");
        bw.flush();
        bw.close();
    }
}
```

总结：

- 这个解题思路大致如下：
  - 先声明一个一个自定义的@Check类
  - 然后再定义一个Calcutor类，将里面需要进行检验的方法打上注解@Check
  - 最后在测试类里：1.获取Calcutor类的字节码对象；2.获取里面被@Check注解的方法；3.调用里面的方法，如果出现了异常，那么就在这个测试类里面解决异常
- 其实只不过是在测试类里面获取了注解@Check的字节码对象
- 最后在测试类里面判断有注解@Check的程序是否会出现异常，如果有异常的话就立即处理。

