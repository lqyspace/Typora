# 共享模型之管程

## 0 本章内容

- 共享问题
- synchronized
- 线程安全分析
- Monitor
- wait/notify
- 线程状态转换
- 活跃性
- Lock



## 1 共享带来的问题

### 1.1 小故事

![image-20230823230716801](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308232307942.png)

![image-20230823230806980](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308232308092.png)

![image-20230823230822404](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308232308454.png)

### 1.2 Java的体现

```java
@Slf4j(topic = "c.Test20")
public class Test20 {
    static int counter = 0;

    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(()->{
            for (int i=0; i<5000; i++){
                counter++;
            }
        }, "t1");

        Thread t2 = new Thread(()->{
            for (int i=0; i<5000; i++)
                counter--;
        }, "t2");

        t1.start();
        t2.start();
        t1.join();
        t2.join();
        log.debug("{}", counter);
    }
}
```

输出：

```java
23:11:45.587 c.Test20 [main] - 1439
```

### 1.3 问题分析

以上代码的结果可能正数，负数，零，为什么呢？因为Java对静态变量的自增，自减不是原子操作，要彻底理解，必须从字节码来进行分析

例如对于`i++`而言（i是静态变量），实际上会产生如下的JVM字节码指令：

```java
getstatic i // 获取静态变量i的值
iconst_1 // 准备常量1
iadd // 自增
putstatic i // 将修改后的值存入静态变量i
```

而对应`i--`也是类似

```java
getstatic i // 获取静态变量i的值
iconst_1 // 准备常量1
isub // 自减
putstatic i // 将修改后的值存入静态变量i
```

而在Java的内存模型中，完成静态变量的自增，自减需要在主存和工作内存进行数据交换：

![image-20230823232534096](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308232325176.png)

如果是单线程，以上8行代码是顺序执行（不会交错）没有问题：

![image-20230823232626771](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308232326861.png)

但是多线程这8行代码可能交错运行：

出现负数的情况：

![image-20230823232833023](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308232328098.png)

出现正数的情况：

![image-20230823232851605](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308232328683.png)

### 1.4 临界区Critical Section

- 一个程序运行多个线程本身是没有问题的
- 问题出在多个线程共同访问共享资源
  - 多个线程读共享资源其实也没有问题
  - 在多个线程对共享资源读写操作时发生指令交错，就会出现问题
- 一段代码内如果存在对共享资源的多线程读写操作，称这段代码为**临界区**

例如下面代码中的临界区：

```java
static int counter = 0;
static void increment()
// 临界区
{
 counter++;
}
static void decrement()
// 临界区
{
 counter--;
}
```



### 1.5 竞态条件Race Condition

**多个线程在临界区内执行**，由于代码的**执行序列不同**而导致结果无法预测，称之为发生了**竞争条件**。





## 2 synchronized

### 2.1 应用之互斥

为了避免临界区的竞态条件发生，有多种手段额可以达到目的：

- 阻塞式的解决方案：synchronized、Lock
- 非阻塞式的解决方案：原子变量

本次课使用阻塞式的解决方案：synchronized，来解决上述问题，即俗称的【对象锁】，它采用互斥的方式让同一 时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住。

这样就能保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换。

> 注意
>
> 虽然Java中的互斥和同步都采用synchronized关键字来完成，但是它们还是有区别的：
>
> - 互斥是保证临界区的竞争条件不发生，同一时刻只能有一个线程执行临界区的代码
> - 同步是由于线程执行的先后，顺序不同，需要一个线程去等待其他线程运行到某个点



### 2.2 synchronized

语法

```java
synchronized(对象) // 线程1， 线程2(blocked)
{
 临界区
}
```

解决：

```java
@Slf4j(topic = "c.Test20")
public class Test20 {
    static int counter = 0;
    static final Object room = new Object();

    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(()->{
            for (int i=0; i<5000; i++){
                synchronized (room) {
                    counter++;
                }
            }
        }, "t1");

        Thread t2 = new Thread(()->{
            for (int i=0; i<5000; i++) {
                synchronized(room) {
                    counter--;
                }
            }
        }, "t2");

        t1.start();
        t2.start();
        t1.join();
        t2.join();
        log.debug("counter = {}", counter);
    }
}
```

输出：

```java
23:43:58.560 c.Test20 [main] - counter = 0
```

![image-20230823234947974](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308232349028.png)

你可以做这样的类比： 

- `synchronized(对象)` 中的对象，可以想象为一个房间（room），有唯一入口（门）房间只能一次进入一人进行计算，线程 `t1`，`t2` 想象成两个人 
- 当线程 `t1` 执行到 synchronized(room) 时就好比 `t1` 进入了这个房间，并锁住了门拿走了钥匙，在门内执行 `count++` 代码 
- 这时候发生了上下文切换， `t2` 也运行到了 synchronized(room) 尝试获取锁，它发现门被锁住了，只能在门外等待，阻塞住了 
- 这中间即使 `t1` 的 `cpu` 时间片不幸用完，被踢出了门外（不要错误理解为锁住了对象就能一直执行下去哦）， 这时门还是锁住的，`t1` 仍拿着钥匙，`t2` 线程还在阻塞状态进不来，只有下次轮到 `t1` 自己再次获得时间片时才 能开门进入
- 当 `t1` 执行完 synchronized{} 块内的代码，这时候才会从 obj 房间出来并解开门上的锁，唤醒 `t2` 线程把钥匙给他。`t2` 线程这时才可以进入 obj 房间，锁住了门拿上钥匙，执行它的 `count--` 代码

用图表示：

![image-20230823235440600](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308232354692.png)

### 2.3 思考

synchronized实际是用**对象锁**保证了**临界区内代码的原子性**，临界区内的代码对外是不可分割的，不会被线程切换所打断。

为了加深理解，请思考下面的问题：

- 如果把synchronized(obj)放在for循环的外面，如何理解？——原子性
  - 相当于一开始只执行自加或者自减，等一个操作执行完释放锁之后，另一个操作继续执行
- 如果t1`synchronized(obj1)`而t2`synchronized(obj2)`会怎么样运行？——锁对象
  - 无法保护临界区代码，两者持有的锁不一样，必须给同一个对象加锁才行
- 如果t1`synchronized(obj)`而t2没有加会怎么样？如何理解？——锁对象
  - t2会肆无忌惮的执行，t1的锁并不影响t2



### 2.4 面向对象改进

把需要保护的共享变量放入一个类

```java
class Room{
    int value = 0;
    public void increment(){
        synchronized (this){
            value++;
        }
    }

    public void decrement(){
        synchronized(this){
            value--;
        }
    }

    public int get(){
        synchronized (this){
            return value;
        }
    }
}

@Slf4j(topic = "c.Test21")
public class Test21 {
    public static void main(String[] args) throws InterruptedException {
        Room room = new Room();
        Thread t1 = new Thread(()->{
           for (int i=0; i<5000; i++)
               room.increment();
        }, "t1");

        Thread t2 = new Thread(()->{
            for (int i=0; i<5000; i++)
                room.decrement();
        }, "t2");
        
        t1.start();
        t2.start();
        t1.join();
        t2.join();

        log.debug("counter : {}", room.get());
    }
}
```

输出：

```java
00:07:02.657 c.Test21 [main] - counter : 0
```



## 3 方法上的synchronized

语法：synchronized只能锁对象，把synchronized加在成员方法上表示锁住的是this这个对象。

```java
class Test{
     public synchronized void test() {

     }
}

等价于
    
class Test{
     public void test() {
         synchronized(this) {

         }
     }
}    
```

```java
class Test{
    public synchronized static void test(){
        
    }
}

等价于

class Test{
    public static void test(){
        synchronized(Test.class){
            
        }
    }
}
```

不加synchronized的方法就好比不遵守规则的人，不去老实的排队（好比翻窗户进去的）



### 3.1 线程八锁

情:1：12或21

```java
@Slf4j(topic = "c.Number")
class Number{
     public synchronized void a() {
     	log.debug("1");
     }
     public synchronized void b() {
     	log.debug("2");
     }
}
public static void main(String[] args) {
     Number n1 = new Number();
     new Thread(()->{ n1.a(); }).start();
     new Thread(()->{ n1.b(); }).start();
}
```



情况2：1s后12 或  2 1s后1

```java
@Slf4j(topic = "c.Number")
class Number{
 public synchronized void a() {
 sleep(1);
 log.debug("1");
 }
 public synchronized void b() {
 log.debug("2");
 }
}
public static void main(String[] args) {
 Number n1 = new Number();
 new Thread(()->{ n1.a(); }).start();
 new Thread(()->{ n1.b(); }).start();
}

```



情况3: 3  1s后12 或 23  1s后1  或  32  1s后1

```java
class Number{
 public synchronized void a() {
     sleep(1);
     log.debug("1");
 }
 public synchronized void b() {
 	log.debug("2");
 }
 public void c() {
 	log.debug("3");
 }
}
public static void main(String[] args) {
     Number n1 = new Number();
     new Thread(()->{ n1.a(); }).start();
     new Thread(()->{ n1.b(); }).start();
     new Thread(()->{ n1.c(); }).start();
}

```

注意：c没有加锁，因此c不受限制



情况4:  2   1s后1

```java
@Slf4j(topic = "c.Number")
class Number{
     public synchronized void a() {
         sleep(1);
         log.debug("1");
     }
     public synchronized void b() {
         log.debug("2");
     }
}
public static void main(String[] args) {
     Number n1 = new Number();
     Number n2 = new Number();
     new Thread(()->{ n1.a(); }).start();
     new Thread(()->{ n2.b(); }).start();
}

```

两个线程锁的对象不一样，几乎同时运行，但是a方法需要睡一秒，因此先输出2



情况5:  2   1s后1

```java
@Slf4j(topic = "c.Number")
class Number{
     public static synchronized void a() {
         sleep(1);
         log.debug("1");
     }
     public synchronized void b() {
     	log.debug("2");
     }
}
public static void main(String[] args) {
     Number n1 = new Number();
     new Thread(()->{ n1.a(); }).start();
     new Thread(()->{ n1.b(); }).start();
}
```

两个线程的锁对象不一样，所以几乎同时运行，a方法会休息一秒，所以先输出2，然后1s后输出1



情况6:  1s后12  或  2  1s后1

```java
@Slf4j(topic = "c.Number")
class Number{
     public static synchronized void a() {
         sleep(1);
         log.debug("1");
     }
     public static synchronized void b() {
     	log.debug("2");
     }
}
public static void main(String[] args) {
     Number n1 = new Number();
     new Thread(()->{ n1.a(); }).start();
     new Thread(()->{ n1.b(); }).start();
}
```





情况7:  2  1s后1

```java
@Slf4j(topic = "c.Number")
class Number{
     public static synchronized void a() {
         sleep(1);
         log.debug("1");
     }
     public synchronized void b() {
     	log.debug("2");
     }
}
public static void main(String[] args) {
     Number n1 = new Number();
     Number n2 = new Number();
     new Thread(()->{ n1.a(); }).start();
     new Thread(()->{ n2.b(); }).start();
}
```

锁对象不一样，相当于没有锁，先输出2，然后1s后输出1





情况8:  1s后12   或   2   1s后1

```java
class Number{
     public static synchronized void a() {
         sleep(1);
         log.debug("1");
     }
     public static synchronized void b() {
         log.debug("2");
     }
}
public static void main(String[] args) {
     Number n1 = new Number();
     Number n2 = new Number();
     new Thread(()->{ n1.a(); }).start();
     new Thread(()->{ n2.b(); }).start();
}
```

锁对象一样，都是类的字节码



## 4 变量的线程安全分析

**成员变量和静态变量是否线程安全？**

- 如果它们没有共享，则线程安全
- 如果他们被共享，根据他们的状态是否能够改变，又分为两种情况
  - 如果只有读操作，则是线程安全的
  - 如果有读写操作，则这段代码是临界区，需要考虑线程安全



**局部变量是否线程安全？**

- 局部变量是线程安全的
- 但局部变量引用的对象则未必
  - 如果该对象没有逃离方法的作用范围，它是线程安全的
  - 如果该对象逃离了方法的作用范围，需要考虑线程安全





**局部变量线程安全分析**

```java
public static void test1() {
 int i = 10;
 i++;
}
```

每个线程调用 `test1()` 方法时局部变量 `i`，会在每个线程的栈帧内存中被创建多份，因此**==不存在共享==**。

```java
public static void test1();
 descriptor: ()V
 flags: ACC_PUBLIC, ACC_STATIC
 Code:
 stack=1, locals=1, args_size=0
 0: bipush 10
 2: istore_0
 3: iinc 0, 1
 6: return
 LineNumberTable:
 line 10: 0
 line 11: 3
 line 12: 6
 LocalVariableTable:
 Start Length Slot Name Signature
 3 4 0 i I
```

![image-20230824220749737](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308242207825.png)



局部变量的引用稍有不同

先看一个成员变量的例子：

```java
class ThreadUnsafe {
     ArrayList<String> list = new ArrayList<>();
     public void method1(int loopNumber) {
         for (int i = 0; i < loopNumber; i++) {
             // { 临界区, 会产生竞态条件
             method2();
             method3();
                 // } 临界区
         }
     }
     private void method2() {
     	list.add("1");
     }
     private void method3() {
     	list.remove(0);
     }
}
```

执行：

```java
public class Test23 {
    static final int THREAD_NUMBER = 2;
    static final int LOOP_NUMBER = 200;

    public static void main(String[] args) {
        ThreadUnSafe tus = new ThreadUnSafe();
        for(int i=0; i<THREAD_NUMBER; i++){
            new Thread(()->{
                tus.method1(LOOP_NUMBER);
            }, "Thread-"+i).start();
        }
    }
}
```

其中一种情况：

```
Exception in thread "Thread-0" Exception in thread "Thread-1" java.lang.ArrayIndexOutOfBoundsException: -1
	at java.util.ArrayList.remove(ArrayList.java:507)
	at org.lqy.test.ThreadUnSafe.method3(Test23.java:33)
	at org.lqy.test.ThreadUnSafe.method1(Test23.java:24)
	at org.lqy.test.Test23.lambda$main$0(Test23.java:13)
	at java.lang.Thread.run(Thread.java:750)
java.lang.ArrayIndexOutOfBoundsException: -1
	at java.util.ArrayList.add(ArrayList.java:465)
	at org.lqy.test.ThreadUnSafe.method2(Test23.java:29)
	at org.lqy.test.ThreadUnSafe.method1(Test23.java:23)
	at org.lqy.test.Test23.lambda$main$0(Test23.java:13)
	at java.lang.Thread.run(Thread.java:750)
```

分析：

> 在多线程环境下，往同一个`ArrayList`中添加数据可能会存在线程安全问题。因为`ArrayList`不是线程安全的，如果多个线程同时往`ArrayList`中添加数据，可能会导致数据不一致或者抛出`ConcurrentModificationException`等异常。
>
> 这是因为多个线程同时修改同一个`ArrayList`时，可能会出现以下情况：
>
> - 写覆盖问题：多个线程同时写入同一个位置的数据，可能会导致数据被覆盖，或者某些数据没有被写入。
>
> - 写丢失问题：多个线程同时在`ArrayList`中添加数据，可能会导致某些数据丢失，因为它们会覆盖其他线程添加的数据。
>
> - 索引越界问题：由于多个线程同时修改`ArrayList`，可能会导致`ArrayList`的大小发生变化，从而导致某些线程访问数组越界。
>
>
> 因此，在多线程环境下，为了保证`ArrayList`的线程安全，可以使用以下几种方式：
>
> - 使用线程安全的容器：例如`ConcurrentLinkedQueue`、`CopyOnWriteArrayList`等线程安全的容器，它们可以保证在多线程环境下不会出现线程安全问题。
>
> - 使用`synchronized`关键字：在多线程环境下，使用`synchronized`关键字可以保证同一时间只有一个线程访问`ArrayList`，从而避免线程安全问题。
>
> - 使用`Lock`接口：与`synchronized`关键字类似，使用`Lock`接口也可以保证同一时间只有一个线程访问`ArrayList`，从而避免线程安全问题。
>
>
> 总之，多线程往同一个`ArrayList`中添加数据可能会存在线程安全问题，为了保证线程安全，可以使用线程安全的容器、`synchronized`关键字或者`Lock`接口。



![image-20230824231727758](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308242317858.png)

将list改为局部变量：

```java
class ThreadSafe {
     public final void method1(int loopNumber) {
         ArrayList<String> list = new ArrayList<>();
         for (int i = 0; i < loopNumber; i++) {
             method2(list);
             method3(list);
         }
     }
     private void method2(ArrayList<String> list) {
     	list.add("1");
     }
     private void method3(ArrayList<String> list) {
     	list.remove(0);
     }
}
```

就不会有上面的问题。

分析：

- list是局部变量，每个线程调用时会创建不同实例，没有共享
- 而method2的参数是从method1中传过来的，与method1引用同一个对象
- method3引用的对象与method1中是同一个对象

![image-20230824232840985](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308242328072.png)

访问修饰符带来的思考，如果把method2和method3的方法修改为public，会不会出现线程安全问题？

- 情况1：有其他的线程调用method2和method3
  - 不会出现线程安全问题，因为method2和method3的list都是来自各自的线程的method1的list，不存在共享变量，所以不存在线程安全问题
- 情况2：在情况1的基础上，为ThreadSafe添加子类，在子类里重写了method2或method3的方法，即

```java
class ThreadSafe {
    // 使用final可以防止子类重写该方法
     public final void method1(int loopNumber) {
         ArrayList<String> list = new ArrayList<>();
         for (int i = 0; i < loopNumber; i++) {
             method2(list);
             method3(list);
         }
     }
     private void method2(ArrayList<String> list) {
     	list.add("1");
     }
    
     private void method3(ArrayList<String> list) {
     	list.remove(0);
     }
}
class ThreadSafeSubClass extends ThreadSafe{
     @Override
     public void method3(ArrayList<String> list) {
         new Thread(() -> {
         	list.remove(0);
         }).start();
     }
}
```

所以是会出现线程安全问题的。

> 从这个例子可以看private或final提供【安全】的意义所在，请体会开闭原则中的【闭】





**常见的线程安全的类**

- String
- Integer
- StringBuffer
- Random
- Vector
- HashTable
- java.util.concurrent 包下的类

这里说他们是线程安全的是指，多个线程调用他们同一个实例的某个方法时，是线程安全的。也可以理解为

```java
Hashtable table = new Hashtable();

new Thread(()->{
 table.put("key", "value1");
}).start();

new Thread(()->{
 table.put("key", "value2");
}).start();
```

- 它们的每个方法都是原子的，因为它们的方法都用synchronized修饰了
- 但是它们多个方法的组合就不是原子的。





**线程安全类方法的组合**

分析下面的代码是否线程安全？**不安全**

```java
Hashtable table = new Hashtable();
// 线程1，线程2
if( table.get("key") == null) {
 	table.put("key", value);
}
```

~~~mermaid
sequenceDiagram
participant t1 as 线程1
participant t2 as 线程2
participant table
t1 ->> table : get("key")==null
t2 ->> table : get("key")==null
t2 ->> table : put("key", v2)
t1 ->> table : put("key", v1)
~~~



**不可变类线程安全性**

String、Integer等都是不可变类，因为其内部的状态不可以改变，因此它们的方法都是线程安全的

有的同学会问，String有replace、substring等方法可以改变值啊，那么这些方法又是如何保证线程安全的呢？

- 看substring的源码发现，该方法最后返回的是一个新的String，以前的字符串没有变，replace方法也是类似。即使被多线程所共享，因为没有改变，所以没有线程安全的问题。

```java
public class Immutable{
     private int value = 0;
     public Immutable(int value){
     	this.value = value;
     }
     public int getValue(){
     	return this.value;
     }
}
```

如果想要增加一个增加的方法呢？

```java
public class Immutable{
     private int value = 0;
     public Immutable(int value){
     	this.value = value;
     }
     public int getValue(){
     	return this.value;
     }

     public Immutable add(int v){
         // 这个增加的方法并不是空，而是返回一个对象
     	return new Immutable(this.value + v);
     }
}

```



**实例分析**

例1：

```java
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

public class MyServlet01 extends HttpServlet {
    // 是否线程安全
    Map<String, Object> map = new HashMap<>(); // 不是线程安全
    // 是否线程安全
    String s1 = ""; // 是
    // 是否线程安全
    final String s2 = ""; // 是
    // 是否线程安全
    Date d1 = new Date(); // 不是
    // 是否线程安全
    final Date d2 = new Date();// 不是
    // 日期是可变类，虽然日期的引用不能改，但是日期的属性是可以改的，因此不是线程安全的

    public void doGet(HttpServletRequest request, HttpServletResponse response){

    }

}
```



例2：

```java
public class MyServlet extends HttpServlet {
     // 是否安全？  不是线程安全的，因为它是共享变量
     private UserService userService = new UserServiceImpl();

     public void doGet(HttpServletRequest request, HttpServletResponse response) {
     	userService.update(...);
     }
}

public class UserServiceImpl implements UserService {
    // 记录调用次数
    private int count = 0;// 共享变量

    public void update() {
        // ...
        count++;
    }
}

```



例3：

```java
@Aspect
@Component// 正常情况是单例模式，会被共享
public class MyAspect {
     // 是否安全？
     private long start = 0L;// 有线程安全问题，变量会被共享，改进：做成局部变量
    // 改成环绕通知

     @Before("execution(* *(..))")
     public void before() {
     	start = System.nanoTime();
     }

     @After("execution(* *(..))")
     public void after() {
     long end = System.nanoTime();
     	System.out.println("cost time:" + (end-start));
     }
}
```

正常来说它是单例模式，如果改成多例模式，多线程拥有的时间不一定，无法统计时间



例4：

```java
public class MyServlet extends HttpServlet {
     // 是否安全？ 是线程安全的，虽然这个类里有一个成员变量userDao,但是它是私有的，他的内部没有可更改的属性或状态，所以也是线程安全
     private UserService userService = new UserServiceImpl();

     public void doGet(HttpServletRequest request, HttpServletResponse response) {
     	userService.update(...);
     }
}

public class UserServiceImpl implements UserService {
    // 是否安全？ 是线程安全；虽然他是一个成员变量，他也会被共享，但是他的内部没有可更改的属性或状态，因此是线程安全的
    private UserDao userDao = new UserDaoImpl();

    public void update() {
        userDao.update();
    }
}

public class UserDaoImpl implements UserDao {
    // 它是线程安全的，首先这个类里面没有成员变量，将来即使多线程来访问，也没有可供多线程改变的属性或这状态，因此没有成员变量的类一般都是线程安全的
    // Connection 也是线程安全的，因为他属于局部变量，每个线程内部都有自己的一个Connection，互不干扰
    // 无状态的类一般都是线程安全的
    public void update() {
        String sql = "update user set password = ? where username = ?";
        // 是否安全，是线程安全的
        try (Connection conn = DriverManager.getConnection("","","")){
            // ...
        } catch (Exception e) {
            // ...
        }
    }
}

```



例5：

```java
public class MyServlet extends HttpServlet {
     // 是否安全
     private UserService userService = new UserServiceImpl();

     public void doGet(HttpServletRequest request, HttpServletResponse response) {
     	userService.update(...);
     }
}

public class UserServiceImpl implements UserService {
     // 是否安全
     private UserDao userDao = new UserDaoImpl();

     public void update() {
     	userDao.update();
     }
}

public class UserDaoImpl implements UserDao {
    // UserDaoImpl会被多个线程共享
     // 是否安全；不是线程安全的，它会被共享
     private Connection conn = null;
     public void update() throws SQLException {
         String sql = "update user set password = ? where username = ?";
         conn = DriverManager.getConnection("","","");
         // ...
         conn.close();
     }
}
```

所以例5不是线程安全的。





例6：

```java
public class MyServlet extends HttpServlet {
     // 是否安全？是
     private UserService userService = new UserServiceImpl();

     public void doGet(HttpServletRequest request, HttpServletResponse response) {
     	userService.update(...);
     }
}

public class UserServiceImpl implements UserService {
     public void update() {
         // 为方法内局部变量，是线程安全
         UserDao userDao = new UserDaoImpl();
         userDao.update();
     }
}

public class UserDaoImpl implements UserDao {
     // 是否安全？是，因为UserDaoImpl作为方法内的局部变量存在
     private Connection = null;
     public void update() throws SQLException {
         String sql = "update user set password = ? where username = ?";
         conn = DriverManager.getConnection("","","");
         // ...
         conn.close();
     }
}
```

所以没有线程安全问题



例7：

```java
public abstract class Test {

     public void bar() {
         // 是否安全
         SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
         foo(sdf);// foo可能把sdf暴露给其他线程
    }

     public abstract foo(SimpleDateFormat sdf);


     public static void main(String[] args) {
     	new Test().bar();
     }
}
```

其中 foo 的行为是不确定的，可能导致不安全的发生，被称之为**外星方法**

```java
public void foo(SimpleDateFormat sdf) {
     String dateStr = "1999-10-11 00:00:00";
     for (int i = 0; i < 20; i++) {
         new Thread(() -> {
             try {
                sdf.parse(dateStr);
             } catch (ParseException e) {
                e.printStackTrace();
             }
         }).start();
     }
}
```

请比较JDK中String类的实现：String类是用final修饰的，这样可以避免子类覆盖父类



## 5 练习

### 5.1 卖票练习

下面的测试代码是否存线程安全问题，并尝试改正

```java
package org.lqy.test;

import lombok.extern.slf4j.Slf4j;

import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.util.Vector;

@Slf4j(topic = "c.ExerciseSell")
public class ExerciseSell {
    public static void main(String[] args) {
        TicketWindow ticketWindow = new TicketWindow(1000);
        // 所有线程的集合
        List<Thread> list = new ArrayList<>();
        // 用来存储卖出去多少张票
        List<Integer> sellCount = new Vector<>();
        for (int i=0; i<2000; i++) {
            Thread t = new Thread(()->{
                // 买票
                // count是局部变量，不涉及线程安全问题
                // ticketWindow是共享变量，存在线程安全问题
                int count = ticketWindow.sell(randomAmount());
                try {
                    Thread.sleep(randomAmount());
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                // sellCount是共享变量，但是已经用Vector了，所以不存在线程安全问题
                sellCount.add(count);
            });
            list.add(t);// 它只会被主线程使用
            t.start();
        }
        list.forEach((t)->{
            try {
                t.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        // 卖出去的票求和
        log.debug("selled count:{}", sellCount.stream().mapToInt(c->c).sum());
        // 剩余票数
        log.debug("remainder count:{}", ticketWindow.getCount());
    }

    // Random 为线程安全
    static Random r = new Random();
    public static int randomAmount(){
        return r.nextInt(5)+1;
    }
}
class TicketWindow {
    private int count;
    public TicketWindow(int count) {
        this.count = count;
    }

    public int getCount() {
        return this.count;
    }

    public int sell(int amount){// 改正，给这个方法加一个 synchronized
        if(this.count >= amount){
            this.count -= amount;
            return amount;
        } else {
            return 0;
        }
    }
}
```





### 5.2 转账练习

下面的测试代码是否存在线程安全问题，并尝试改正。

```java
package org.lqy.test;

import lombok.extern.slf4j.Slf4j;

import java.util.Random;

@Slf4j(topic = "c.ExerciseTransfer")
public class ExerciseTransfer {
    public static void main(String[] args) throws InterruptedException {
        Account a = new Account(1000);
        Account b = new Account(1000);
        Object obj = new Object();
        Thread t1 = new Thread(()->{
           for (int i=0; i<1000; i++) {
               // 两个共享变量，都是余额
//               synchronized (obj){// 改进
//                   a.transfer(b, randomAmount());
//               }
               a.transfer(b, randomAmount());
           }
        }, "t1");

        Thread t2 = new Thread(()->{
            for (int i=0; i<1000; i++) {
                // 两个共享变量，都是余额
//                synchronized (obj){// 改进
//                    b.transfer(a, randomAmount());
//                }
                b.transfer(a, randomAmount());
            }
        }, "t2");

        t1.start();
        t2.start();
        t1.join();
        t2.join();

        log.debug("total:{}", (a.getMoney() + b.getMoney()));
    }

    static Random r = new Random();

    public static int randomAmount(){
        return r.nextInt(100) + 1;
    }
}

class Account {
    private int money;
    public Account(int money){
        this.money = money;
    }

    public int getMoney() {
        return this.money;
    }

    public void setMoney(int money) {
        this.money = money;
    }

    public void transfer(Account target, int amount){
        synchronized (Account.class){// 改进
            if(this.money >= amount){
                this.setMoney(this.getMoney() - amount);
                target.setMoney(target.getMoney() + amount);
            }
        }
    }
}
```



## 6 Monitor 概念

### 6.1 Java对象头

以32为虚拟机为例。

**普通对象**

![image-20230829225855310](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308292258455.png)

一个普通对象的对象头是8个字节，其中4个字节是 `Mark Word`，另外4个字节点是指向对象类型的指针。

Integer包装类在32位虚拟机里，占用8个字节的对象，再加上4字节的存储值，所以一共占了12字节。

而int数据类型占用4个字节。在内存敏感的情况下，尽量使用int数据类型而不是使用Integer数据类型。



**数组对象**

![image-20230829230603857](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308292306951.png)



其中Mark Word结构为

![image-20230829230646867](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308292306960.png)



64位虚拟机Mark Word

![image-20230829230801241](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308292308443.png)





### 6.2 Monitor(锁)

**Monitor被翻译为监视器或管程**

每个Java对象都可以关联一个Monitor对象，如果使用synchronized给对象上锁（重量级）之后，该对象头的Mark Word中就被设置指向Monitor对象的指针。

Monitor 结构如下：

![image-20230829231112333](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308300127113.png)

- 刚开始Monitor中的Owner为null
- 当Thread-2执行synchronized(obj)就会将Monitor的所有者Owner置为Thread-2，Monitor中只有一个Owner
- 在Thread-2上锁的过程中，如果Thread-3，Thread-4，Thread-5也来执行synchronized(obj)，就会进入EntryList BLOCKED
- Thread-2执行完同步代码块的内容，然后唤醒EntryList中等待的线程来竞争，竞争时是非公平的
- 图中WaitSet中的Thread-0，Thread-1是之前获得过锁，但条件不满足进入WAITING状态的线程，后面讲wait-notify时会分析。

> **注意：**
>
> - synchronized必须是同一个对象的Monitor才有上述效果
> - 不加synchronized的对象不会关联监视器，不遵从以上规则



![image-20230830012707058](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308300127011.png)



Monitor对象是操作系统提供的，将obj对象与Monitor对象相关联，在obj对象的Mark Word里面记录了Monitor对象的指针地址，根据这个地址找到Monitor对象。

关联成功之后，Thread-2就成为了Monitor的所有者。当其他的线程来访问临界区代码时，就会检查这个obj对象是否关联了Monitor锁，当发现obj关联了Monitor锁时，然后就会检查这个所有没有主人，然后发现这个锁已经被Thread-2所有。

不过其他的线程也会和Monitor进行关联，只不过关联的是阻塞对列，把其他的想要访问临界区代码的线程放在一个叫 EntryList 的阻塞队列里。其他的线程被BLOCKED。

当Thread-2把临界区的代码执行完了以后，Owner就会被释放，这个时候就会通知EntryList中被阻塞的线程，把这些线程叫醒，然后这些被叫醒的线程进行竞争Owner，竞争成功的线程就会获得Owner，并拥有执行权。





![image-20230830020033470](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308300200545.png)

![image-20230830020047641](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308300200724.png)



### 6.3 小故事

故事角色 

- 老王 - JVM 
- 小南 - 线程 
- 小女 - 线程 
- 房间 - 对象 
- 房间门上 - 防盗锁 - Monitor 
- 房间门上 - 小南书包 - 轻量级锁 
- 房间门上 - 刻上小南大名 - 偏向锁 
- 批量重刻名 - 一个类的偏向锁撤销到达 20 阈值 
- 不能刻名字 - 批量撤销该类对象的偏向锁，设置该类不可偏向 

小南要使用房间保证计算不被其它人干扰（原子性），最初，他用的是防盗锁，当上下文切换时，锁住门。这样， 即使他离开了，别人也进不了门，他的工作就是安全的。 ==（此时用的是Monitor）==

但是，很多情况下没人跟他来竞争房间的使用权。小女是要用房间，但使用的时间上是错开的，小南白天用，小女 晚上用。每次上锁太麻烦了，有没有更简单的办法呢？ 

小南和小女商量了一下，约定不锁门了，而是谁用房间，谁把自己的书包挂在门口，但他们的书包样式都一样，因 此每次进门前得翻翻书包，看课本是谁的，如果是自己的，那么就可以进门，这样省的上锁解锁了。万一书包不是 自己的，那么就在门外等，并通知对方下次用锁门的方式。 ==（轻量级锁）==

后来，小女回老家了，很长一段时间都不会用这个房间。小南每次还是挂书包，翻书包，虽然比锁门省事了，但仍 然觉得麻烦。

于是，小南干脆在门上刻上了自己的名字：【小南专属房间，其它人勿用】，下次来用房间时，只要名字还在，那 么说明没人打扰，还是可以安全地使用房间。如果这期间有其它人要用这个房间，那么由使用者将小南刻的名字擦 掉，升级为挂书包的方式。 ==（偏向锁）==

同学们都放假回老家了，小南就膨胀了，在 20 个房间刻上了自己的名字，想进哪个进哪个。后来他自己放假回老 家了，这时小女回来了（她也要用这些房间），结果就是得一个个地擦掉小南刻的名字，升级为挂书包的方式。老 王觉得这成本有点高，提出了一种批量重刻名的方法，他让小女不用挂书包了，可以直接在门上刻上自己的名字 。==（批量重刻名）==

后来，刻名的现象越来越频繁，老王受不了了：算了，这些房间都不能刻名了，只能挂书包。==（不能刻名字）==





### 6.4 synchronized原理进阶

#### 6.4.1 轻量级锁

轻量级锁的使用场景：如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化。

轻量级锁对使用者是透明的，即语法仍然是 `synchronized`，即使用synchronized会优先使用轻量级锁，如果轻量级锁加锁失败，就会使用重量级锁。

假设有两个方法同步块，利用同一个对象加锁

```java
static final Object obj = new Object();
public static void method1(){
    synchronized(obj){
        // 同步块 A
        method2();
    }
}

public static void method2(){
    synchronized(obj) {
        // 同步块 B
    }
}
```

- 创建锁记录（Lock Record）对象，每个线程的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的Mark Word

![image-20230830022914732](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308300229805.png)



- 让锁记录中Object reference指向锁对象，并尝试用cas替换Object的Mark Word，将Mark Word的值存入锁记录。

  ![image-20230830233700364](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308302337469.png)

- 如果cas替换成功，对象头存储了 `锁记录地址和状态00`，表示由该线程给对象加锁，这时图示如下。

  ![image-20230830234238119](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308302342202.png)

- 如果cas失败，有两种情况

  - 如果其他线程已经持有了该Object的轻量级锁，这时表示有竞争，进入锁膨胀过程
  - 如果是自己执行了synchronized锁重入，那么再添加一条Lock Record作为重入的计数
    - 当synchronized锁重入的时候，也会经历cas的过程，但是cas会失败，不过这个失败是允许的，因为这个锁是本身自己持有的，锁记录里面是null

  ![image-20230830234519332](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308302345446.png)

如果对象头的后两位是00，那么就cas失败，表示已经有其他的线程持有了这个对象的轻量级锁。看锁记录的个数可以看出对这个线程加了几次锁。

- 当退出synchronized代码块（解锁时）如果有取值为null的锁记录，表示有重入，这时重置锁记录（也就是删除锁记录），表示重入计数减一
- 当退出synchronized代码块（解锁时）锁记录的值不为null，这时使用cas将Mark Word的值恢复给对象头
  - 成功，则解锁成功
  - 失败，说明**轻量级锁进行了锁膨胀或已经升级为重量级锁**，进入重量级锁解锁流程





#### 6.4.2 锁膨胀

如果在尝试加轻量级锁的过程中，CAS操作无法成功，这时一种情况就是有其他线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁。

```java
static Object obj = new Object();
public static void method1(){
    //同步块
}
```

- 当Thread-1进行轻量级加锁时，Thread-0已经对该对象加了轻量级锁

![image-20230831000524795](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308310005898.png)

- 这时Thread-1加轻量级锁失败，进入锁膨胀流程

  - 即为Object对象申请Monitor锁，让Object指向重量级锁地址
  - 然后自己进入Monitor的EntryList BLOCKED

  ![image-20230831000717544](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308310007647.png)

- 当Thread-0退出同步代码块时，使用cas将Mark Word的值恢复给对象头，失败。这时进入重量级锁解锁流程，即按照Monitor地址找到Monitor对象，设置Owner为null，唤醒EntryList中的BLOCKED线程。





#### 6.4.3 自旋优化

重量级锁竞争的时候，还可以使用自旋（即线程先不要进入阻塞，而是进行几次循环）来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步代码块，释放了锁），这时当前线程就可以避免阻塞。（因为阻塞会导致上下文切换）

自旋成功的情况。

![image-20230831001724128](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308310017235.png)

自旋失败的情况。

![image-20230831001746561](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308310017653.png)

- 自旋会占用CPU时间，单核CPU自旋是十分浪费的，多核cpu自旋才能发挥优势
- 在Java6之后自旋是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，。就少自旋甚至不自旋，总之，比较智能。
- Java7之后就不能控制是否开启自旋的功能





#### 6.4.4 偏向锁

轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行CAS操作。

Java6中引入了偏向锁来做进一步的优化：只有第一次使用CAS将**线程ID**设置到对象的Mark Word头，之后发现**线程ID是自己时就表示没有竞争**，不用进行CAS。以后只要不发生竞争，这个对象就归该线程所有。

例如：

```java
static final Object obj = new Object();
public static void m1(){
    synchronized(obj){
        // 同步块A
        m2();
    }
}

public static void m2(){
    synchronized(obj){
        // 同步块B
        m3();
    }
}

public static void m3(){
    synchronized(obj){
        // 同步块C
    }
}
```

![image-20230831002723970](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308310027088.png)

##### 6.4.4.1 偏向状态

对象头格式：

![image-20230831002937233](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308310029363.png)

biased_lock表示是否启用了偏向锁，如果是0，则没有启用偏向锁，如果是1，则启用了偏向锁。

一个对象创建时：

- 如果开启了偏向锁（默认开启），那么对象创建后，MarkWord值为0x05即最后3位为101，这时它的thread，epoch，age都为0
- 偏向锁是默认是延迟的，不会在程序启动时立即生效，如果想避免延迟，可以加VM参数 `-XX:BiasedLockingStartupDelay=0`来禁用延迟
- 如果没有开启偏向锁，那么对象创建后，MarkWord值为0x01即最后3位为001，这时它的hashcode，age都为0，第一次用到hashcode时才会赋值

1）测试延迟特性

加载依赖：

```java
<dependency>
    <groupId>org.openjdk.jol</groupId>
    <artifactId>jol-core</artifactId>
    <version>0.16</version>
</dependency>
```

```java
import lombok.extern.slf4j.Slf4j;
import org.openjdk.jol.info.ClassLayout;

@Slf4j(topic = "c.TestBiased")
public class TestBiased {
    public static void main(String[] args) throws InterruptedException {
        Dog dog = new Dog();
        log.debug(ClassLayout.parseInstance(dog).toPrintable());
        synchronized (dog){
            log.debug(ClassLayout.parseInstance(dog).toPrintable());
        }
        log.debug(ClassLayout.parseInstance(dog).toPrintable());
    }
}
class Dog{

}
```

输出：

```java
01:28:45.329 c.TestBiased [main] - org.lqy.test.Dog object internals:
OFF  SZ   TYPE DESCRIPTION               VALUE
  0   8        (object header: mark)     0x0000000000000005 (biasable; age: 0)
  8   4        (object header: class)    0xf8018ba4
 12   4        (object alignment gap)    
Instance size: 16 bytes
Space losses: 0 bytes internal + 4 bytes external = 4 bytes total

01:28:45.334 c.TestBiased [main] - org.lqy.test.Dog object internals:
OFF  SZ   TYPE DESCRIPTION               VALUE
  0   8        (object header: mark)     0x000001b11860e805 (biased: 0x000000006c46183a; epoch: 0; age: 0)
  8   4        (object header: class)    0xf8018ba4
 12   4        (object alignment gap)    
Instance size: 16 bytes
Space losses: 0 bytes internal + 4 bytes external = 4 bytes total

01:28:45.335 c.TestBiased [main] - org.lqy.test.Dog object internals:
OFF  SZ   TYPE DESCRIPTION               VALUE
  0   8        (object header: mark)     0x000001b11860e805 (biased: 0x000000006c46183a; epoch: 0; age: 0)
  8   4        (object header: class)    0xf8018ba4
 12   4        (object alignment gap)    
Instance size: 16 bytes
Space losses: 0 bytes internal + 4 bytes external = 4 bytes total
```

由于开启了禁用延迟，所以最开始就启用了偏向锁，然后执行到同步代码块时，有线程id，同步代码块执行完毕以后，线程id不变，还存储在对象头中。

有偏向锁时，优先使用偏向锁。

> **注意**
>
> 处于偏向锁的对象解锁后，线程id仍存储于对象头中
>
> 相关参考：[java使用jol打印对象信息](https://blog.csdn.net/u011943534/article/details/125470089)



2）测试禁用

在上面的测试代码运行时在添加参数 `-XX:-UseBiasedLocking`禁用偏向锁

输出：

```java
01:36:16.428 c.TestBiased [main] - org.lqy.test.Dog object internals:
OFF  SZ   TYPE DESCRIPTION               VALUE
  0   8        (object header: mark)     0x0000000000000001 (non-biasable; age: 0)
  8   4        (object header: class)    0xf8018ba4
 12   4        (object alignment gap)    
Instance size: 16 bytes
Space losses: 0 bytes internal + 4 bytes external = 4 bytes total

01:36:16.434 c.TestBiased [main] - org.lqy.test.Dog object internals:
OFF  SZ   TYPE DESCRIPTION               VALUE
  0   8        (object header: mark)     0x00000024115ff098 (thin lock: 0x00000024115ff098)
  8   4        (object header: class)    0xf8018ba4
 12   4        (object alignment gap)    
Instance size: 16 bytes
Space losses: 0 bytes internal + 4 bytes external = 4 bytes total

01:36:16.435 c.TestBiased [main] - org.lqy.test.Dog object internals:
OFF  SZ   TYPE DESCRIPTION               VALUE
  0   8        (object header: mark)     0x0000000000000001 (non-biasable; age: 0)
  8   4        (object header: class)    0xf8018ba4
 12   4        (object alignment gap)    
Instance size: 16 bytes
Space losses: 0 bytes internal + 4 bytes external = 4 bytes total
```

最开始是无所，执行到了synchronized时，变成了轻量锁，同步代码块执行完了就变成了无所状态。



3）测试hashcode

- 正常状态对象一开始是没有hashcode的，第一次调用才生成并填充到对象头里。
- 之所以调用了hashcode方法会撤销掉对象的偏向锁，从而变成普通状态，是因为偏向锁状态下没有空间存储hashcode，大部分的空间被用来存储线程id。
- 但是轻量级锁或者重量级锁状态下调用hashCode方法不会被撤销，是因为轻量级锁的hashcode被存在锁记录里，而重量级锁的hashcode被存在Monitor里。

```java
import lombok.extern.slf4j.Slf4j;
import org.openjdk.jol.info.ClassLayout;

@Slf4j(topic = "c.TestBiased")
public class TestBiased {
    public static void main(String[] args) throws InterruptedException {
        Dog dog = new Dog();
        dog.hashCode();// 它会禁用掉对象的偏向锁
        log.debug(ClassLayout.parseInstance(dog).toPrintable());
        synchronized (dog){
            log.debug(ClassLayout.parseInstance(dog).toPrintable());
        }
        log.debug(ClassLayout.parseInstance(dog).toPrintable());
    }
}
class Dog{

}
```

输出：

```java
01:44:53.388 c.TestBiased [main] - org.lqy.test.Dog object internals:
OFF  SZ   TYPE DESCRIPTION               VALUE
  0   8        (object header: mark)     0x0000001761e84001 (hash: 0x1761e840; age: 0)
  8   4        (object header: class)    0xf8018ba4
 12   4        (object alignment gap)    
Instance size: 16 bytes
Space losses: 0 bytes internal + 4 bytes external = 4 bytes total

01:44:53.392 c.TestBiased [main] - org.lqy.test.Dog object internals:
OFF  SZ   TYPE DESCRIPTION               VALUE
  0   8        (object header: mark)     0x0000004b8d3ff788 (thin lock: 0x0000004b8d3ff788)
  8   4        (object header: class)    0xf8018ba4
 12   4        (object alignment gap)    
Instance size: 16 bytes
Space losses: 0 bytes internal + 4 bytes external = 4 bytes total

01:44:53.393 c.TestBiased [main] - org.lqy.test.Dog object internals:
OFF  SZ   TYPE DESCRIPTION               VALUE
  0   8        (object header: mark)     0x0000001761e84001 (hash: 0x1761e840; age: 0)
  8   4        (object header: class)    0xf8018ba4
 12   4        (object alignment gap)    
Instance size: 16 bytes
Space losses: 0 bytes internal + 4 bytes external = 4 bytes total
```















