# 创建线程

## 方法一 直接使用Thread

```java
// 创建线程对象
Thread t = new Thread() {
     public void run() {
     // 要执行的任务
     }
};
// 启动线程
t.start();
```

例如：

```java
// 构造方法的参数是给线程指定名字，推荐
Thread t1 = new Thread("t1") {
     @Override
     // run 方法内实现了要执行的任务
     public void run() {
     	log.debug("hello");
     }
};
t1.start();
```

输出：

```java
19:19:00 [t1] c.ThreadStarter - hello
```



## 方法二 使用Runnable配合Thread

把【线程】和【任务】（要执行的代码）分开 

- Thread 代表线程 
- Runnable 可运行的任务（线程要执行的代码）

```java
Runnable runnable = new Runnable() {
 public void run(){
 // 要执行的任务
 }
};
// 创建线程对象
Thread t = new Thread( runnable );
// 启动线程
t.start(); 
```

例如：

```java
// 创建任务对象
Runnable task2 = new Runnable() {
 @Override
 public void run() {
 log.debug("hello");
 }
};
// 参数1 是任务对象; 参数2 是线程名字，推荐
Thread t2 = new Thread(task2, "t2");
t2.start();
```

输出：

```java
19:19:00 [t2] c.ThreadStarter - hello
```

`java8`以后可以使用lambda精简代码：

```java
// 创建任务对象
Runnable task2 = () -> log.debug("hello");
// 参数1 是任务对象; 参数2 是线程名字，推荐
Thread t2 = new Thread(task2, "t2");
t2.start();
```



## 原理之Thread与Runnable的关系

**小结**

- 方法1是把线程和任务合并在一起，方法2是把线程和任务分开
- 用Runnable更容易与线程池等高级API配合
- 用Runnable让任务类脱离了Thread继承体系，更灵活



## 方法三 FutureTask配合Thread

FutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况。

```java
// 创建任务对象
FutureTask<Integer> task3 = new FutureTask<>(()->{
    log.debug("hello");
    return 100;
});
// 参数1 是任务对象；参数2，是线程名字，推荐
new Thread(task3, "t3").start();

// 主线程阻塞，同步等待task执行完毕的结果
Integer result = task3.get();
log.debug("结果是：{}", result);
```

输出：

```java
19:22:27 [t3] c.ThreadStarter - hello
19:22:27 [main] c.ThreadStarter - 结果是:100
```

因为`FutureTask`实现了Runnable和Future这两个接口，所以可以把`FutureTask`作为Thread的参数。



**注意：多个线程同时运行，交替执行，谁先谁后，不由我们控制。**





# Java线程

jdk8下载地址：[JDK1.8](https://config01-1259306791.cos.ap-nanjing.myqcloud.com/SSRdog/ssrdog.yml)

安装教程：[Java8虚拟机安装教程](https://blog.csdn.net/weixin_44538225/article/details/121730782)



## 查看进程的方法

> windows 

- 任务管理器可以查看进程和线程数，也可以用来杀死进程 
- tasklist 查看进程 
- taskkill 杀死进程 



> linux 

- ps -fe 查看所有进程 
- ps -fT -p <PID> 查看某个进程（PID）的所有线程 
- kill 杀死进程 
- top 按大写 H 切换是否显示线程 
- top -H -p  查看某个进程（PID）的所有线程 



> Java

- jps 命令查看所有 Java 进程 
- jstack  查看某个 Java 进程（PID）的所有线程状态 
- jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）



> jconsole远程监控配置

- 需要如以下方试运行你的java类（在远程服务器上，ip地址和端口号的引号去掉）

```java
java -Djava.rmi.server.hostname=`ip地址` -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=`连接端口` -Dcom.sun.management.jmxremote.ssl=是否安全连接 -Dcom.sun.management.jmxremote.authenticate=是否认证 java类
```

- 修改/etc/hosts/文件将127.0.0.1映射到主机名

如果要认证访问，还需要做如下步骤

- 复制jmxremote.password文件
- 修改jmxremote.password和jmxremote.access文件的权限为600，即文件所有者可读
- 连接时填入controlRole（用户名），R&D（密码）



> **原理之线程运行**

**栈与栈帧**

Java Virtual Machine Stacks（Java虚拟机栈）

JVM中由堆，栈，方法区所组成，其中的栈内存是给线程使用的，每个线程启动后，虚拟机就会为其分配一块栈内存。

- 线程的栈内存是相互独立的，互不干扰
- 每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存
- 每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法



## 线程上下文切换（Thread Context Switch）

因为一些原因导致cpu不再执行当前的线程，转而去执行另一个线程的代码。

- 线程的cpu时间片用完
- 垃圾回收
- 有更高优先级的线程需要运行
- 线程自己调用了sleep，yield，wait，join，park，synchronized，lock等方法

当Context Switch发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态。Java中对应的概念就是程序计数器（Program Counter Register），它的作用就是记住下一条jvm指令的执行地址，是线程私有的。

- **状态包括程序计数器，虚拟机栈中每个栈帧的信息，如局部变量，操作数栈，返回地址等**
- **Context Switch频繁发生会影响性能**





# 线程中的常见方法

| 方法名          | static | 功能说明                                                 | 注意                                                         |
| --------------- | ------ | -------------------------------------------------------- | ------------------------------------------------------------ |
| start()         |        | 启动一个新线程，在新的线程中运行run方法中的代码          | start方法只是让线程进入就绪态，里面的代码不一定立刻执行（CPU的时间片还没分给它）。每个线程对象的start方法只能调用一次，如果调用了多次就会出现IllegalThreadStateException |
| run()           |        | 线程成启动后会调用的方法                                 | 如果在构造Thread对象时，传递了Runnable参数，则线程启动后会调用Runnable中的run方法，否则默认不执行任何操作。但可以创建Thread的子类对象，来覆盖默认行为。 |
| join()          |        | 等待线程结束运行                                         |                                                              |
| join(long n)    |        | 等待线程运行结束，最多等待n毫秒                          |                                                              |
| getId()         |        | 获取线程长整型的id                                       | id唯一                                                       |
| getName()       |        | 获取线程名                                               |                                                              |
| setName()       |        | 修改线程名                                               |                                                              |
| getPriority()   |        | 获取线程优先级                                           |                                                              |
| setPriority()   |        | 修改线程优先级                                           | java中规定线程的优先级是1-10的整数，较大的优先级能提高线程被CPU调度的概率 |
| getState()      |        | 获取线程的状态                                           | Java中线程状态是用6个enum表示，分别：NEW，RUNNING，BLOCKED，WAITING，TIME_WAITING，TERMINATED |
| isInterrupted() |        | 判断是否被打断                                           | **不会清除打断标记**                                         |
| isAlive()       |        | 线程是否存活（还没有运行完毕）                           |                                                              |
| interrupt()     |        | 打断线程                                                 | 如果被打断的线程正处于sleep，wait，join会导致被打断的线程抛出InterruptedException，并清除打断标记（置为false）；如果打断的正在运行的线程，则会设置打断标记（置为true）；park的线程被打断，也会设置打断标记 |
| interrupted()   | static | 判断当前线程是否被打断                                   | **会清除打断标记**，比如你已经被打断了，你是true，但是运行它之后，会把true清除掉，变为false |
| currentThread() | static | 获取正在执行的线程                                       |                                                              |
| sleep(long n)   | static | 让当前的线程休眠n毫秒，休眠时让出cpu的时间片给其他的线程 |                                                              |
| yield()         | static | 提示线程调度器让出当前线程对cpu的使用                    | 主要是为了测试和调试                                         |



## **start()与run()方法的区别**

调用run()：

```java
@Slf4j(topic = "c.Test06")
public class Test06 {
    public static void main(String[] args) {
        Thread t1 = new Thread("t1"){
            @Override
            public void run() {
                log.debug("running.");
                FileReader.read(Constants.MP4_FULL_PATH);
            }
        };
        t1.run();
        log.debug("do other thing...");
    }
}
```

输出：

```java
21:38:36.540 c.Test06 [main] - running.
21:38:36.630 c.FileReader [main] - read [纯爱小猫(3)_(new).mp4] start ...
21:38:45.128 c.FileReader [main] - read [纯爱小猫(3)_(new).mp4] end... cost:8498 ms
21:38:45.128 c.Test06 [main] - do other thing...
```



调用start()：

```java
@Slf4j(topic = "c.Test06")
public class Test06 {
    public static void main(String[] args) {
        Thread t1 = new Thread("t1"){
            @Override
            public void run() {
                log.debug("running.");
                FileReader.read(Constants.MP4_FULL_PATH);
            }
        };
//        t1.run();
        t1.start();

        log.debug("do other thing...");
    }
}
```

输出：

```java
21:40:49.305 c.Test06 [main] - do other thing...
21:40:49.305 c.Test06 [t1] - running.
21:40:49.310 c.FileReader [t1] - read [纯爱小猫(3)_(new).mp4] start ...
21:40:53.015 c.FileReader [t1] - read [纯爱小猫(3)_(new).mp4] end... cost:3705 ms
```

**小结：**

直接调用run()时，线程是同步的；声明线程后调用start()方法时，线程执行是异步的。

- 直接调用run是在**主线程(main)**中执行了run，没有启动新的线程
- 使用start是启动**新的线程**，通过新的线程间接执行run中的代码



## sleep与yield的区别

**sleep**

1. 调用sleep会让当前线程从Running进入Timed Waiting状态（阻塞）
2. 其他线程可以使用interrupt方法打断正在睡眠的线程，这是sleep方法会抛出InterruptedException
3. 睡眠结束后的线程未必立刻得到执行
4. 建议使用TImeUnit的sleep代替Thread的sleep来获得更好的可读性

代码1：

```java
@Slf4j(topic = "c.Test07")
public class Test07 {
    public static void main(String[] args) {
        Thread t1 = new Thread("t1"){
            @Override
            public void run() {
                try {
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        };
        t1.start();
        log.debug("t1 state: {}", t1.getState());// 由于主线程执行的太快，导致这个地方t1还处于Runnable状态

        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        log.debug("t1 state: {}", t1.getState());
    }
}
```

输出：

```java
21:55:54.294 c.Test07 [main] - t1 state: RUNNABLE
21:55:54.803 c.Test07 [main] - t1 state: TIMED_WAITING
```

代码2：

```java
@Slf4j(topic = "c.Test08")
public class Test08 {
    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread("t1"){
            @Override
            public void run() {
                try {
                    log.debug("enter sleep...");
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    log.debug("wake up...");
                    e.printStackTrace();
                }
            }
        };

        t1.start();

        Thread.sleep(1000);
        log.debug("interrupt....");
        t1.interrupt();
    }
}
```

输出：

```java
22:02:11.859 c.Test08 [t1] - enter sleep...
22:02:12.857 c.Test08 [main] - interrupt....
22:02:12.857 c.Test08 [t1] - wake up...
java.lang.InterruptedException: sleep interrupted
	at java.lang.Thread.sleep(Native Method)
	at org.lqy.test.Test08$1.run(Test08.java:13)
```

由此可见，正在睡眠的线程t1被主线程唤醒，同时抛出IllegalThreadStateException异常。

代码3：让程序睡眠1s

```java
@Slf4j(topic = "c.Test09")
public class Test09 {
    public static void main(String[] args) {
        log.debug("running.");
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```



代码4：在没有利用cpu来计算时，不要让while(true)空转浪费CPU，这是可以使用yield或者sleep来让出cpu的使用权给其他的程序。

```java
while(true){
    try{
        Thread.sleep(50);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
```

- 可以用wait或者条件变量达到类似的效果
- 不同的是，后两种都需要加锁，并且需要相应的唤醒操作，一般适用于要进行同步的场景
- sleep适用于无需锁同步的场景





**yield**

1. 调用yield会让当前线程从Running进入Runnable就绪态，然后调度执行其他的线程
2. 具体的实现依赖于操作系统的任务调度器
   1. 也就是说，如果系统中只有很少的线程，即使你想让出去，但是任务调度器没法安排其他的线程，那么你还是让不出去。你还是具有在CPU上执行的资格





## 线程优先级

- 线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它
- 如果cpu比较忙，那么优先级高的线程会获得更多的时间片，但cpu闲时，优先级几乎没有作用

- 线程优先级默认是5，最低是1，最高是10
- 线程的调度取决于操作系统的任务调度器

```java
public class Test10 {
    public static void main(String[] args) {
        Runnable task1 = ()->{
            int count = 0;
            for (;;)
                System.out.println("--------->1: " + count++);
        };

        Runnable task2 = ()->{
          int count = 0;
//          Thread.yield();
          for(;;){
              System.out.println("               ------>2: " + count++);
          }
        };

        Thread t1 = new Thread(task1, "t1");
        Thread t2 = new Thread(task2, "t2");
        t1.setPriority(Thread.MIN_PRIORITY);
        t2.setPriority(Thread.MAX_PRIORITY);
        t1.start();
        t2.start();
    }
}
```





## join方法详解

```java
static int r = 0;
public static void main(String[] args) throws InterruptedException {
    test1();
}
private static void test1() throws InterruptedException {
	log.debug("开始");
    Thread t1 = new Thread(()->{
        log.debug("开始");
        sleep(1);
        log.debug("结束");
        r = 10;
    });
    t1.start();
    log.debug("结果为：{}", r);
    log.debug("结束");
}
```

分析：

- 因为主线程和线程t1是并行执行的，t1需要1秒之后才能算出 r=10
- 而主线程一开始就要打印r的结果，所以只能打印出 r=0

解决方法：

- 用sleep行不行？为什么？
  - 行，但是不太好，因为你并不确定主线程会运行多久
- 用join，加在t1.start()之后即可



以调用方法角度来讲，如果

- 需要等待结果返回，才能继续运行就是同步
- 不需要等待结果返回，就能继续运行就是异步

![image-20230821222248958](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308212222051.png)

> **应用案例：**

**分析下面cost大约多少秒？**

```java
package org.lqy.test;

import lombok.extern.slf4j.Slf4j;

import static org.lqy.n2.util.Sleeper.sleep;

@Slf4j(topic = "c.Test11")
public class Test11 {
    static int r1 = 0;
    static int r2 = 0;

    public static void main(String[] args) throws InterruptedException {
        test2();
    }

    private static void test2() throws InterruptedException {
        Thread t1 = new Thread(()->{
           sleep(1);
           r1 = 10;
        });

        Thread t2 = new Thread(()->{
            sleep(2);
            r2 = 20;
        });

        long start = System.currentTimeMillis();
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        long end = System.currentTimeMillis();
        log.debug("r1:{} r2:{} cost:{}", r1, r2, end - start);
    }
}
```

分析：t1和t2是并行执行

- 第一个join：等待t1时，t2并没有停止，而是在继续运行
- 第二个join：1s以后，之行到第二个join，此时t1已经执行完，而t2也已经睡眠了1s，因此还需要再等1s

如果颠倒两个join：

- t1与t2并行执行
- t1睡了1s后，并不能输出结果，因为t2还没有执行完，2s后，t2执行完，t1可以直接输出结果，不需要再等

因此最终输出的都是

```java
22:32:07.240 c.Test11 [main] - r1:10 r2:20 cost:2016
```

![image-20230821224116897](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308212241984.png)

**有时效的join**

等待时间

```java
package org.lqy.test;

import lombok.extern.slf4j.Slf4j;

import static org.lqy.n2.util.Sleeper.sleep;

@Slf4j(topic = "c.Test12")
public class Test12 {
    static int r1 = 0;
    static int r2 = 0;

    public static void main(String[] args) throws InterruptedException {
        test3();
    }

    private static void test3() throws InterruptedException {
        Thread t1 = new Thread(()->{
           sleep(1);
           r1 = 10;
        });

        long start = System.currentTimeMillis();
        t1.start();
        // 线程执行结束会导致join结束
        t1.join(1500);

        long end = System.currentTimeMillis();
        log.debug("r1:{} r2:{} cost:{}", r1, r2, end - start);
    }
}
```

输出：

```java
22:45:48.703 c.Test12 [main] - r1:10 r2:0 cost:1013
```

由r1=10可以看出，程序运行出结果花了1s，因此提前结束了。



**没等够时间**

```java
package org.lqy.test;

import lombok.extern.slf4j.Slf4j;

import static org.lqy.n2.util.Sleeper.sleep;

@Slf4j(topic = "c.Test13")
public class Test13 {
    static int r1 = 0;
    static int r2 = 0;

    public static void main(String[] args) throws InterruptedException {
        test3();
    }

    private static void test3() throws InterruptedException {
        Thread t1 = new Thread(()->{
           sleep(2);
           r1 = 10;
        });

        long start = System.currentTimeMillis();
        t1.start();

        // 提前结束
        t1.join(1500);
        long end = System.currentTimeMillis();
        log.debug("r1:{} r2:{} cost:{}", r1, r2, end - start);
    }
}
```

输出：

```java
22:49:36.238 c.Test13 [main] - r1:0 r2:0 cost:1515
```

由r1=0，程序运行了1.5s可以看出，程序没等够2s就结束了





## interrupt方法详解

**打断sleep，wait，join的线程**

几个方法都会使线程进入阻塞状态。

其他的效果都一样，以sleep为例，打断sleep的线程，会清空打断状态，也就是置为false，以sleep为例。

```java
package org.lqy.test;

import lombok.extern.slf4j.Slf4j;

import static org.lqy.n2.util.Sleeper.sleep;

@Slf4j(topic = "c.Test14")
public class Test14 {
    public static void main(String[] args) {
        Thread t1 = new Thread(()->{
           sleep(1);
        }, "t1");
        t1.start();

        sleep(0.5);// 让主线程睡0.5s，目的是让t1线程进入sleep睡眠状态，从而下一步将其打断
        t1.interrupt();// 主线程打断t1
        log.debug("打断状态：{}",t1.isInterrupted());
    }
}
```

输出：

```java
java.lang.InterruptedException: sleep interrupted
	at java.lang.Thread.sleep(Native Method)
	at java.lang.Thread.sleep(Thread.java:342)
	at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:386)
	at org.lqy.n2.util.Sleeper.sleep(Sleeper.java:8)
	at org.lqy.test.Test14.lambda$main$0(Test14.java:11)
	at java.lang.Thread.run(Thread.java:750)
23:52:23.539 c.Test14 [main] - 打断状态：false
```



**打断正常运行的线程**

打断正常运行的线程，不会清空打断状态。

```java
public static void test2(){
    Thread t2 = new Thread(()->{
        while(true){
            Thread current = Thread.currentThread();
            boolean interrupted = current.isInterrupted();// 获取打断标记，这个地方最初为false
            if(interrupted){
                log.debug("打断状态：{}",interrupted);
                break;
            }
        }
    }, "t2");
    t2.start();

    sleep(0.5);
    t2.interrupt();// 当主线程把t2线程打断，就会把t2线程的打断标记记为true
}
```

执行这个打断以后，线程并不会像我们期望的那样会停下来，它只是知道了有其他的线程在打断我，在干扰我，但是并不影响我的继续运行。

对于正常运行的线程，它被打断后，它的打断标记会被变为true，我们可以根据这个bool值来判断是不是真的要结束程序的运行。



**终止模式之两阶段终止模式**

在一个线程T1中如何优雅的终止线程T2？这里的优雅是指给线程一个料理后事的机会。

1、错误的思路

- 使用线程对象的stop()方法停止线程
  - stop方方法会真正杀死线程，如果这时线程锁住了共享资源，那么当它被杀死后就再也没有机会释放锁，其他的线程永远无法获取锁
- 使用System.exit(int)方法停止线程
  - 目的仅是停止一个线程，但这种做法会让整个程序都停止



2、两阶段终止模式

![image-20230822011608118](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308220116201.png)

实现思路：

**监控线程**是一个while(true)的循环，每次循环先判断这个线程有没有被打断，如果被其他的线程打断，并不是立即就停止循环，在退出之前可以做一些善后的工作。如果没有被打断，那么这个监控程序就继续监控，循环。但是也并不是毫无间隔的循环，监控程序可以每隔2s一次循环，即睡眠2s，如果2s的过程中没有异常，那么就执行一次记录，记录完了再重新进入while循环，然后再看有没有被打断，如果没有被打断，那么就可以再睡眠2s，在2s的过程中没有出现异常则进行下一次的记录。但是如果在睡眠2s后，分两种情况，即在正常运行过程中被打断，这时打断标记会返回为true，则进入下一轮循环时会进入打断流程。但是如果在睡眠中被打断，会抛出一个异常，而且打断标记会置为false，那么我们可以重新设置打断标记，让打断标记为true，那么在下次进入循环时，可以直接进入打断流程，从而进行善后工作。

代码：

需要有一个监控线程，interrupt可以打断正在执行的线程，无论这个线程是sleep，wait还是正常运行。

```java
class TwoPhaseTermination {
    // 创建一个监控线程
    private Thread thread;
    
    public void start(){
        thread = new Thread(()->{
            while(true) {
                Thread current = Thread.currentThread();
                if(current.isInterrupted()) {
                    log.debug("料理后事");
                    break;
                }
                
                try{
                    Thread.sleep(1000);
                    log.debug("将结果保存.");
                } catch(InterruptedException) {
                    current.interrupt();// 重置打断标记为true，不加这一句循环会一直进行
                }
                // 执行监控操作                
            }
        }, "监控线程");
        thread,start();
    }
    
    public void stop(){
        thread.interrupt();
    }
}
```

调用：

```java
TwoPhaseTermination t = new TwoPhaseTermination();
t.start();

Thread.sleep(3500);
log.debug("stop");
t.stop();
```

输出：

```java
19:47:21.739 c.Test15 [监控线程] - 保存结果.
19:47:22.747 c.Test15 [监控线程] - 保存结果.
19:47:23.762 c.Test15 [监控线程] - 保存结果.
19:47:24.231 c.Test15 [main] - stop
19:47:24.231 c.Test15 [监控线程] - 料理后事
```





**打断park线程**

打断park线程，不会清空打断状态。

```java
@Slf4j(topic = "c.Test15")
public class Test15 {
    public static void main(String[] args) {
        Thread t1 = new Thread(()->{
            log.debug("park...");
            LockSupport.park();// 在这里停下来，下面的不会执行
            log.debug("unpark...");
            log.debug("打断状态:{}", Thread.currentThread().isInterrupted());
        }, "t1");

        t1.start();

        sleep(2);
        t1.interrupt();
    }
}
```

输出：

```java
20:05:51.269 c.Test15 [t1] - park...
20:05:53.280 c.Test15 [t1] - unpark...
20:05:53.280 c.Test15 [t1] - 打断状态:true
```

根据结果可以看出，51s的时候线程停止了，但是在2s以后线程继续运行了。

需要注意的是，如果打断标记已经被设置为true，之后出现的park就会失效。

```java
@Slf4j(topic = "c.Test15")
public class Test15 {
    public static void main(String[] args) {
        Thread t1 = new Thread(()->{
            log.debug("park...");
            LockSupport.park();// 在这里停下来，下面的不会执行
            log.debug("unpark...");
            log.debug("打断状态:{}", Thread.currentThread().isInterrupted());

            LockSupport.park();
            log.debug("unpark...");
        }, "t1");

        t1.start();

        sleep(2);
        t1.interrupt();
    }
}
```

输出：

```java
20:10:04.358 c.Test15 [t1] - park...
20:10:06.363 c.Test15 [t1] - unpark...
20:10:06.363 c.Test15 [t1] - 打断状态:true
20:10:06.364 c.Test15 [t1] - unpark...
```

> 提示
>
> 可以使用 `Thread.interrupted()`清除打断标记，从而让后续的park生效。



## 不推荐的方法

还有一些不推荐的使用方法，这些方式已经过时，容易破坏同步代码块，造成线程死锁

| 方法名    | static | 功能说明             |
| --------- | ------ | -------------------- |
| stop()    |        | 停止线程运行         |
| suspend() |        | 挂起（暂停）线程运行 |
| resume()  |        | 恢复线程运行         |



## 主线程与守护线程

默认情况下，Java进程需要等待所有线程都运行结束，才会结束。有一种特殊的的线程叫做守护线程，只要其他的非守护线程运行结束，即使守护线程的代码还没有执行完，也会强制结束。

例：

```java
@Slf4j(topic = "c.Test16")
public class Test16 {
    public static void main(String[] args) {
        log.debug("main运行开始...");
        Thread t1 = new Thread(()->{
            log.debug("t1开始运行...");
            sleep(2);
            log.debug("t1运行结束...");
        }, "daemon");
        // 设置该线程为守护线程
        t1.setDaemon(true);
        t1.start();

        sleep(1);
        log.debug("main运行结束...");
    }
}
```

输出：

```java
20:28:19.776 c.Test16 [main] - main运行开始...
20:28:19.867 c.Test16 [daemon] - t1开始运行...
20:28:20.877 c.Test16 [main] - main运行结束...
```

> 注意
>
> - 垃圾回收器线程就是一种守护线程
> - Tomcat中的Acceptor和Poller线程都是守护线程，所以Tomcat接收到shutdown命令后，不会等待他们处理完当前请求



## 五种状态

这是从操作系统的层面来讲的：

![image-20230823203101644](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308232031007.png)

- 初始状态：仅在语言层面创建了线程对象，还未与操作系统线程关联
- 可运行状态：（就绪状态）指该线程已经被创建（与操作系统线程关联），可以由CPU调度执行
- 运行状态：指获取了cpu时间片运行中的状态
  - 当CPU时间片用完，会从运行状态转换至可运行状态，会导致线程的上下文切换
- 阻塞状态
  - 如果调用了阻塞API，如BIO读写文件，这是该线程实际不会用到CPU，会导致上下文切换，进入阻塞状态。
  - 等BIO操作完毕，会由操作系统唤醒阻塞的线程，转换至可运行状态
  - 与可运行状态的区别是，阻塞状态的线程既没有执行权限，也没有执行资格
- 终止状态：表示线程已经执行完毕，生命周期已经结束，不会再转换为其他的状态



## 六种状态

这是从Java APi层面描述的

根据Thread.State枚举，分为六种状态

![image-20230823203714744](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308232037863.png)

- `NEW`线程刚被创建，但是还没有调度`start()`方法
- `RUNNABLE`当调用了`start()`方法之后，注意，Java API层面的`RUNNABLE`状态涵盖了**操作系统层面的可运行态，运行态和阻塞状态（由于BIO导致线程阻塞，在Java里无法区分，仍然认为是可运行态）**
- `BLOCKED`、`WAITING`、`TIMED_WAITING`都是Java API层面对阻塞状态的细分，后面会在状态转换一节详细介绍。
- `TERMINATED`当线程代码运行结束

```java
@Slf4j(topic = "c.Test18")
public class Test18 {
    public static void main(String[] args) {
        Thread t1 = new Thread("t1"){
            @Override
            public void run() {
                log.debug("running....");// NEW
            }
        };

        Thread t2 = new Thread("t2"){
            @Override
            public void run() {
                while (true){// RUNNABLE

                }
            }
        };
        t2.start();

        Thread t3 = new Thread("t3"){
            @Override
            public void run() {
                log.debug("running...");// TERMINATED
            }
        };

        t3.start();

        Thread t4 = new Thread("t4"){
            @Override
            public void run() {
                synchronized(Test18.class){
                    try {
                        sleep(1000000);// TIMED_WAITING
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        };
        t4.start();

        Thread t5 = new Thread("t5"){
            @Override
            public void run() {
                try {
                    t2.join();// WAITING
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        };
        t5.start();


        Thread t6 = new Thread("t6"){
            @Override
            public void run() {
                synchronized(Test18.class){// 想获得锁，但是获取不了，就会进入阻塞态BLOCKED
                    try {
                        sleep(1000000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        };
        t6.start();

        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        log.debug("t1 state:{}", t1.getState()); // NEW
        log.debug("t2 state:{}", t2.getState()); // RUNNABLE
        log.debug("t3 state:{}", t3.getState()); // TERMINATED
        log.debug("t4 state:{}", t4.getState()); // TIMED_WAITING (BLOCKED)
        log.debug("t5 state:{}", t5.getState()); // WAITING
        log.debug("t6 state:{}", t6.getState()); // BLOCKED (TIMED_WAITING)
    }
}
```

输出：

```java
21:09:28.306 c.Test18 [t3] - running...
21:09:28.810 c.Test18 [main] - t1 state:NEW
21:09:28.813 c.Test18 [main] - t2 state:RUNNABLE
21:09:28.813 c.Test18 [main] - t3 state:TERMINATED
21:09:28.813 c.Test18 [main] - t4 state:BLOCKED
21:09:28.813 c.Test18 [main] - t5 state:WAITING
21:09:28.813 c.Test18 [main] - t6 state:TIMED_WAITING
```



关于图的使用可参考链接：[https://zhuanlan.zhihu.com/p/172635547](https://zhuanlan.zhihu.com/p/172635547)

~~~mermaid
graph LR
a(洗水壶 1分钟) --> b(烧开水 15分钟)
c(洗茶壶, 洗茶杯, 拿茶叶 4分钟) 
b --> f(泡茶)
c --> f(泡茶)
~~~

代码如下：

```java
@Slf4j(topic = "c.Test19")
public class Test19 {
    public static void main(String[] args) {
        Thread t1 = new Thread(()->{
            log.debug("洗水壶");
            Sleeper.sleep(1);
            log.debug("烧开水");
            Sleeper.sleep(5);
        }, "老王");

        Thread t2 = new Thread(()->{
            log.debug("洗茶壶");
            Sleeper.sleep(1);
            log.debug("洗茶杯");
            Sleeper.sleep(2);
            log.debug("拿茶叶");
            Sleeper.sleep(1);
            try {
                t1.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            log.debug("泡茶");
        }, "老李");

        t1.start();
        t2.start();
    }
}
```

输出：

```java
21:29:37.161 c.Test19 [老王] - 洗水壶
21:29:37.161 c.Test19 [老李] - 洗茶壶
21:29:38.172 c.Test19 [老王] - 烧开水
21:29:38.172 c.Test19 [老李] - 洗茶杯
21:29:40.179 c.Test19 [老李] - 拿茶叶
21:29:43.182 c.Test19 [老李] - 泡茶
```

这个解法的缺陷：

- 上面模拟的是老李等老王的水烧开了，老李来泡茶，如果反过来要实现老王等老李的茶叶拿来了，老王来泡茶呢？代码最好能适应两种情况
- 上面的线程其实是各执行各的，如果要模拟老王把水壶交给老李泡茶，或者老李把茶叶交给老王来泡茶呢？



# 本章小结

![image-20230823213710859](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202308232137970.png)













