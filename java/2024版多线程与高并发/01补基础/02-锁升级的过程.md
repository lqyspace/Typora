# 锁升级的过程

锁的四种状态：new、偏向锁、轻量级锁、重量级锁

**new创建——偏向锁——轻量级锁（无锁，cas自旋锁，自适应自旋）——重量级锁**

![image-20240223234602017](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202402232346053.png)

`synchronized`上锁的过程中有锁升级的过程，这个升级过程对markword进行了清晰的记录。

下图是8个字节markword：

![image-20240222172924705](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202402221729786.png)

new出来以后，第一次上锁上偏向锁，有人征用升级为轻量级锁，征用状态变为竞争状态，升级为重量级锁，这些信息全部记录在markword的8个字节里面。

最后两个字节是锁标志位，倒数第三位是偏向锁位，当后两位是01时，如果偏向锁位是0则是无锁状态，如果是1则是偏向锁状态；

轻量级锁及以上只需要使用两个锁标志位。

markword中记录了**锁信息**和**GC信息**。分带年龄最大为15,是因为分带年龄只用了4bit,最大也就是15。

中间有1位没有使用，在无锁状态下，还有25位没有使用。31位存identity hashCode，如果对这个只有调用的话，那么hashCode就有值，否则就为空。

> 下面这个是32位的图：

![image-20240222174426561](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202402221744617.png)

> **锁升级过程**

最开始，一个对象没有任何锁加上来，然后它一个线程来了，加了`synchronized`，发现这把锁没有任何人污染过，我是第一个拥有这个对象的，那我就不先上那么重量级的锁，我就直接给它贴个标签，因此这是一把偏向锁，偏向锁的意思就是它偏向于第一个刚刚进来的线程，（其实在工程项目竞争不是很激烈的情况下，一个线程是完全足够任务执行，任务执行完了以后就会把这把锁释放掉，所以没有必要申请那么重量级的锁，干脆给这把锁贴个名字就行）。



在很多种情况下，在下一个进程进来的时候发现还是之前第一个线程，还是它自己这个线程。所以在偏向锁的状态下，markword里面有54位是用来存储当前线程的指针（JavaThread*）。

当有另一个线程需要对这个对象上锁时，此时撤离偏向锁，偏向锁升级为轻量级锁。具体过程如下：撤离偏向锁，在每个线程栈的栈帧里生成一个**lock record**（里面记录着hashCode）的指针，然后两个线程使用自旋的方式**争抢**这个对象的锁，争抢的过程使用的是cas，也就是说，某一个线程从对象里面读出markword的值，然后将其改为自己的lock record，在改的过程中如果还是保持原来的那个值，则说明我们可以修改，修改成功；如果修改过程中，已经被另外一个线程修改过，则说明该线程争抢成功。争抢失败的那个线程就会一直自旋等待。

用cas操作修改轻量级线程的62位的Lock Record，将其修改为指向自己的Lock Record指针，谁修改成功，这把锁就是谁的。这就叫做轻量级锁，也叫做自旋锁。

默认情况下，自选次数超过10次，或者自旋带等着的线程超过整个cpu核数的二分之一，此时轻量级锁升级为重量级锁。



**小结：**

- 默认synchronized(o) 00->轻量级锁，默认情况下偏向锁有一个时延，默认是4秒，因为JVM虚拟机自己有一些默认启动的线程，里面有好多sync代码，这些sync代码启动时就知道肯定会有竞争，如果使用偏向锁，如果使用偏向锁就会造成偏向锁不断的进行锁撤销和锁升级的操作，效率低小。可以使用`-XX:BiasedLockingStartupDelay=0`关闭时延.

- **如果有线程上锁：**会上偏向锁，指的就是，把markword的线程ID改成自己的线程ID的过程；偏向锁不可重偏向，批量偏向，批量撤销；
- **如果有线程竞争：**撤销偏向锁，升级轻量锁；线程在自己的线程栈生成LockRecord，用CAS操作将markword设置为指向自己这个线程的LR的指针，设置成功者得到锁
- **如果竞争加剧：**竞争加剧，有线程超过10次自旋，-XX：PreBlockSpin，或者自旋线程数超过CPU核数的一半，整个锁升级为重量级锁。而在1.6之后，加入了自适应自旋Adapative Self Spinging，JVM自己控制，一般不用去调优；**升级重量锁**，向操作系统申请资源，linux mutex，CPU从3级-0级系统调用（用户态是ring3，内核态是ring0），线程挂起，进入等待队列，等待操作系统的调度，然后再映射回用户空间。
- 轻量级锁是运行在用户态，不用和内核态打交道，效率特别高
- 切记：自旋锁是一个循环，循环是需要不断消耗CPU的，是存在竞争的，如果竞争特别激烈，一万个竞争在自旋等待，有一个线程就是不释放锁，那么CPU的消耗特别高。
- 升级为重量级锁是有好处的，升级为重量级锁是有一个队列的，会把那些自旋等待的线程，放入这个队列，在这个队列里是不消耗CPU的，由操作系统负责唤醒(wait/notify)
- synchronized是一个非公平锁
- 以上实验环境是JDK11，打开就是偏向锁，而JDK8默认对象头就是无锁
- 偏向锁默认就是打开的，但是有一个时延，如果要观察到偏向锁，应该设定参数



> **锁介绍**

**偏向锁** - 严格来讲不是锁 - markword上记录当前线程**指针**，下次同一个线程加锁的时候，不需要争用，只需要判断线程指针是否是同一个，所以，偏向锁，偏向加锁的第一个线程。hashCode备份在线程栈上线程销毁，锁降级为无锁

有争用 - 锁升级为**轻量级锁** - 每个线程都有自己的LockRecord在自己的线程栈上，用CAS去争用markword的LR的指针，指针指向哪个线程的LR，哪个线程就拥有锁。

自旋次数超过10次，升级为**重量级锁** - 如果太多线程自旋CPU消耗太大，不如升级为重量级锁，进入等待队列（不消耗CPU） -XX:PreBlockSpin

自旋锁在JDK1.4.2中引入，使用-XX:+UseSpinging来开启。JDK6中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。

自适应自选锁意味着自旋的时间（次数）不在固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自选等待刚刚成功获得的锁，并且持有锁的线程正在运行中，那么虚拟机就有认为这次自旋也是很有可能再次成功，进而允许它自旋等待持续相对更长的时间。如果对于某个锁，自旋很少获得成功，那么以后在尝试获得这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。

偏向锁由于有锁撤销的过程revoke，会消耗系统资源，所以在锁争用特别激烈的时候，用偏向锁未必效率高，还不如直接使用轻量级锁。



**锁降级（不重要）**

锁降级的过程其实不重要，在某些特定的情况下会发生（也就是在GC的时候会发生），这把锁不被任何线程锁定，这个时候降级没有意义，已经在GC了。



**锁消除 lock eliminate**

```java
public void add(String str1, String str2){
    StringBuffer sb = new StringBuffer();
    sb.append(str1).append(str2);
}
```

我们都知道StringBuffer是线程安全的，因为它的关键方法都是被synchronized修饰的；

但是看上面的代码，我们会发现，sb这个引用只会在add方法中使用，不可能被其他的线程引用（因为是局部变量，是私有的）因此sb是不可能有共享资源的，JVM会自动消除StringBuffer对象内部的锁。

**锁粗化 lock coarsening**

```java
public String test(String str){
    int i=0;
    StringBuffer sb = new StringBuffer();
    while(i<100){
        sb.append(str);
        i++;
    }
    return sb.toString();
}
```

JVM会检测到这一连串的操作都对同一个对象加锁（while循环内100次执行append，没有锁粗化的就要进行100次加锁/解锁），此时JVM就会将加锁的范围粗化到这一连串操作的外部（比如while虚幻体外），使得这一连串操作只需要加一次锁即可）

