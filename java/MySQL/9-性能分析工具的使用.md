### 第09章 性能分析工具的使用

#### 0. 数据库服务器的优化步骤

当我们遇到数据库调优问题的时候，该如何思考呢？

整个流程划分成了 观察（Show status）和行动（Action）两个部分。字母S的部分代表观察（会使用相应的分析工具），字母A代表的部分是行动（对应分析可以采取的行动）。

![image-20231006151740760](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310061517836.png)

![image-20231006152030952](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310061520954.png)

![image-20231006152904252](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310061529300.png)

![image-20231006153749687](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310061537210.png)

![image-20231006154454957](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310061544039.png)

![image-20231006154602491](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310061546549.png)

```MySQL
# 常用的MySQL profiling的单条语句
# 5.1版本以后show profile剖析单条语句功能，支持show profile和show profiling语句，参数having_profiling控制是否开启：
# 查看是否支持这个功能（查询为yes表示支持）
show variables like 'having_profiling';

# 需要临时使用时
set profiling=1;
# 某一条查询语句
select count(*) from xx;
# 所有查询的查询过程
show profiles;
# 单个查询语句的查询过程
show profile for query 1;
# 查看某一类型的执行过称
show prfile cpu for query 2;
```

#### 0.1 查看系统性能的参数

在MySQL中，可以使用show status语句查询一些MySQL数据库服务器的**性能参数**，**执行频率**。

```mysql 
show [global|session] status like '参数';
```

![image-20231006161928531](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310061621920.png)

- 查询MySQL服务器的连接次数，则下面的执行语句是：

  ```MySQL
  show status like 'Connections';
  ```

- 查询服务器的工作时间

  ```MySQL
  show status like 'Uptime';
  ```

- 查询MySQL服务器的慢查询次数

  ```MySQL
  show status like 'Slow_queries';
  ```

- 查询相关指令的情况

  ```MySQL
  show status like 'Innodb_rows_%';
  ```

  ![image-20231006164449889](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310061644019.png)

#### **1.** **统计SQL的查询成本：last_query_cost**

![image-20231006164840753](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310061648832.png)

![image-20231006165114582](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310061651648.png)

`value` 表示的值为20多，表示**查询成本需要20个数据页**。

![image-20231006165546388](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310061655498.png)

```mysql
SHOW STATUS LIKE 'last_query_cost';
```

使用场景：它对于比较开销是非常有用的，特别是我们有好几种查询方式可选的时候。

> SQL 查询是一个动态的过程，从页加载的角度来看，我们可以得到以下两点结论：
>
> 1. `位置决定效率`。如果页就在数据库`缓冲池`中，那么效率是最高的，否则还需要从`内存`或者`磁盘`中进行读取，当然针对单个页的读取来说，如果页存在于内存中，会比在磁盘中读取效率高很多。
> 2. `批量决定效率`。如果我们从磁盘中对单一页进行随机读，那么效率是很低的（差不多10ms），而采用顺序读取的方式，批量对页进行读取，平均一页的读取效率就会提升很多，甚至要快于单个页面在内存中的随机读取。
>
> 所以说，遇到I/O并不用担心，方法找对了，效率还是很高的。我们首先要考虑数据存放的位置，如果是经常使用的数据就要尽量放到`缓冲池`中，其次我们可以充分利用磁盘的吞吐能力，一次性批量读取数据，这样单个页的读取效率也就得到了提升。

#### **2.** **定位执行慢的SQL：慢查询日志**

MySQL的慢查询日志，用来记录在MySQL中`响应时间超过阈值`的语句，具体指运行时间超过`long_query_time`的值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为`10`，意思是运行10秒以上（不含10秒）的语句，认为是超出了我们的最大忍耐时间值。

默认情况下，MySQL数据库`没有开启慢查询日志`，需要我们手动来设置这个参数。`如果不是调优需要的话，一般不建议启动该参数`，因为开启慢查询日志会或多或少带来一定的性能影响。

##### **2.1** **开启慢查询日志参数**

MySQL的慢查询日志，用来记录MySQL中`响应时间超过阈值`的语句，具体指运行时间超过`long_query_time`值的SQL，则会记录到慢查询日志中。`long_query_time`的默认值为10，意思是运行10s以上（不含10s）的语句，认为是超出了我们的最大忍耐限度。

它的主要作用是帮助我们发现那些执行时间特别长的SQL语句，并且有针对性的进行优化。从而提高系统的整体效率。当我们的数据库云服务器发生阻塞、运行变慢的时候，检查一下慢查询日志，找到那些慢查询，对解决问题很有帮助。比如一条SQL执行超过5s，我们就算慢查询SQL，希望收集超过5s的SQL，结合explain进行全面的分析。

默认情况下，MySQL没有开启慢查询日志，我们需要手动设置这个参数。如果不是调优的需要的话，一般`不建议启动这个参数`，因为开启慢查询或多或少会带来性能上的损耗。

慢查询日志支持将日志记录写入文件。

**1.** **开启slow_query_log**

==这个地方设置的变量必须是全局的。==

```mysql
set global slow_query_log='ON';
```

查看下慢查询日志是否开启，以及慢查询日志文件的位置：

```mysql
show variables like `%slow_query_log%`;
```

![image-20231007102350441](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310071023499.png)

**2.** **修改long_query_time阈值**

```mysql
show variables like '%long_query_time%';
```

![image-20231007104058016](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310071040062.png)

```mysql
#测试发现：设置global的方式对当前session的long_query_time失效。对新连接的客户端有效。所以可以一并 执行下述语句 
mysql > set global long_query_time = 1; 
mysql> show global variables like '%long_query_time%'; 

mysql> set long_query_time=1; 
mysql> show variables like '%long_query_time%';
```

![image-20231007105053008](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310071051343.png)

![image-20231007105218572](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310071052618.png)

注意：在当前session中，使用global设置的慢查询时间只对global的long_query_time有效，对局部的long_query_time无效，不过打开新的session对二者都有效；使用局部设置慢查询时间对局部有效，对新的session也有效。

![image-20231007105730408](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310071057504.png)

##### **2.2** **查看慢查询数目**

```mysql
SHOW GLOBAL STATUS LIKE '%Slow_queries%';
```

![image-20231007105837091](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310071058133.png)

**案例演示：**

![image-20231007111706868](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310071117948.png)

![image-20231007111750216](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310071117283.png)

**测试以及分析：**

> 测试

![image-20231007124451087](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310071244168.png)

从上面的结果可以看出，查询编号为3455655的学生信息花费为3.52s。查询学生姓名为“oQmLUr”的学生花费时间为3.66s。已经到达了秒的数量级，说明目前查询效率是比较低的。下面来分析一下原因。

> 分析

```MySQL
show status like 'slow_queries';
```

![image-20231007131912603](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310071319773.png)

##### **2.3** **慢查询日志分析工具：mysqldumpslow**

查看mysqldumpslow的帮助信息

```MySQL
mysqldumpslow --help
```

```shell
#得到返回记录集最多的10个SQL 
mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log 
#得到访问次数最多的10个SQL 
mysqldumpslow -s c -t 10 /var/lib/mysql/atguigu-slow.log
#得到按照时间排序的前10条里面含有左连接的查询语句 
mysqldumpslow -s t -t 10 -g "left join" /var/lib/mysql/atguigu-slow.log 
#另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况 
mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log | more
```

![image-20231007183251042](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310071833605.png)

```
sudo mysqldumpslow -a -s t -t 5 /var/lib/mysql/yang-Lenovo-slow.log
```

![image-20231007183441922](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310071834016.png)

**工作中常用参考：**

```MySQL
# 得到返回记录最多的10个SQL
mysqldumpslow -a -s r -t 10 /var/lib/mysql/yang-Lenovo-slow.log

# 得到访问次数最多的10条SQL
mysqldumpslow -a -s c -t 10 /var/lib/mysql/yang-Lenovo-slow.log

# 得到按照时间排序的前10条里面含有左连接的查询语句
mysqldumpslow -a -s t -t 10 -g "left join" /var/lib/mysql/yang-Lenovo-slow.log

# 另外建议在使用这些命令时结合 | 和 more 使用，否则有可能出现爆屏情况
mysqldumpslow -a -s r -t 10 /var/lib/mysql/yang-Lenovo-slow.log | more
```

##### **2.4** **关闭慢查询日志**

**方式1：永久性方式**

```ini
[mysqld] 
slow_query_log=OFF
#或 把slow_query_log一项注释掉
[mysqld] 
#slow_query_log =OFF
```

重启MySQL服务器，执行如下语句查询慢日志功能

```MySQL
show variables like '%slow%'; # 查询慢查询日志所在目录
show variables like '%long_query_time%'; # 查询超时时长
```

![image-20231007191514912](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310071915025.png)

**方式2：临时性方式**

```mysql
SET GLOBAL slow_query_log=off;
```

重启MySQL，使用show语句查询慢查询日志功能信息，具体SQL语句如下：

```MySQL
show variables like '%slow%'; # 查询慢查询日志所在目录
show variables like '%long_query_time%'; # 查询超时时长
```



**删除慢查询日志**

使用show语句显示慢查询日志信息，具体SQL语句如下。

```MySQL
show variables like 'show_query_log%';
```

![image-20231007192852404](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310071929276.png)

从执行结果可以看出，慢查询日志的目录默认为MySQL的数据库目录，在该目录下 **手动删除查询日志文件** 即可。

使用命令 `mysqladmin flush-logs`来重新生成查询日志文件（包括各种日志），具体命令如下，执行完毕会在数据目录下重新生成慢查询日志文件。

```ini
mysqladmin -uroot -p flush-logs slow # 仅仅重新生成慢查询日志
```

> **提示**
>
> 慢查询日志都是使用mysqladmin flush-logs命令来删除重建的。使用时一定要注意，一旦执行了这个命令，慢查询日志都只会存在于新的日志文件中，如果需要旧的查询日志，就必须提前备份。

#### **3.** **查看** **SQL** **执行成本：SHOW PROFILE**

```mysql
show variables like 'profiling';
#开启
set profiling = 'ON';
#查看
show profiles;
show profile cpu,block io for query 2;
```

![image-20231007194833363](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310071948411.png)

![image-20231007194906123](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310071949209.png)

![image-20231007194016161](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310071940329.png)



#### **4.** **分析查询语句：EXPLAIN**

![image-20231007194242205](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310071942326.png)

![image-20231007194541518](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310071945612.png)

##### **4.1** **基本语法**

```mysql
EXPLAIN SELECT select_options 
#或者
DESCRIBE SELECT select_options
```

EXPLAIN 语句输出的各个列的作用如下：

| 列名          | 描述                                                     |
| ------------- | -------------------------------------------------------- |
| id            | 在一个大的查询语句中每个SELECT关键字都对应一个`唯一的id` |
| select_type   | SELECT关键字对应的那个查询的类型                         |
| table         | 表名                                                     |
| partitions    | 匹配的分区信息                                           |
| `type`        | 针对单表的访问方法                                       |
| possible_keys | 可能用到的索引                                           |
| key           | 实际上使用的索引                                         |
| `key_len`     | 实际使用到的索引长度                                     |
| ref           | 当使用索引列等值查询时，与索引列进行等值匹配的对象信息   |
| `rows`        | 预估的需要读取的记录条数                                 |
| filtered      | 某个表经过搜索条件过滤后剩余记录条数的百分比             |
| `Extra`       | 一些额外的信息                                           |

##### **4.2 EXPLAIN各列作用**

**1. table**

不论我们的查询语句有多复杂，包含了多少个表 ，到最后也是需要对每个表进行`单表访问`的，所以MySQL规定**EXPLAIN语句输出的每条记录都对应着某个单表的访问方法**，该条记录的table列代表着该表的表名（有时不是真实的表名字，可能是简称）。

**2. id**

我们写的关键字一般是以select关键字开头，比较简单的查询语句里只有一个select关键字，比如下面的查询语句：

```MySQL
select * from s1 where key1='a';
```

稍微复杂一点的连接中也只有一个select关键字，比如：

```MySQL
select * from s1 inner join s2
on s1.key1 = s2.key1
where s1.common_field = 'a';
```

```mysql
# 查询的每一行记录都对应着单表
Explain select * from s1 where key1 = 'a';
```

![image-20231007203438283](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310072034368.png)

```mysql 
# s1：驱动表   s2：被驱动表
explain select * from s1 inner join s2;
# select 只有一个，所以id是1，但是有两张表，所以有两条记录
```

![image-20231007203523691](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310072035786.png)

```MySQL
# 第一个select对应第一个表
# 第二个select对应第二个表
explain select * from s1 where key1 in (select key1 from s2) or key3='a';
```

![image-20231007204654073](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310072046163.png)

```MySQL
# 查询优化器可能对涉及子查询的查询语句进行重写，转变为多表查询操作，因此输出select的id为1
EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key2 FROM s2 WHERE common_field='a');
```

![image-20231007205110343](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310072051460.png)

```MySQL
# union 去重：union使用临时表去除的重复的数据
explain select * from s1 union select * from s2;
```

![image-20231007205242246](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310072052358.png)

```MySQL
# union all不去重，所以不需要创建临时表
explain select * from s1 union all select * from s2;
```

![image-20231007205531877](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310072055978.png)

**小结：**

- **id如果相同，可以认为是一组，从上往下顺序执行**
- **在所有组中，id值越大，优先级越高，越先执行**
- **关注点：id号每个号码，表示一趟独立的查询,一个sql的查询趟数越少越好**

**3. select_type**

一条大的查询语句里面包含若干个select关键字，**每个select关键字代表着一个小的查询语句**，而每个select关键字的from子句中都可以包含若干张表（这些表用来做连接查询），**每一张表都对应着执行计划输出中的一条记录**，对于在同一个select关键字中的表来说，他们的id是相同的。

MySQL为每一个select关键字代表的小查询都定义了一个称之为select_type的属性，意思是我们只要知道了某个小查询的select_type属性，就知道了这个 `小查询在大查询中扮演了什么角色`。

![image-20231007203648550](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310072036611.png)

```MySQL
# 查询语句中不包含union或者子查询的查询都算作simple类型
explain select * from s1;

# 连接查询也算是simple类型
explain select * from s1 inner join s2;

# 对于包含union或union all或子查询的大查询来说，它是由几个子查询组成的，其中最左边查询的select_type值就是primary，或者也叫做外层，查询的类型就是primary

# 对于包含union或union all或子查询的大查询来说，它是由几个子查询组成的，其中除了最左边的那个小查询以外，其余的小查询的select_type的类型值是union

# MySQL选择使用临时表来完成union查询的去重工作，针对该临时表的查询的select_type就是union result
explain select * from s1 union select * from s2;

# 不去重, 所以是union
explain select * from s1 union all select * from s2;

# 子查询：
# 如果包含子查询的查询语句不能够转为对应的semi-join的形式，并且该子查询是不相关子查询
# 该子查询的第一个select关键字代表的那个查询的select_type就是subquery
explain select * from s1 where key1 in (select key1 from s2) or key3='a';

# 如果包含子查询的查询语句不能够转化为对应的semi-join的形式，并且该子查询是相关子查询
# 则该子查询的第一个select关键字代表的那个查询的select_type就是dependent subquery
explain select * from s1
where key1 in (select key1 from s2 where s1.key2=s2.key2) or key3='a';
# 注意，select_type为dependent subquery的查询可能会被执行多次。
```

![image-20231007224352876](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310072243037.png)

```MySQL
# 在包含 union 或者 union all 的大查询中，如果各个小查询都依赖于外层查询的话，那除了
# 最左边的那个小查询以外，其余的小查询的select_type的值就是dependent union
explain select * from s1
where key1 in (select key1 from s2 where key1='a' union select key1 from s1 where key1='b');
```

![image-20231007231417753](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310072314881.png)

```mysql
# 对于包含派生表的查询，该派生表对应的子查询的select_type就是derived
explain select *
from (select key1, count(*) as c from s1 group by key1) as derived_s1 where c>1;
```

![image-20231007232129566](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310072321686.png)

```mysql
# 当查询优化器在执行包含子查询的语句时，选择将子查询物化之后与外层查询进行连接查询时，该子查询对应的select_type属性就是materialized
explain select * from s1 where key1 in (select key1 from s2); # 子查询被转化为物化表
```

![image-20231007232802692](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310072328855.png)

**4. partitions**

![image-20231007233243171](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310072332235.png)

![image-20231008095237665](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310080952823.png)

**5. type（重点）**

执行计划的一条记录就代表着MySQL对某个表的 `执行查询时的访问方法`，又称`访问类型`，其中的`type`就表明了这个访问方法是啥，是较为重要的一个指标，比如看到type列是`ref`，表明MySQL即将使用`ref`访问方法来执行对`s1`表的查询。

完整的访问方法如下：`system`、`const`、`eq_ref`、`ref`、`fulltext`、`ref_or_null`、`index_merge`、`unique_subquery`、`index_subquery`、`range`、`index`、`ALL`。

如果type的类型取值为`NULL`，则说明查询优化执行时不用访问表数据，可能通过索引就搞定了，或者根本就没有数据。

- `system`

  当表中`只有一条记录`并且该表使用的存储引擎的统计数据是精确的，比如MyISAM，memory，那么对该表的访问方法就是`system`，比方说我们新建了一个MyISAM表，并为其插入了一条记录：
  
  ```MySQL
  create table t(i int) Engine=MyIsaM;
  
  INsert into t values(1);
  
  explain select * from t;
  ```
  
  ![image-20231008095944760](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310080959858.png)
  
  ```MySQL
  # 换成Innodb
  create table tt(i int) engine=Innodb;
  insert into tt values(1);
  explain select * from tt;
  ```
  
  ![image-20231008102210393](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310081022822.png)
  
  由于Innodb统计数据不是精确的，而且也不是索引，所以只能实打实数一下。所以就是ALL。
  
- `const`

  当我们根据主键或唯一的二级索引与常数进行等值匹配时，对单表的访问方法就是 `const`

  ```MySQL
  explain select * from s1 where id = 10005; # const
  
  explain select * from s1 where key2 = 10036; # const
  
  explain select * from s1 where key3 = 1111;
  ```

  ![image-20231008104536882](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310081045990.png)

  ![image-20231008112549170](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310081125295.png)

  ![image-20231008112711980](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310081127079.png)

- `eq_ref`

  在连接查询时，如果被驱动表是通过主键或者唯一索引等值匹配的方式进行访问的，（如果该主键或者唯一二级索引是联合索引的话，所有的索引都必须进行等值比较），则对该被驱动表的访问方法就是 `eq_ref`

  > 在输出的执行计划中，排在第一行的表是**驱动表**，排在第二行的表是**被驱动表**。
  >
  > 驱动表在SQL语句执行过程中，总是先读取，而被驱动表在SQL语句执行的过程中，总是后读取。
  >
  > left join中：左表示驱动表，右表示被驱动表
  >
  > right join中：右表示驱动表，左表示被驱动表
  >
  > inner join中：MySQL会选择小表作为驱动表，大表作为被驱动表
  >
  > - 小表选择：在决定哪个表作为驱动表的时候，应该是两个表按照各自的条件过滤，过滤完成之后，计算参与join的各个字段的总数据量，数据量小的表，就是“小表”，应该作为驱动表。

  ```MySQL
  explain select * from s1 inner join s2 on s1.id = s2.id;
  ```

  ![image-20231008113157909](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310081131015.png)

- `ref`

  当通过普通的二级索引与常量进行等值匹配的时候来查询某个表，那么对该表的访问方法就可能是`ref`

  ```MySQL
  explain select * from s1 where key1='a'; # ref
  explain select * from s1 where key3=10036; # ALL
  # 解释一下：这里key1和key3都是普通索引，但是为什么key1是ref，而key3是ALL呢，首先key1和key3都是varchar类型，而key3=10036在进行等值匹配的时候用上了函数，用上函数那就说明不会用索引了，所以key3的type就是ALL，我们把10036改成'10036'，那么key3的type就变成ref；而key1='a'就是字符串的等值匹配，所以type=ref。
  ```

  ![image-20231008113511511](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310081135635.png)

- `ref_or_null`

  当对普通二级索引进行等值匹配查询时，该索引列的值也可以是NULL值时，那么对该表的访问方法就可能是 `ref_or_null`

  ```MySQL
  explain select * from s1 where key1='a' or key1 is NULL;
  ```

  ![image-20231008114242405](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310081142549.png)

- `index_merge`

  单表访问方法时在某些场景下可以使用`intersection`、`union`、`sort-union`这三种索引合并的方式来执行查询。

  ```MySQL
  explain select * from s1 where key1='a' or key3='a';
  ```

  ![image-20231008114533758](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310081145032.png)

- `unique_subquery`是针对在一些包含`in`子查询的查询语句中，如果查询优化器决定将`in`子查询转换为`exists`子查询，而且子查询可以使用到主键进行等值匹配的话，那么该子查询执行计划的`type`列的值就是`unique_subquery`

  ```MySQL
  explain select * from s1
  where key2 in (select id from s2 where s1.key1=s2.key1) or key3='a';
  ```

  ![image-20231008115108343](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310081151596.png)

- `range`

  如果使用索引获取某些“范围区间”的记录，那么就可能使用到“range”访问方法

  ```MySQL
  explain select * from s1 where key1 in ('a', 'b', 'c');
  explain select * from s1 where key1 > 'a' and key1 < 'b';
  ```

  ![image-20231008115836755](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310081158882.png)

  ![image-20231008115949403](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310081159499.png)

- `idnex`

  当我们可以使用索引覆盖，但需要扫描全部的索引记录时，该表的访问方法就是`index`

  ```MySQL
  explain select key_part2 from s1 where key_part3='a';
  ```

  ![image-20231008145658569](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310081456767.png)

  ![image-20231008145725671](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310081457825.png)

  我们发现我们要查询的索引和条件索引按顺序都是联合索引的一部分，因此可以按照联合索引进行查询，从而不用进行回表。

- `ALL`

  全表扫描

  ```MySQL
  explain select * from s1;
  ```

  ![image-20231008150020955](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310081500074.png)

**结果值从最好到最坏依次是：** **system > const > eq_ref > ref** **> fulltext > ref_or_null > index_merge > unique_subquery > index_subquery >** **range > index > ALL** 

**SQL性能优化的目标：至少要达到 range级别，要求是ref级别，最好是consts级别。（阿里巴巴开发手册要求）**

**6. possible_keys和key**

在explain语句输出的执行计划中，`possible_keys`列表示在某个查询语句中，对某个表执行单表查询时可能用到的索引有哪些，一般查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用。`key`列表示`实际用到的索引`有哪些，如果为null，则没有使用索引。比如说下面的这个查询：

`possible_keys`里面可以用到的索引越多，那么筛选的时候就越消耗性能，因为`key`只有一个。

`key`并不一定是`possible_keys`的子集

```MySQL
EXPLAIN SELECT * FROM s1 WHERE key1 > 'z' AND key3 = 'a';
```

![image-20231008152855444](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310081529871.png)

```MySQL
EXPLAIN SELECT * FROM s1 WHERE key1 > 'z' or key3 = 'a';
# 说明key1和key3的索引都用上了
```

![image-20231008154908073](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310081549334.png)

**7. key_len（重点）**

`key_len`实际使用到索引长度（即：字节数）

帮你检查是否充分的使用上了索引；针对联合索引而言，这个值越大越好

**key_len的长度计算公式：**

```MySQL
varchar(10)变长字段且允许NULL = 10 * ( character set： utf8=3,gbk=2,latin1=1)+1(NULL)+2(变长字段) 

varchar(10)变长字段且不允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1)+2(变长字段)

char(10)固定字段且允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1)+1(NULL) 

char(10)固定字段且不允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1)

int 固定字段且允许为NULL = 4 + 1(NULL)
int 固定字段且不允许为NULL = 4
```

```MySQL
explain select * from s1 where id=10005;
```

![image-20231008155455236](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310081554359.png)

```mysql
explain select * from s1 where key2 = 10036;
```

![image-20231008155605553](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310081556665.png)

```mysql
explain select * from s1 where key1='a';
```

![image-20231008160135894](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310081601030.png)

```mysql
explain select * from s1 where key_part1='a';
```

![image-20231008160240616](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310081602750.png)

```mysql
explain select * from s1 where key_part1='a' and key_part2='b';
```

![image-20231008160420391](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310081604516.png)

```MySQL
explain select * from s1 where key_part1='a' and key_part2='b' and key_part3='c';
```

![image-20231008161314927](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310081613193.png)

上面的3个例子中：key_len的长度分别是303，606，909，值越大越好，这是针对联合索引而言的。

但是下面的例子`key_len`就是`null`，是因为不符合`最左前缀原则`。

```MySQL
explain select * from s1 where key_part3='c';
```

![image-20231008161625661](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310081616772.png)

**8. ref** 

当使用索引列进行等值查询时，与索引列进行等值匹配的对象信息。

比如只是一个常数或者某个列。

```MySQL
explain select * from s1 where key1='a'; # 常数
```

![image-20231008162743591](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310081627724.png)

```mysql
explain select * from s1 inner join s2 on s1.id = s2.id; # id 列
```

![image-20231008162943718](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310081629840.png)

```MySQL
explain select * from s1 inner join s2 on s2.key1 = upper(s1.key1);
```

![image-20231008164307713](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310081643965.png)

**9. rows（重点）**

预估的需要读取的记录条数；**值越小越好**。

之所以越小越好，是因为查询的记录就有可能在同一个页中，那么IO次数相对就比较小。

```MySQL
explain select * from s1 where key1 > 'z';
```

![image-20231008164550666](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310081645916.png)

**10. filtered**

某个表经过搜索条件过滤后剩余记录条数的百分比。**越大越好**。

如果使用的是 索引执行的单表扫描，那么计算时需要估计出  满足除使用到对应索引的搜索条件外的其他搜索条件的记录有多少条。

```MySQL
explain select * from s1 where key1>'z' and common_field = 'a';
```

![image-20231008165323060](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310081653225.png)

满足索引的记录条数是374条，满足其他的搜索条件的记录条数是 374*10%；



对于单表查询来说，这个`filtered`列的值没什么意义，我们更关注在连接查询中**驱动表对应的执行计划记录的filtered值**，它决定了被驱动表要执行的次数（即：rows * filtered）

```MySQL
explain select * from s1 inner join s2 on s1.key1=s2.key1 where s1.common_field='a';
```

![image-20231008170454985](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310081704148.png)

**11. Extra**

`Extra`列是用来说明一些额外信息的，包含不适合在其他列中显示但十分重要的额外信息。我们可以通过这些额外信息来 `更准确的理解MySQL到底将如何执行给定的查询语句`。MySQL提供的额外信息有好几十个，接下来介绍几个比较重要的额外信息。

- `No tables used`

  当查询语句没有from子句时会提示该额外信息，比如：

  ![image-20231008170933063](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310081709226.png)

- `Impossible Where`

  当查询语句的where子句永远为false时

  ![image-20231008171127538](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310081711655.png)

- `Using where`

  当我们使用**全表扫描**来执行对某个表的查询， 并且该语句的where子句中有针对该表的搜索条件时，在`Extra`会提示该额外信息

  ![image-20231008171402797](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310081714916.png)

  当使用索引来访问执行对某个表的查询，并且该语句的`where`子句中有除了该索引包含的列之外的其他搜索条件时，在`Extra`会提示该额外信息

  ![image-20231008171706398](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310081717353.png)

- `No matching min/max row`

  当查询列表处有 `min` 或 `max` 聚合函数，但是并**没有**符合`where`子句中的搜索条件的记录时，将会提示该额外信息

  ![image-20231008172024339](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310081720463.png)

- `Using index`

  当查询列表以及搜索条件中只包含属于某个索引的列，也就是在可以使用覆盖索引的情况下，在`Extra`列将会提示该额外信息。

  ```MySQL
  explain select key1 from s1 where key1='a';
  ```

  ![image-20231008182207947](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310081822079.png)

  key1在这个情况里属于**覆盖索引**，是因为通过key1查询的记录，不用进行**回表**操作，直接可以在记录里面返回key1这个值，所以key1被称为**覆盖索引**。假如此时select的是key1，id，那么它也是覆盖索引，因为查询到的记录里同时也包含id，如果select里面包含了记录里面不包含的字段，那么这就不是**覆盖索引**。

- `Select tables optimized away`

  如果`where`子句中条件成立，则会提示该额外信息。

  ![image-20231008172628024](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310081726257.png)

- `Using index condition`

  有些搜索条件中虽然出现了索引列，但是却不能使用索引，比如下面这个语句：

  ```MySQL
  select * from s1 where key1 > 'z' and key1 like '%a';
  ```

  ![image-20231008192400035](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310081924283.png)

  其中`key1>'z'`可以使用到索引，但是`key1 like '%a'`却无法使用到索引，在以前版本的MySQL中，是按照下面的步骤来进行查询的：

  - 先根据 `key1 > 'z'`这个条件，从二级索引`idx_key1`中获取到对应的二级索引记录。
  - 根据上一步骤中得到的二级索引记录的主键值进行**回表**，找到完整的用户记录再监测该记录是否符合`key1 like '%a'`这个条件，将符合条件的记录加入到最后的结果集里。

  但是虽然`key1 like '%a'`不能组成范围区间参与`range`访问方法的执行，但这个条件毕竟只涉及到了`key1`列，所以MySQL把上边的步骤改进了一下：

  - 先根据`key1>'z'`这个条件，定位到二级索引`idx_key1`中对应的二级索引记录。
  - 对于指定的二级索引记录，先不着急**回表**，而是检测一下该记录是否满足`key1 like '%a'`这个条件，如果这个条件不满足，则该二级索引记录压根不需要**回表**。
  - 对于满足`key1 like '%a'`这个条件的二级索引记录执行回表操作。

  我们说回表操作其实是一个`随机IO`，比较耗时，所以上述修改虽然只改进了一点点，但是却可以省却许多的回表操作的成本。MySQL把他们这个改进称之为`索引条件下推`（`Using Index condition`）。

  如果在查询语句的执行过程中将要使用`索引条件下推`这个特性，在Extra列中将会显示`Using Index condition`。

- `Using join buffer (hash join)`

  在连接查询执行过程中，当被驱动表不能有效的利用索引加快访问速度，MySQL一般会为其分配一块名为 “join buffer”的内存块来加快查询速度，也就是我们所讲的 “基于块的嵌套循环算法”

  ```MySQL
  explain select * from s1 inner join s2 on s1.common_field = s2.common_field;
  ```

  ![image-20231008193047809](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310081930006.png)

- `Not exists`

  当我们使用左外连接时，如果`where`子句中包含  要求被驱动表的某个列等于`null`值的搜索条件，而且那个列又是不允许为NULL值的，那么在该表的执行计划的`Extra`列就会提示`Not Exists`额外信息。

  ```MySQL
  explain select * from s1 left join s2 on s1.key1 = s2.key1 where s2.id is NULL;
  ```

  ![image-20231008195405459](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310081954605.png)

- `Using  intersect(...)`

  如果执行计划的`Extra`列出现`Using intersect(...)`提示，说明准备使用`Intersect`索引合并的方式执行查询，括号中的`"..."`表示需要进行索引合并的索引名称；

  如果出现了`Using union(...)`提示，说明准备使用`Union`索引合并的方式执行查询。

  出现了`Using sort union(...)`提示，说明准备使用`Sort-Union`索引合并的方式执行查询。

  ```MySQL
  explain select * from s1 where key1='a' or key3='a';
  ```

  ![image-20231008200853654](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310082008077.png)

- `Zero limit`

  当limit子句的参数为0时，表示压根不打算从表中读取任何记录，将会提示该额外信息

  ```MySQL
  explain select * from s1 limit 0;
  ```

  ![image-20231008201123932](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310082011064.png)

- `Using filesort`

  有一些情况对结果集中的记录进行排序是可以使用到索引的，比如下边这个查询：

  ```MySQL
  explain select * from s1 order by key1 limit 10;
  ```

  ![image-20231008201536237](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310082015384.png)

  这个查询语句可以利用`idx_key1`索引直接取出`key1`列的10条记录，然后再进行回表操作就好了，所以这里的`Extra`的额外信息为`NULL`。但是很多情况下排序操作无法使用索引，只能在内存中（记录较少的时候）或者磁盘中（记录较多的时候）进行排序，MySQL把这种在内存中或者磁盘上进行排序的方式统称为文件排序（文件名：filesort）。如果某个查询需要使用文件排序的方式执行查询，就会在执行计划的`Extra`列中显示`Using filesort`提示，比如这样：

  ```MySQL
  explain select * from s1 order by common_field limit 10;
  ```

  ![image-20231008204304080](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310082043232.png)

- `Using temporary`

  在许多查询的执行过程中，MySQL可能会借助临时表来完成一些功能，比如去重，排序之类的，比如我们在执行许多包含 `distinct`、`group by`、`union`等子句的查询过程中，如果不能有效利用索引来完成查询，MySQL很有可能寻求通过建立内部的临时表来执行查询。如果查询中使用到了内部的临时表，在执行计划的`Extra`列会显示出`Using temporary`提示。

  ```MySQL
  explain select distinct common_field from s1;
  ```

  ![image-20231008204956138](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310082049295.png)

  ```mysql
  explain select common_field, count(*) as amount from s1 group by common_field;
  ```

  ![image-20231008205341508](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310082053629.png)

  执行计划中出现`Using temporary`并不是一个好的征兆，因为建立与维护临时表都要付出很大的成本，所以我们最好能使用索引来代替使用临时表，比如：扫描指定的索引`idx_key1`即可

  ```MySQL
  explain select key1, count(*) as amount from s1 group by key1;
  ```

  ![image-20231008205833337](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310082058564.png)

  

**小结：**

- explain不考虑各种Cache
- explain不能显示MySQL在执行查询时所作的优化工作
- explain不会告诉你关于触发器，存储过程的信息活用户自定义函数对查询的影响情况
- 部分统计信息是估算的，并非精确值

#### **5. EXPLAIN的进一步使用**

##### **5.1 EXPLAIN四种输出格式**

这里谈谈EXPLAIN的输出格式。EXPLAIN可以输出四种格式：`传统格式`，`JSON格式`，`TREE格式`以及`可视化输出`。用户可以根据需要选择适用于自己的格式。

**1.** **传统格式**

![image-20231008213318435](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310082133620.png)

**2. JSON格式** ：包含了执行的成本信息

JSON格式：在EXPLAIN单词和真正的查询语句中间加上`FORMAT=JSON`。用于查看执行成本`cost_info`

```MySQL
explain format=json select ....
```

![image-20231008213657484](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310082136688.png)

这样我们就得到了一个json格式的执行计划，里面包含该计划花费的成本，比如这样：

```MySQL
mysql> explain format=json select * from s1 inner join s2 on s1.key1=s2.key2 where s1.common_field = 'a' \G
*************************** 1. row ***************************
EXPLAIN: {
  "query_block": {
    "select_id": 1,
    "cost_info": {
      "query_cost": "1394.77"
    },
    "nested_loop": [
      {
        "table": {
          "table_name": "s1",
          "access_type": "ALL",
          "possible_keys": [
            "idx_key1"
          ],
          "rows_examined_per_scan": 10152,
          "rows_produced_per_join": 1015,
          "filtered": "10.00",
          "cost_info": {
            "read_cost": "937.93",
            "eval_cost": "101.52",
            "prefix_cost": "1039.45",
            "data_read_per_join": "1M"
          },
          "used_columns": [
            "id",
            "key1",
            "key2",
            "key3",
            "key_part1",
            "key_part2",
            "key_part3",
            "common_field"
          ],
          "attached_condition": "((`atguigu`.`s1`.`common_field` = 'a') and (`atguigu`.`s1`.`key1` is not null))"
        }
      },
      {
        "table": {
          "table_name": "s2",
          "access_type": "eq_ref",
          "possible_keys": [
            "idx_key2"
          ],
          "key": "idx_key2",
          "used_key_parts": [
            "key2"
          ],
          "key_length": "5",
          "ref": [
            "atguigu.s1.key1"
          ],
          "rows_examined_per_scan": 1,
          "rows_produced_per_join": 1015,
          "filtered": "100.00",
          "index_condition": "(cast(`atguigu`.`s1`.`key1` as double) = cast(`atguigu`.`s2`.`key2` as double))",
          "cost_info": {
            "read_cost": "253.80",
            "eval_cost": "101.52",
            "prefix_cost": "1394.77",
            "data_read_per_join": "1M"
          },
          "used_columns": [
            "id",
            "key1",
            "key2",
            "key3",
            "key_part1",
            "key_part2",
            "key_part3",
            "common_field"
          ]
        }
      }
    ]
  }
}
1 row in set, 2 warnings (0.01 sec)
```

![image-20231008213607194](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310082136292.png)

![image-20231008214456226](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310082144439.png)

**3. TREE格式**

TREE格式是8.0.16版本之后引入的新格式，主要根据查询的`各个部分之间的关系`和`各部分的执行顺序`来描述如何查询。

```mysql 
mysql> EXPLAIN FORMAT=tree SELECT * FROM s1 INNER JOIN s2 ON s1.key1 = s2.key2 WHERE
    -> s1.common_field = 'a'\G
*************************** 1. row ***************************
EXPLAIN: -> Nested loop inner join  (cost=1395 rows=1015)
    -> Filter: ((s1.common_field = 'a') and (s1.key1 is not null))  (cost=1039 rows=1015)
        -> Table scan on s1  (cost=1039 rows=10152)
    -> Single-row index lookup on s2 using idx_key2 (key2=s1.key1), with index condition: (cast(s1.key1 as double) = cast(s2.key2 as double))  (cost=0.25 rows=1)

1 row in set, 1 warning (0.00 sec)
```

**4.** **可视化输出**

可视化输出，可以通过MySQL Workbench可视化查看MySQL的执行计划。

##### **5.2 SHOW WARNINGS的使用** 

![image-20231008220251636](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310082202819.png)

```mysql
mysql> EXPLAIN SELECT s1.key1, s2.key1 FROM s1 LEFT JOIN s2 ON s1.key1 = s2.key1 WHERE s2.common_field IS NOT NULL;
# 查看优化后的执行语句
mysql> SHOW WARNINGS\G
```

#### **6.** **分析优化器执行计划：trace**

![image-20231008220836090](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310082208283.png)

```mysql
# 开启
SET optimizer_trace="enabled=on",end_markers_in_json=on; 
# 设置大小
set optimizer_trace_max_mem_size=1000000;
# 使用
select * from student where id < 10;
select * from information_schema.optimizer_trace\G
```

![image-20231008220913553](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310082209698.png)

![image-20231008221002237](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310082210475.png)

#### **7. MySQL监控分析视图-sys schema** 

![image-20231008221146809](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310082211932.png)

**7.1 Sys schema视图使用场景**

**索引情况**

```mysql
#1. 查询冗余索引 
select * from sys.schema_redundant_indexes; 
#2. 查询未使用过的索引 
select * from sys.schema_unused_indexes; 
#3. 查询索引的使用情况 
select index_name,rows_selected,rows_inserted,rows_updated,rows_deleted from sys.schema_index_statistics where table_schema='dbname' ;
```

**表相关**

```mysql
# 1. 查询表的访问量 
select table_schema,table_name,sum(io_read_requests+io_write_requests) as io from sys.schema_table_statistics group by table_schema,table_name order by io desc; 
# 2. 查询占用bufferpool较多的表 
select object_schema,object_name,allocated,data
from sys.innodb_buffer_stats_by_table order by allocated limit 10; 
# 3. 查看表的全表扫描情况 
select * from sys.statements_with_full_table_scans where db='dbname';
```

**语句相关**

```mysql
#1. 监控SQL执行的频率 
select db,exec_count,query from sys.statement_analysis order by exec_count desc; 
#2. 监控使用了排序的SQL 
select db,exec_count,first_seen,last_seen,query
from sys.statements_with_sorting limit 1; 
#3. 监控使用了临时表或者磁盘临时表的SQL 
select db,exec_count,tmp_tables,tmp_disk_tables,query
from sys.statement_analysis where tmp_tables>0 or tmp_disk_tables >0 order by (tmp_tables+tmp_disk_tables) desc;
```

**IO相关**

```mysql
#1. 查看消耗磁盘IO的文件 
select file,avg_read,avg_write,avg_read+avg_write as avg_io
from sys.io_global_by_file_by_bytes order by avg_read limit 10;
```

**Innodb** **相关**

```mysql
#1. 行锁阻塞情况 
select * from sys.innodb_lock_waits;
```

![image-20231008221405211](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310082214402.png)

