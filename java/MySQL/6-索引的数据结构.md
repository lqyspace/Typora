# 06-索引的数据结构

## 1 为什么使用索引

索引是存储引擎用于快速找到数据记录的一种数据结构，就好比一本教科书的目录，通过目录中找到对应文章的页码，便可快速定位到需要的文章。MySQL也是一样的道理，进行数据查找时，==首先查看查询条件是否命中某条索引，符合则通过索引查找相关数据，如果不符合则需要全表扫描，即需要一条一条地查找记录，直到找到与条件相符的记录==

![image-20231003142827916](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310031428996.png)

如上图所示，数据库在没有索引的情况下，数据部分在硬盘的不同位置上，读取数据时，摆臂需要前后摆动查找数据，这样操作非常消耗时间。如果数据顺序摆放，那么也需要从1到6行顺序读取，这样就相当于进行了6次IO操作，依旧非常耗时。如果我们不借助任何索引结构帮助我们快速定位的话，我们查找col2=89这条记录，就要==逐行==去查找，去比较。从col2=34开始，进行比较，发现不是，继续下一行。也就意味着，如果表很大的话，我们可能需要很多次的IO操作才能找到数据。现在要查找col2=89这条记录。cpu必须先去磁盘查找这条记录，找到之后加载到内存，再对数据进行处理。这个过程最耗时的就是就是磁盘IO（涉及到磁盘的旋转时间，速度较快，磁头的寻道时间，速度较慢费时。

![image-20231003153412247](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310031534352.png)





## 2 索引及其优缺点

### 2.1 概述

MySQL官方对索引的定义：**索引（Index）是帮助MySQL高效快速获取数据的数据结构。**

索引的本质：索引是数据结构。可以简单地理解为“排好序的快速查找的数据结构”，满足特定的查找算法。这些数据结构以某种方式指向数据，这样就可以在这些数据结构的基础上实现**高级查找算法**。

==索引是在存储引擎中实现的==，因此每种存储引擎的索引不一定完全相同，并且每种存储引擎不一定支持所有索引类型。同时存储引擎可以定义每个表的==最大索引数==和==最大索引长度==。所有存储引擎支持每个表至少16个索引。总索引长度至少为256字节。有些存储引擎支持更多的索引数和更大的索引长度。

### 2.2 优点

（1）提高数据检索的效率，降低数据库的IO成本，这是创建索引的主要原因。

（2）通过创建唯一索引，可以保证数据库表中每一行数据的唯一性。

（3）在实现数据的参考完整性方面，可以加速表与表之间的连接。换句话，对于有依赖关系的子表和父表联合查询时，可以提高查询速度。

（4）在使用分组和排序子句进行数据查询时，可以显著减少查询中分组和排序的时间，降低了CPU的消耗。

### 2.3 缺点

增加索引也有许多不利的方面，主要表现在如下几个方面：

（1）创建索引和维护索引要消耗时间，并且随着数据的增加，所耗费的时间也会增加。

（2）索引需要占用磁盘空间，除了数据表占数据空间之外，每一个索引还要占用一定的物理空间，存储在磁盘上，如果有大量的索引，索引文件有可能比数据文件更快达到最大文件尺寸。

（3）虽然索引大大提升了查询速度，但是却会降低更新表的速度。当对表中的数据进行增加，删除和修改时，缩索引也要动态的维护，这样就降低了数据的维护速度。

因此，选择使用索引时，需要综合考虑索引的优缺点。

> 提示：
>
> 索引可以提高查询的速度，但是会影响插入记录的速度，这种情况下，最好的办法就是先删除表中的索引，然后就可以频繁地插入数据，插入完成后在创建索引。



## 3 InnodB中索引的推演

### 3.1 索引之前的查找

先来看一个精确匹配的例子

```MySQL
select [列名列表] from 表名 where 列名=xxx;
```

> **在一个页中的查找**

假设目前表中的记录非常的少，所有的记录都可以被放在一个页中，在查找记录的时候根据搜索条件的不同分为两种情况：

- 以主键为搜索条件

  可以在页目录中使用==二分法==快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录

- 以其他的列作为搜索条件

  因为在数据页中并没有对非主键列建立页目录，所以我们无法通过二分法快速定位相应的槽，这种情况下只能从最小记录开始依次遍历单链表中的每条记录，然后对比每条记录是不是符合搜索条件。很显然，这种搜索方式是非常低效的。



> **在很多页中查找**

在很多的页中查找记录一般分为两步：

- 定位到记录所在的页
- 从所在的页内中查找相应的记录

在没有索引的情况下无论是根据主键列还是其他列的值进行查找，由于我们并不能快速的定位到记录所在的页，所以只能==从第一个页==沿着==双向链表==一直往下找，在每一个页中根据我们上面的查找方法查找指定的记录。因为要遍历所有的数据页，所以这种方式显然是超级费时的。如果一个表有一亿条记录呢，那么索引就产生了。



### 3.2 设计索引

![image-20231003161206634](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310031612695.png)

我们只在示意图里展示记录的这几个部分：

- record_type：记录头信息的一项属性，表示记录的类型，0表示普通记录，2表示最小记录，3表示最大记录，1暂时还没用过，下面讲。
- next_record：记录头信息的一项属性，表示下一条地址相对于本条记录地址的偏移量，我们用箭头来表明下一条记录是谁。
- 各个列的值：这里只记录在index_demo表中的三个列，分别是c1，c2，c3。
- 其他信息：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。

![image-20231003161817844](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310031618915.png)

> **一个简单的索引设计方案**

我们根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢？因为各个页中的记录没有规律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以不得不依次遍历所有的数据页。所以如果我们想快速的定位到需要查找的记录在哪些数据页中该咋办？我们可以为 快速定位记录所在的数据页 而建立一个目录，建这个目录必须完成下面几件事：

- **下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值**

  ![image-20231003162723583](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310031627681.png)

  一定要保证插入的时候是按照顺序的，这样做是为了快速的查找。如上图所以，所有的数据都被插入到了页10中，此时如果再插入一条记录：

  ```MySQL
  insert into index_demo values(4,4,'a');
  ```

  因为页10最多只能放3条记录，所以我们不得不再分配一个新页：

  ![image-20231003163214460](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310031632528.png)

  注意，新分配的数据页编号可能并不是连续的，它们只是以双向链表的方式维护着上一个页和下一个页的关系。另外，页10中记录的最大值是5，而新增的记录是4，这就违背了上一页的主键最大值要小于下一页的主键最小值的要求，所以在插入主键为4的记录的时候需要伴随一次==记录移动==，也就是把主键值为5的记录移动到页28中，然后再把主键值为4的记录插入到页10中，过程示意图如下：

  ![image-20231003170801526](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310031708734.png)

  我们必须通过一些诸如==记录移动==的操作来始终保持这个状态一直成立：下一个数据页中用户记录的主键值必须大于上一个数据页中用户记录的主键值。这个过程称为==页分裂==。

- **给所有的页建立一个目录项**

  由于数据页的编号有可能不是连续的，所以在向index_demo表中插入许多条记录以后，可能是这样的效果：

  ![image-20231003181329080](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310031813763.png)

  因为这些16KB的页面在物理存储上是不连续的，所以如果想从这么多页中==根据主键值快速定位某些记录所在的页==，我们需要给它做一个目录，每一个页对应一个目录项每个目录向包含下面两个部分：

  - 页的用户记录中最小的主键值，我们用key表示
  - 页号，我们用page_no表示

  所以我们为上边几个页做好的目录就像这个样子：

  ![image-20231003181702944](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310031817994.png)

  以页28为例，它对应目录项2，这个目录项中包含==该页的页号28==以及==该页中用户记录的最小主键值5==.我们只需要把几个目录项在物理存储器上连续存储（比如：数组），就可以实现根据主键值快速查找某条记录的功能了。比如：查找主键值为20的记录，具体查找过程分两步：

  - 先从目录项中根据==二分法==快速确定出主键值为20的记录在**目录项3**中。
  - 再根据前面的说的页中查找记录的方式去`页9`中定位具体的记录。

  至此，针对数据页做的简易目录就搞定了，这个目录就叫做索引。



> **InnodB中的索引方案**

**迭代1次：目录项记录的页**

上述做了一个简易的索引方案，是因为我们为了在根据主键在进行查找时使用==二分法==快速定位具体的目录项而假设所有的目录都可以在物理存储器上连续存储，但是这样做有几个问题：

- Innodb是使用页来作为管理存储空间的基本单位，最多能保证16KB的连续存储空间，而随着表中记录数量的增多，需要非常大的连续存储空间才能把所有的目录项都放下，这对记录数量非常多的表来说是不现实的。
- 我们时常需要对记录进行增删，假设我们把页28中的记录都删除了，那意味着目录项2也就没有存在的必要了，这就需要把目录项2后面的目录项往前移，这样牵一发而动全身的操作效率很差的

所以我们需要一种灵活管理所有目录项的方式，我们发现目录项其实长的跟我们的用户记录差不多，只不过目录项中的两个列是主键和页号而已，为了和用户记录做一下区分，我们把这些用来表示目录项的记录称为**目录项纪录**。那InnodB是如何区分普通的用户记录还是目录项记录呢？使用记录头信息里的record_type属性，它的各个取值的意思代表如下：

- 0：普通的用户记录
- 1：目录项纪录
- 2：最小记录
- 3：最大记录

我们把前面使用到目录项放到数据页中的样子就是这样：

![image-20231003190659438](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310031907182.png)

从图中可以看出，我们新分配了一个编号为30的页专门存储目录项记录。这里再次强调目录项纪录和普通的用户记录的**不同点**：

- 目录项记录的record_type值是1，而普通用户记录的record_type值是0。
- 目录项记录只有主键值和页的编号两个列，而普通的用户记录的列使用户自定义的，可能包含很多列，另外还有Innodb自己添加的隐藏列。
- 了解：记录头信息还有一个叫min_rec_mask的属性，只有在存储目录项记录的页中的主键值最小的目录项记录的min_rec_mask值为1，其他的记录的min_rec_mask的值都是0。

**相同点**：

两者用的都是一样的数据页，都会为主键值生成Page Directory（页目录），从而在按照主键值进行查找时可以使用二分法来加快查询速度。

现在已查找主键为20的记录为例，根据某个主键去查找记录的步骤就可以大致分为下边两步：

- 先到存储目录项记录的页，也就是页30中通过二分法快速定位到对应目录项，因为12<20<209，所以所以定位到对应的记录的页为9。
- 再到存储用户记录的页9中根据二分法快速定位到主键为20的用户记录。



**迭代2次：多个目录项记录的页**

一般一个页只有16KB的大小，能存放的目录项记录也是有限的。如果表中的数据太多以至于不能在一个页面中存放，那么如何处理呢？

这里我们假设一个存储目录项纪录的页最多只能存储4个目录项记录，所以如果此时我们再向上图中插入一条主键为320的用户记录的话，那就需要分配一个新的存储目录项记录的页：

![image-20231003200806527](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310032008001.png)

从图中我们可以看出，我们插入了一条主键值为320的用户记录之后需要两个新的数据页：

- 为存储该用户记录而新生成了页31
- 因为原先存储目录项记录的页30的容量已经满了（我们假设一个页只能存储4条目录项记录），所以不得不需要一个新的页32来存放页31对应的目录项。

因为现在存储目录项记录的页不止一个，所以如果我们想根据主键值查找一条用户记录大概需要3个步骤，以查找主键值20为例：

- 首先确定==目录项记录页==

  我们现在存储目录项记录的页有两个，即30和32，又因为页30存储的主键的范围是[1, 320)，页32表示的目录项的主键值不小于320，所以主键值为20的记录对应的目录项记录在页30中。

- 在目录项记录页中确定==用户记录真实所在的页==

- 在真实存储用户记录的页中==定位到具体的记录==



**迭代3次：目录项记录页的目录页**

在上一个实例中，第一步其实存在一个问题，我们需要定位存储目录项记录的页，但是这些也是不连续的，如果我们表中的数据非常多则会产生很多==存储目录项记录的页==，那我们如何根据主键值快速定位一个存储目录项记录的页？那就是为这些存储目录项记录的页生成一个更高级的“目录页”，那就像是多级目录一样，==大目录里嵌套着小目录==，小目录才是真实的数据，所以现在各个页的示意图就是这样子：

![image-20231003202313118](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310032023177.png)

如图，我们生成一个存储更高级目录项的页33，这个页中的两条记录分别代表页30和页33，如果用户记录的主键值在[1, 320)之间，则到页30中查找更详细的目录项记录，如果主键值不小于320，则到页33查找更详细的目录项信息。

![image-20231003202612267](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310032026316.png)

如上图所示，它的名称就是B+树。



**B+tree**

一个B+tree的节点其实可以分成好多层，规定最下边的那层，**也就是存放我们用户记录的那层为第0层**，之后依次往上加。之前我们做了一个非常极端的假设：存放用户记录的页最多存放3条记录，存放目录项记录的页最多存放4条记录。其实真实环境一个也能存放的数据量还是很大的，假设所有存放用户记录的叶子结点的数据页可以存放100条用户记录，所有存放目录项记录的内节点代表的数据也可以存放1000条目录项记录，那么：

- 如果B+树只有一层，也就是以只有一个用于存放用户记录的节点，最多能存放100条用户记录。
- 如果B+树有2层，最多可以存放 1000 * 100 = 100000 条记录
- 如果B+树有3层，最多可以存放1000 * 1000 * 100 = 100000000条记录
- 如果B+树有4层，最多可以存放1000 * 1000 * 1000 * 100 = 100000000000条记录

你的表里能存放100000000000条记录吗？所以一般情况下，我们用到的B+树都不会超过4层，按我们通过主键值去查找某条记录最多也只需要4次IO的查找。





### 3.3 常见索引概念

索引按照物理实现方式，可以分为2种：聚簇索引（聚集）和非聚簇（非聚集）索引。我们把非聚簇索引称为**二级索引或辅助索引**。

**1. 聚簇索引**

**聚簇索引**并不是一种单独的索引类型，而是**一种数据存储方式**（所有的用户记录都存储在了叶子结点），也就是所谓的==索引即数据，数据即索引==。

> **术语“聚簇”表示数据行和相邻的键值聚簇的存储在一起。**

**特点**：

1. 使用**记录主键值**的大小进行记录和页的排序，这包括三个方面的含义：

   - **页内**的记录是按照主键的大小顺序拍成一个单向链表
   - 各个存放**用户记录的页**也是根据页中用户记录的主键大小顺序排成一个**双向链表**
   - 存放**目录项记录的页**分为不同的层次，在同一层次中页也是根据页中目录项记录的主键大小顺序排成一个**双向链表**。

2. B+树的**叶子节点**存储的是完整的用户记录。

   所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。

具备这两种特性的B+树被称为**聚簇索引**，所有完整的用户记录都存放在这个聚簇索引的叶子节点处。这种聚簇索引并不需要我们在MySQL语句中显式的使用INDEX语句去创建，Innodb会自动的为我们创建聚簇索引。

**优点：**

1. **数据访问更快**，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比从非聚簇索引更快
2. 聚簇索引对于主键的**排序查找**和**范围查找**速度更快
3. 按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连的，数据库不用从多个数据块找中提取数据，所以**节省了大量的io操作**。

**缺点**：

1. **插入速度严重依赖于插入顺序**，按照主键的顺序插入是最快的方式，否则将会出现页分裂的现象，严重影响性能。因此，对于Innodb表，我们一般都会定义一个**自增的ID列为主键**。
2. **更新主键的代价很高**，因为将会导致被更新的行移动。因此对于Innodb表，我们一般定义为**主键是不可更新的**。
3. **二级索引访问需要两次索引查找**，第一次找到主键，第二次根据主键值找到行数据



**限制：**

1. 对于MySQL数据库目前只有Innodb数据存储引擎支持聚簇索引，而MYISAM并不支持聚簇索引。
2. 由于数据物理存储排序方式只能有一个，所以每个MySQL的表只能有一个聚簇索引。一般情况下就是该表的主键。
3. 如果没有定义主键，Innodb会选择非空的唯一索引代替。如果没有这样的索引，innodb会隐式的定义一个主键来作为聚簇索引。
4. 为了充分利用聚簇索引的聚簇特性，所以Innodb表的主键列尽量选择有序的顺序id，而不建议用无序的id，比如UUID，MD5，HASH，字符串列作为主键而无法保证数据的顺序增长。



**2. 二级索引（辅助索引、非聚簇索引）**

聚簇索引只能在搜索条件是主键时才能发挥作用，因为B+树中的数据都是按照主键进行排序的。那如果我们想以别的列作为搜索条件该怎么办呢？肯定是不能从头到尾沿着链表遍历记录一遍。

答案：我们可以多建立几颗B+树，不同的B+树的数据采用不同的排列规则。比方说我们可以使用c2列的大小作为数据页，页中记录的排序规则，再建一棵B+树，效果如图所示：

![image-20231003232550416](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310032325494.png)

这个B+树与上面介绍的聚簇索引有几处不同：

- 使用记录c2列的大小进行记录和页的排序，这包括三个方面的含义：
  - 页内的记录是按照c2列的大小顺序排成一个**单向链表**
  - 各个存放**用户记录的项**也是根据页中记录c2列的大小顺序排成一个**双向链表**
  - 存放**目录项记录的页**分为不同的层次，在同一层次中的页也是根据页中目录项记录的c2列大小顺序排成一个**双向链表**
- B+树的叶子节点存储的并不是完整的用户记录，而是**c2+主键**这两个列的值
- 目录项记录中不再是**主键+页号**的搭配，而是**c2列+主键**的搭配。

如果查询c2=4，那么就会先查页42，由于c2列并没有唯一性约束，所以4既可能在页34中也可能在页35中，因此需要在两个数据页里面查。

**回表：**

我们根据这个以c2列排序的B+树只能确定我们要查找的记录的主键，如果想要查找完整的用户记录还需要到聚簇索引中再查一遍，这个过程就称为回表。也就是根据c2值查询一条完整的用户记录需要使用到2颗B+树。

**问题：**为什么我们还需要一次回表操作呢？直接把用户记录放到叶子节点不好吗？

如果我们把完整的用户记录方到叶子节点，那么我们是不用回表的。但是比较占空间，相当于每建立一颗B+树就得把所有需要的用户记录再拷贝一遍，太浪费存储空间。

因为这种按照非主键列建立的B+树需要一次回表操作才可以定位到完整的用户记录，所以这种B+树也被称为二级索引（英文名secondary index），或者辅助索引。由于我们使用的是c2列的大小作为B+树的排序规则，所以我们也称这个B+树是为c2建立的索引。

非聚簇索引的存在并不影响数据在聚簇索引中的组织，所以一张表可以有多个非聚簇索引。

![image-20231004100037017](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310041000092.png)

小结：聚簇索引与非聚簇索引的区别

1. 聚簇索引的叶子结点存储的就是完整的数据记录，非聚簇索引的叶子节点存储的就是数据位置。非聚簇索引不会影响数据表的物理存储顺序。
2. 一个表**只能有一个聚簇索引**，因为只能有一种排序存储的方式，但是可以有**多个非聚簇索引**，也就是多个索引目录提供数据检索。
3. 使用聚簇索引的时候，数据的查询效率高，但是对数据的插入，更新，删除等操作，效率会比非聚簇索引低。



**3. 联合索引**

我们也可以同时以多个列的大小作为排序顺序，也就是同时为多个列建立索引，比如说我们想让B+树按照c2和c3的大小进行排序，这个包含两层含义：

- 先把各个记录和页按照c2列进行排序
- 在记录的c2列相同的情况下，采用c3列进行排序

以c2和c3列的大小为排序规则建立的B+树称为**联合索引**，本质上也是一个二级索引。

- 建立**联合索引**只会建立如上图所示的一颗B+树
- 为c2和c3分别建立索引会分别以c2和c3列的大小为排序规则建立2颗B+树。

![image-20231004101449631](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310041014778.png)

注意：

- 每条目录项记录都由c2，c3，页号这三个部分组成，各条记录先按照c2列的值进行排序，如果c2列相同则按照c3进行顺序
- B+树的叶子结点处存储的是c2，c3和主键。



### 3.4 Innodb的B+树索引的注意事项

1. 根页面位置万年不动

   - 我们前面介绍的B+树索引的时候，为了大家理解上的方便，先把存储用户记录的叶子节点都画出来，然后接着画存储目录项记录的内节点，是以一种自下而上的方式展示的，而实际上B+树的形成过程是这样的：
   - 每当为某个表创建一个B+树索引（聚簇索引不是认为创建，而是默认）时，都会为这个索引创建一个**根节点**页面。最开始表中没有数据的时候，每个B+树索引对应的根节点中既没有用户记录，也没有目录项记录。
   - 随后向表中插入用户记录时，先把用户记录存储到这个**根节点**中。
   - 当根节点中的**可用空间完成时**继续插入记录，此时会将根节点中的所有记录复制到一个新分配的页。比如页a中，然后对这个新页进行页分裂操作，得到另一个新页，比如页b。这时新插入的记录根据键值（聚簇索引的主键值，二级索引的列值）的大小就会被分配到页a或者页b中，而根节点便升级为存储目录项记录的页。

   **注意**，一个B+树的根节点自诞生之日起，便不会再移动。这样我们只要对某个表建立了索引，那么它的根节点的页号便会被记录到某个地方，然后凡是Innodb存储引擎需要用到这个索引的时候，都会从那个固定的地方取出根节点的页号，从而来访问这个索引。

2. 内节点目录记录的唯一性

   ![image-20231004105153489](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310041051558.png)

   如果二级索引中目录项记录的内容只是**索引号+页号**的搭配的话，那么为c2建立索引后的B+树应该长这样：

   ![image-20231004105337466](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310041053527.png)

   如果我们想插入一行新记录，其中c1，c2，c3的值分别是：9、1、'c'，那么在这个为c2列建立的二级索引对应的B+树时便碰到了个大问题：由于页3中存储的目录项记录是由**c2列+页号**的值构成的，页3中的两条目录项记录对应的c2列的值都是1，而我扪新插入的这条记录的c2列的值也是1，那我们这条新记录应该插入到页4中，还是页5中。

   为了能保证让新插入的记录能够找到自己所在的那个页面，我们需要**保证在B+树的同一层内节点的目录项记录除页号这个字段以外是唯一的**，所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分组成：

   - 索引列的值
   - 主键值
   - 页号

   也就是我们把**主键值**也添加到二级索引内节点中的目录项记录了，这样就能保证B+树每一层节点中各条目录项记录除页号以外这个字段是唯一的，所以我们为二级索引建立的B+树应该是这个样子：

   ![image-20231004110153514](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310041101743.png)

3. 一个页面最少存储2条记录

   ![image-20231004111552408](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310041115496.png)



## 4 MyISAM的索引方案

![image-20231004111704192](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310041117273.png)

### 4.1 MyISAM索引的原理

我们知道Innodb中索引即数据，也就是聚簇索引的那棵B+树的叶子节点已经把所有完整的用户记录都包含了，而MyISAM的索引方案虽然也使用了树形结构，但是却将索引和数据分开存储：

- 将表中的记录按照记录的插入顺序单独存储在一个文件中，称之为数据文件。这个文件并不划分若干个数据页，有多少记录就往这个文件中塞多少记录就行。由于在插入数据的时候并没有刻意按照主键大小排序，所以我们并不能在这些数据上使用二分法进行查找。
- 使用MyISAM存储引擎会把索引信息存储到另一个称为索引文件的另一个文件中。MyISAM会单独为表的主键创建一个索引，只不过在索引的叶子节点中存储的并不是完整的用户记录，而是**主键值+数据记录地址**的组合。
- MYISAM是没有聚簇索引的，可以理解为二级索引

![image-20231004113057276](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310041131492.png)

这里设表一共有三列，假设我们以col1为主键，上图是一个MYISAM表的主索引（Primary key）示意图。可以看出，**MYISAM的索引文件仅仅保存数据记录的地址**。在MYISAM中，主键索引和二级索引（secondary index）在结构上是没有区别的，只是主键索引要求key是唯一的，而二级索引的key可以重复。如果我们在col2上建立一个二级索引，则索引的结构如下图所示：

![image-20231004113614094](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310041136152.png)

同样也是一颗B+树，data域保存数据记录的地址。因此，MYISAM中索引检索的算法为：首先按照B+树搜索算法搜索索引，如果指定的key存在，则取出其data域，然后以data域的值为地址，读取相应的数据记录。



### 4.2 MYISAM与Innodb的对比

1. 在Innodb存储引擎中，可以根据主键值进行聚簇索引一次性找到对应的记录，而在MYISAM中却需要进行一次回表操作，意味着MYISAM中建立的索引相当于全部都是二级索引。

2. Innodb的数据文件本身就是索引文件，而MYISAM索引文件和数据文件都是分离的，索引文件仅保存数据记录的地址。

3. Innodb的非聚簇索引的data域存储相应记录的**主键值**，而MYISAM索引文件记录的是数据地址，换句话说，Innodb的所有非聚簇索引都引用主键为data域。

4. ==MYISAM的回表操作是十分快速的，因为是拿着地址偏移量直接到文件中取数据，反观Innodb是通过获取主键之后再去聚簇索引里找记录，虽说也不慢，但是比不上直接用地址去访问。==

5. Innodb要求表**必须有主键**（MYISAM可以没有）。如果没有显示的指定，MySQL系统会自动选择一个非空且唯一标识数据记录的列作为主键。如果不存在这种列，则MySQL自动为Innodb表生成一个隐含字段作为主键，这个字段长度为6个字节，类型是长整型。

   ![image-20231004125435784](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310041254840.png)

**小结：**

1. 不建议使用过长的字段作为主键，因为所有的二级索引都引用主键索引，过长的主键索引会令二级索引变得更大。

2. 用非单调的字段作为主键在Innodb中并不是一个好主意，因为Innodb数据文件本身是一颗B+树，非单调主键会造成再插入新记录时，数据文件为了维持B+树的特性而频繁的分裂调整，十分低效，而使用自增字段为主键则是一个很好的选择。

   

## 5 索引的代价

索引是个好东西，但是也不能乱建，它在时间和空间上都会有消耗：

- 空间上的代价

  每建立一个索引都要为它建立一颗B+树，**每一颗B+树的每一个节点都是一个数据页**，一个也默认会占用16KB的存储空间，一棵很大的B+树由许多数据页组成，那就是很大的一片存储空间。

- 时间上的代价

  每次对表中的数据进行增删改操作时，都需要去修改各个B+树索引，而且我们讲过，B+树每层节点都是按照索引列的值从小到大顺序排列而组成**双向链表**。不论是叶子结点中的记录，还是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个**单向链表**。而增删改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些**记录移位，页面分裂，页面回收**等操作来维护好节点和记录的排序。如果我们建了许多索引，每个索引对应的B+树都要进行相关的维护工作，会给性能拖后腿。

> 一个表上索引建得越多，就会占用越多的存储空间，在增删改记录的时候性能就越差。为了能建立又少又好的索引，我们需要了解这些索引在哪些条件下起作用



## 6 MySQL数据结构选择的合理性

从MySQL的角度讲，不得不考虑一个问题就是磁盘IO。如果能够让索引的数据结构尽量减少磁盘的IO次数，所消耗的时间也就越小。可以说，**磁盘IO操作次数对索引的使用效率至关重要**。

查找都是索引操作，一般来说，索引非常大，尤其是关系型数据库，当数据量比较大时，索引的大小有可能几个G，为了减少索引在内存中的占用，**数据库索引是存储在外存上的**。当我们利用索引进行查询的时候，不可能把所有的索引全部加载到内存中，只能逐一加载，MySQL衡量查询效率的标准就是磁盘吧IO次数。

### 6.1 全表扫描

### 6.2 Hash结构

Hash本身是一个函数，又称为散列函数，他可以帮助我们大幅度提升数据的检索效率。

Hash算法是通过某种不确定性的算法（比如MD5，SHA1，SHA2，SHA3）将输入变为输出。相同的输入永远可以得到相同的输出，假设输入内容有微小差别，在输出中通常会有不同的结果。

举例：如果你想验证两个文件是否相同，那你可以比较这个文件的hash值，相同即说明是一样的，不相等就是不一样的，完全不用比较文件的内容。

**加速查找速度的数据结构，常见的有两类：**

（1）树，例如平衡二叉树，查询/插入/修改/删除的平均时间复杂度都是O(log2n)

（2）哈希，例如HashMap，查询/插入/修改/删除的平均时间复杂度都是O(1)

![image-20231004141012733](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310041410822.png)

采用Hash进行检索的效率非常高，基本上一次检索就可以找到数据，而B+树需要自顶向下依次查找，多次访问节点才能找到数据，中间需要多次IO操作，从效率来说Hash比B+树更快。

在哈希的方式下，一个元素k处于h(k)下，即利用哈希函数h，根据关键字k计算出槽的位置。函数h将关键字域映射到哈希表T[0...m-1]的槽位上。

![image-20231004141427403](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310041414466.png)

上图中哈希函数h有可能将两个不同的关键字映射到相同的位置，这叫做哈希碰撞，在数据库中一般采用**链接法**来解决。在链接法中，将散列到同一槽位的元素放在一个链表中，如下图所示：

![image-20231004142512750](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310041425476.png)

![image-20231004142839472](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310041428555.png)

**Hash结构效率高，那为什么索引结构要设计成树形呢？**

原因1：Hash索引仅能满足（=） （<>）和in查询。如果进行**范围查找**，**哈希型**的索引，时间复杂度回退化为O(n)；而树形的**有序**特性，依然能够保持O(log2N)的高效率

原因2：Hash索引还有一个缺陷，数据的存储是没有顺序的，在order by 的情况下，使用Hash索引还需要对数据进行重新排序。

原因3：对于联合索引的情况，Hash值是将联合索引合并后一起来计算的，无法对单独的一个键或者几个索引键进行查询。

原因4：对于等值查询来说，通常Hash索引的效率更高，不过也存在一种情况，就是索引列的重复值如果很多，效率就会降低。这是因为遇到Hash冲突时，需要遍历桶中的行指针来进行比较，找到查询的关键字，非常耗时，所以，Hash索引通常不会用到重复值多的列上，比如列为性别，年龄的情况。

![image-20231004154724830](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310041547881.png)

![image-20231004154746660](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310041547719.png)

Hash存在着很多的限制，相比之下在数据库中B+树索引的适用面会更广，不过也有一些场景采用Hash索引效率更高，比如在键值型数据库中，redis的核心就是hash表。

MySQL中的memory存储引擎支持Hash存储，如果我们需要用到查询的临时表时，就可以选择memory存储引擎，把某个字段设置为Hash索引，比如字符串类型的字段，进行Hash计算之后长度可以缩短到几个字节，当字段的重复度低，而且经常需要进行**等值查询**时，采用Hash索引是一个不错的选择。

另外，Innodb本身不支持Hash索引，但是提供了自适应Hash索引（Adaptive Hash Index）。什么情况下才会使用自适应Hash索引呢？如果某个数据经常被访问，当满足一定条件的时候，就会将这个数据页的地址存放到Hash表中。这样下次查询的时候，就可以直接找到这个页面所在的位置。这样B+树也就具备了Hash索引的优点。

采用**自适应Hash索引**的目的是==方便根据SQL的查询条件加速定位到叶子节点，特别是当B+树比较深的时候，通过自适应Hash索引可以明显提高数据的检索效率。==

我们可以通过innodb_adaptive_hash_index变量来查看是否开启了自适应Hash，比如：

```MySQL
show variables like '%adaptive_hash_index%';
```

![image-20231004165109593](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310041652386.png)



### 6.3 二叉搜索树

如果我们使用二叉搜索树作为索引结构，那么磁盘的IO次数和索引树的高度是相关的。

**1. 二叉搜索树的特点**

- 一个节点只能有两个子节点，也就是一个节点的度不能超过2
- 左子节点<本节点；右子节点>本节点

**2. 查找规则**

- 如果key大于根节点，则在右子树查找
- 如果key小于根节点，则在左子树查找
- 如果等于key，返回节点

![image-20231004165450830](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310041654908.png)



### 6.4 AVL树

为了解决二叉树退化成链表的问题，人们提出了平衡二叉树，又称为AVL树（有别于AVL算法），它在二叉树的基础上增加了约束，具体性质如下：

**它是一颗空树或它的左右子树的高度差的绝对值不超过1，并且左右子树都是一颗平衡二叉树。**

常见的平衡二叉树有很多种，包括常见的**平衡二叉搜索树**，**红黑树**，**数堆**，**伸展树**。平衡二叉搜索树是最早提出来的自平衡二叉搜索树，当我们提到平衡二叉树时一般指的就是平衡二叉搜索树。事实上，第一棵树就是平衡二叉搜索树，搜索时间复杂度为O(log2n)。

数据查询的时间主要依赖与磁盘IO的次数，如果我们使用二叉树的形式，即使通过平衡二叉搜索树进项了改进，树的深度也是O(log2N)，当n比较大时，深度也是比较高的，比如下图：

![image-20231004170321082](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310041703633.png)

**每访问一次节点就需要进行一次IO操作**，对于上面的树来说，我们需要进行5次IO操作。虽然平衡二叉树的效率高，但是树的深度同样也高，这就意味的IO次数很多，会影响整体数据查询的效率。

针对上面的问题，如果把二叉树变成M叉树（M>2）呢？当M=3时，同样的31个节点由下面的三叉树构成：

![image-20231004170632055](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310041706103.png)

可见，IO次数变为4次。因此我们需要把树**从瘦高变成矮胖**。



### 6.5 B-Tree

B树的结构如下：

![image-20231004170830716](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310041708793.png)

一个M阶的B树（M>2）有以下特性：

- 根节点的儿子树的范围[2, M]。
- 每个中间结点包含k-1个关键字和k个孩子，孩子的数量=关键字的数量+1，k的取值范围为[ceil(M/2), M]
- 叶子结点包含k-1个关键字（叶子结点没有孩子），k的取值范围为[ceil(M/2), M]。
- 假设中间结点的关键字为：key[1], key[2], ..., key[k-1]，且关键字按照升序排序，即key[i]<key[i+1]。此时k-1个关键字相当于划分了k个范围，也就是对应k个指针，即为：P[1], P[2], ..., P[k]，其中P[1]指向关键字小于key[1]的子树，P[i]指向关键字属于key[i-1], key[i] 的子树，P[k]指向指向关键字大于key[k-1]的子树。
- 所有叶子节点位于同一层

![image-20231004171732009](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310041717061.png)

假设我们想查找关键字9，那么步骤可以分为以下几步：

- 与根节点关键字（17,35）进行比较，9小于17那么得到指针P1；
- 按照指针P1找到磁盘块2，关键字为（8,12），因为9位于8和12之间，所以得到指针P2；
- 按照指针P2找到磁盘块6，关键字为（9,10），然后我们找到了关键字

![image-20231004172035358](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310041720414.png)

**小结：**

- B树在插入和删除的时候如果导致树不平衡，就通过自动调节节点的位置来保持树的自平衡
- 关键字集合分布在整棵树中，即叶子结点和非叶子节点都存放数据。搜索有可能在非叶子节点结束。
- 其搜索性能等价于在关键字全集内做一次二分查找

再举一个例子：

![image-20231004190224464](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310041902535.png)

### 6.6 B+Tree

![image-20231004190312757](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310041903815.png)

**B+树和B树的区别**：

1. 有k个孩子节点就有k个关键字，也就是孩子节点数=关键字数；而在B树中，孩子数=关键字数+1
2. 非叶子节点的关键字也会同时存在与叶子结点中，并且是在子节点所有关键字的最大（或最小）。
3. 非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子结点上。而B树中，非叶子节点即保存索引也保存数据记录。
4. 所有关键字都在叶子节点出现，叶子节点构成了一个有序链表，而叶子节点本身按照关键字的大小从小到大进行排序。

> B树和B+树都可以作为索引的数据结构，在MySQL中采用的是B+树。
>
> 但是B+树和B树都有自己的应用场景，不能说B+树就一定比B树好。

思考题：**B+树的中间结点并不存储数据，这样有什么好处？**

- **B+树查询效率更稳定**。因为B+树每次需要访问到叶子节点才能访问到具体的用户记录。而在B树中，非叶子节点也存储数据，这样就导致了B树的查询效率不稳定，有的时候在树内部就访问到了节点也有可能到了叶子节点才访问到具体的数据。
- **B+树查询效率更高**。这是因为B+树比B树更加的矮胖（阶数更大，深度更低），查询所需要的磁盘IO越少。同样的磁盘页大小，B+树可以存储更多的节点关键字。
- **在查询范围上，B+树的效率也比B树高**。这是因为所有的关键字都出现B+树的叶子节点上，叶子节点之间有指针，数据又是递增的，这就使得我们在范围查询的时候可以通过指针连接查询。而在B树中则需要通过中序遍历才能完成范围查询的任务，效率要低很多。



思考题：**为了减少IO，索引树会一次性加载吗？**

不会。数据库索引是存储在磁盘上的，如果数据量很大的话，必然导致索引的大小也很大，超过几个G。

当我们利用索引查询数据的时候，是不可能将全部几个G的索引都加载到内存，我们能做就是：逐一加载每一个磁盘页，因为磁盘页对应着索引树的节点。



思考题：**B+树的存储能力如何？为何说一般查找行记录，最多只需要1~3次磁盘IO？**

Innodb存储引擎中页的大小一般是16KB，一般表的主键类型为int类型（占用4个字节）或bigint（占用8个字节），指针类型也一般为4个或8个字节，也就是说一个页（B+树中的一个页）中大概存储16KB/(8B+8B)=1K个键值（为了方便计算，这里取K=10^3），也就是说，一个深度为3的B+树可以存储10^3 * 10^3 * 10^3 = 10^9条记录。（这里假设一个数据也存储10^3条记录数据）。

实际上每个节点可能不能填充满，因此在数据库中，B+树的高度一般在2~4层。MySQL的Innodb存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘IO。



思考题：**为什么说B+树比B树更适合实际应用中操作系统的文件索引和数据库索引？**

1. B+树的读写代价更低

   B+树内部节点并没有指向关键字具体信息的指针。因此其内部节点比B树更小，如果把所有同一内部节点的关键字放在用一块磁盘上，那么B+树所能容纳的关键字的数量也越多，一次性读入内存的关键字数量也就越多，相对来说磁盘IO的读写次数也就越低

2. B+树的查询效率更稳定

   由于非终结点并不是指向文件内容的节点，而只是叶子节点中关键字的索引。索引任何关键字的查找都必须走一条从根到叶子节点的路径。所有的关键字的查询路径是相同的，导致每一个关键字的查询效率相当。



思考题：**hash索引与B+树索引的区别？**

1. Hash**不支持范围查找**，但B+树可以。这是因为Hash索引指向的数据是无序的，而B+树的叶子节点是个有序的链表。
2. Hash索引**不支持联合索引的最左侧原则**（即联合索引的部分索引无法使用），而B+树可以。对于联合索引来说，Hash索引在计算Hash值的时候是将索引建合并后再一起计算Hash值，所以不会针对每个索引单独计算Hash值。因此用到联合索引的一个或几个索引时，联合索引无法被利用。
3. Hash索引**不支持Order by排序**，因为Hash索引指向的数据是无序的，因此无法起到排序优化的作用，而B+树索引排序是有序的，可以起到对该字段Order by排序优化的作用。同理了，我们也无法使用Hash索引进行**模糊查询**，而B+树使用like进行模糊查询的时候，like后面后模糊查询（比如%结尾）的话就可以起到优化的作用。
4. **Innodb不支持哈希索引**



思考题：**Hash索引与B+树索引是在建索引的时候手动指定吗？**

![image-20231004200937482](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310042009544.png)

针对Innodb和MYISAM存储引擎，都会默认采用B+树索引，无法使用Hash索引。Innodb提供自适应Hash是不需要手动指定的。如果是Memory/Heap 和 NDB存储引擎，是可以进行选择Hash索引的。



### 6.7 R树

![image-20231004201022099](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310042010176.png)