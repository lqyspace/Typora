[TOC]

# 04-逻辑架构

## 1. 逻辑架构剖析

### 1.1 服务器处理客户端请求

![image-20231001135323040](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310011353102.png)

具体展开：

![image-20231001135428680](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310011354741.png)



### 1.2 连接层

系统（客户端）访问MySQL服务器之前，做的第一件事就是建立TCP连接。

经过三次握手建立连接成功后，MySQL服务器对TCP传输过来的账号密码做身份认证，权限获取。

- 用户名或密码不对，会收到一个Access denied for user错误，客户端程序结束执行。
- 用户名密码认证通过，会从权限表处查询账号拥有的权限与连接关联，之后的权限判断都依赖于此时读取到的权限。

TCP连接收到请求后，必须要分配给一个线程专门与这个客户端进行交互。所以还会有一个线程池，去走后面的流程，每一个连接从线程池中获取线程，省去了创建和销毁线程的开销。



### 1.3 服务层

- SQL Interface：SQL接口

  - 接受用户的SQL命令，并且返回用户需要查询的结果。比如select...from就是调用SQL Interface
  - MySQL支持DML（数据操作语言），DDL（数据定义语言），存储过程，视图，触发器，自定义函数等多种SQL语言接口。

- Parser：解析器

  - 在解析器中对SQL语句进行词法分析，语法分析。将SQL语句分解成数据结构，并将这个数据结构传递到后续的步骤，以后SQL语句的传递和处理就是基于这个数据结构的。如果在分解构成中遇到错误，那么就说明这个SQL语句是不合理的。
  - 在SQL命令传递到解析器的时候会被解析器验证和解析，并为其创建==语法树==，并根据数据字典丰富查询语法树，会 ==验证客户端是否具有执行该查询的权限==。创建好语法树后，MySQL还会对SQL查询进行==语法上的优化==，进行==查询重写==。

- Optimizer：查询优化器

  - SQL语句在语法解析之后，查询之前会使用查询优化器确定SQL语句的执行路径，生成一个==执行计划==。

  - 这个==执行计划==表明应该使用哪些索引进行查询（全表检索还是索引检索），表之间的连接顺序如何，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将查询结果返回给用户。

  - 它使用 ==选取-投影-连接== 策略进行查询。例如：

    ```MySQL
    select id, name from student where gender = '女';
    ```

    这个select查询先根据where语句进行==选取==，而不是将表全部查询出来以后再进行gender过滤。然后根据id和name进行属性==投影==，而不是将属性全部取出来以后再进行过滤，最后将这两个查询条件==连接==起来生成最终查询结果。

- Cache & Buffer：查询缓存组件

  - MySQL内部维持着一些Cache和Buffer，比如Query Cache用来缓存一条select语句的执行结果，如果能够在其中找到对应的查询结果，那么就不必再进行查询解析，优化和执行的整个过程，直接将结果返回给客户端。
  - 这个缓存机制是由一系列小缓存组成的，比如表缓存，记录缓存，key缓存，权限缓存等。
  - 这个查询缓存可以在==不同客户端之间共享==。
  - 从MySQL5.7.20开始，不推荐使用查询缓存，并在MySQL8.0中删除



### 1.4 引擎层

插件式存储引擎（Storage Engines），==真正的负责了MySQL数据的存储和提取。对物理服务器级别维护的底层数据执行操作==，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。

![image-20231002014141029](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310020141079.png)



### 1.5 存储层

![image-20231002014239569](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310020142617.png)



### 1.6 小结

![image-20231002014328978](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310020143026.png)

简化为三层结构：

- 连接层客户端和服务端建立连接，客户端发送SQL至服务端；
- SQL层（服务层）：对SQL语句进行查询处理；与数据库文件的存储方式无关；
- 存储引擎层：与数据库文件打交道，负责数据的存储和读取。



## 2. SQL执行流程

### 2.1 语法顺序

![image-20231001165417298](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310011654353.png)



### 2.2 执行顺序

![image-20231001131442754](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310011314827.png)

**MySQL的查询流程**：

**1. 查询缓存：**server如果在查询缓存中发现了这条SQL语句，就会直接将结果返回给客户端；如果没有，就进入解析器阶段。需要说明的是，因为查询缓存往往效率不高，==所以在MySQL8.0以后就抛弃了这个功能。==

**大多数情况查询缓存就是个鸡肋，为什么呢？**

查询就是提前把查询结果缓存起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在MySQL的查询缓存，不是缓存查询计划，而是缓存对应的结果。这就意味着**查询匹配的鲁棒性大大降低**，只有**相同的查询操作才会命中查询缓存**。两个查询请求在在任何字符上的不同（例如空格，注释，大小写等）都会导致缓存不会命中。因此MySQL的查询缓存的命中率不高。

同时查询请求中包含某些系统函数，用户自定义变量和函数，一些系统表，如MySQL、information_schema、performance_schema数据库中的表，那这个请求就不会缓存。

以某些系统函数举例，可能同样的函数两次调用会产生不一样的结果，比如函数`NOW`，每次调用都会产生最新的时间，即使缓存了第一次的查询结果，第二次相同的请求信息如果返回还是相同的查询结果的话那么就是错的。

此外，既然是缓存，那么就有缓存失效的时候。MySQL的缓存系统会监测涉及到的每张表，只要该表的结构或者数据被修改，如对该表使用了insert，update，delete，truncate table，alter table，drop table或drop database语句，那使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除！对于更新压力大的数据库来说，查询缓存的命中率会非常低。

**总之，因为查询缓存往往弊大于利，查询缓存的失效非常频繁。**

一般建议大家在静态表里使用查询缓存，什么是静态表呢？就是一般我们极少更新的表。比如，一个系统配置表，字典表，这张表上的查询才适合查询缓存。好在MySQL提供了“按需使用”的方式，可以在my.cnf参数query_cache_type设置成demand，代表当SQL语句中有sql_cache关键词时才缓存。比如：

```MySQL
# query_cache_type有三个值  0代表关闭查询缓存OFF，1代表开启ON，2（DEMAND）
query_cache_type=2
```

这样对于默认的SQL语句不会使用查询缓存。而对于你确定要使用查询缓存的语句，可以使用sql_cache显示指定，像下面这个语句一样：

```MySQL
select sql_cache * from test where ID=5;
```

查看当前MySQL实例是否开启了缓存机制：

```MySQL
# 5.7
mysql> show global variables like '%query_cache_type%';
```

![image-20231001155010891](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310011550937.png)

```mysql
# 8.0
mysql> show global variables like '%query_cache_type%';
Empty set (0.02 sec)
```

查询缓存的命中率：

```MySQL
# 5.7
mysql> show status like '%Qcache%';
```

![image-20231001155305798](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310011553836.png)

`Qcache_free_blocks`: 查询缓存中碎片的个数；

`Qcache_free_memory`：空间的利用率越低

`Qcache_lowmem_prunes`：表示有多少查询是因为内存不足而移除掉的

`Qcache_queries_in_cache`：表示当前缓存中查询的数量



**2. 解析器：**在解析器中对SQL语句进行语法分析，语义分析

![image-20231001143434949](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310011434011.png)

**分析器**先做词法分析。你输入的是由多个字符串和空格组成的一条SQL语句。**MySQL需要识别出里面的字符串分别是什么，代表什么**。MySQL从你输入的select这个关键字识别出来，这是一个查询语句。他也要把字符串T识别成表名T，把字符串ID识别成列ID。

接着，要做**语法分析**。根据词法分析的结果，语法分析器（比如：Bison）会根据语法规则。判断你输入的这个SQL语句是否满足MySQL语法。

```MySQL
select department_id, job_id, avg(salary) from employees group by department_id;
```

如果SQL语句正确，则会生成这样的一个语法树：

![image-20231001144502019](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310011445085.png)

**3. 优化器：**在优化器中会确定SQL语句的执行路径，比如是根据 **全表检索** 还是根据 **索引检索** 等。

![image-20231001144741984](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310011447028.png)

在查询优化器中，可以分为 `逻辑查询` 优化阶段和 `物理查询` 优化阶段。

- 物理查询优化：通过`索引`和`表连接方式`等技术进行优化，这里重点需要掌握索引的使用。
- 逻辑查询优化：通过SQL等价变换提升查询效率，直白一点就是说，换一种查询写法执行效率可能更高。

**4. 执行器：**

截止到现在，还没有真正去读写一个真实的表，仅仅只是产出一个执行计划。接下来就进入了 `执行器阶段`。

![image-20231001145019009](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310011450072.png)

在执行之前，需要判断该用户是否具备执行权限。如果没有，就会返回权限错误。如果具备权限，就执行SQL语句并返回结果。在MySQL8.0以下的版本如果设置了查询缓存，这时会将查询结果进行缓存。

```MySQL
select * from test where id=1;
```

比如：表test中，id字段没有索引，那么执行器的执行流程是这样的：

> 调用Innodb引擎接口去这个表的第一行，判断id是不是1，如果不是则跳过，如果是则将这行存在结果集中；调用引擎接口取“下一行”，重复相同的判断逻辑，直到去这个表的最后一行。
>
> 执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。
>
> 以上过程是“全表检索”

至此，这个语句就执行完成了。对于有索引的表，执行的逻辑差不多。

SQL语句在MySQL的执行流程是：SQL语句——>查询缓存——>解析器——>优化器——>执行器。

![image-20231001153601185](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310011536235.png)



## 3 MySQL8中SQL执行原理

既然一条SQL语句会经历不同的模块，那么我们来看下，在不同的模块里，SQL所使用的资源情况如何。如何在MySQL中对一条SQL语句的执行时间进行分析。

### 3.1 确认profiling是否开启

```MySQL
mysql> select @@profiling;

mysql> select variables like 'profiling';
```

![image-20231001162255532](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310011622574.png)

profiling=0代表关闭，我们需要把profiling打开，即设置为1：

```MySQL
mysql> set profiling=1;
```

### 3.2 多次指向相同的SQL查询

然后我们执行一个SQL查询：

```MySQL
mysql> select * from employees;
```

### 3.3 查看profiles

查看当前会话所产生的所有profiles：

```MySQL
mysql> show profiles; # 显示最近几次查询
```

![image-20231001162617825](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310011626883.png)

### 3.4 查看profile

显示执行计划，查看程序的执行步骤：

```MySQL
mysql> show profile;
```

![image-20231001162918782](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310011629835.png)

当然你也可以指定Query ID，比如：

```MySQL
mysql> show profile for query 7;
```

查询SQL的执行时间结果和上面是一样的。

此外，还可以查询更丰富的内容：

```MySQL
mysql> show profile cpu, block io for query 6;
```

![image-20231001163240395](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310011632447.png)



## 4 MySQL5.7中SQL执行原理

在MySQL5.7中我们需要显示开启查询缓存模式。

### 4.1 配置文件中开启查询缓存

在/etc/my.cng中新增一行：

```MySQL
query_cache_type=1
```

### 4.2 重启MySQL服务

```MySQL
systemctl restart mysqld
```

### 4.3 开启查询执行计划

由于重启过服务，需要重新执行如下的指令，开启profiling。

```MySQL
mysql> set profiling=1;
```

### 4.4 执行两次sql

```MySQL
mysql> select * from locations;

mysql> select * from locations;
```

### 4.5 查看profiles

```MySQL
mysql> show profiles;
```

![image-20231001164024899](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310011640940.png)

### 4.6 查看profile

```MySQL
mysql> show profile for query 1;
```

![image-20231001164117600](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310011641662.png)

```mysql
mysql> show profile for query 2;
```

![image-20231001164158207](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310011641252.png)

执行的是相同的SQL语句，但是能够看出执行编号2时比执行编号1少了很多信息，从截图中可以看出查询语句直接从缓存中获取数据。



## 5 数据库缓冲池（buffer pool）

Innodb是以页为单位来管理存储空间的，我们进行的增删改查操作本质上都是在访问页面（包括读页面，写页面，创建新页面等操作）。而磁盘IO需要消耗的时间很多，但是在内存中操作，则效率会很高，为了能让数据表或者索引中的数据随时被我们使用，DBMS会申请占用内存作为数据缓冲池，在真正访问页面之前，需要把磁盘上的页缓存到内存中的Buffer Pool之后才可以访问。

这样的好处减少了磁盘IO的访存次数，节省了访存时间。这种策略对于提升SQL语句的查询性能是至关重要的，如果索引的数据在缓冲池里，那么访问的成本就会降低很多。



### 5.1 缓冲池 vs 查询缓存

**==缓冲池和查询缓存不是一个东西==**。

> **缓冲池（Buffer Pool）**

在Innodb存储引擎中有一部分数据会放到内存中，缓冲池则占了这部分内存的大部分，它用来存储各种数据的缓存，如下图所示：

![image-20231001212100485](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310012121550.png)

从图中，我们可以看出Innodb缓冲池包括数据页，索引页，插入缓冲，锁信息，自适应索引hash和数据字典信息等。

**缓存池的重要性：**

**缓存原则：**

“位置 * 频次” 这个原则，可以帮助我们对IO访问效率进行优化。

首先，**位置**决定效率，提供缓冲池就是为了在**内存**中可以直接访问数据。

其次，频次决定优先级的顺序。因为缓冲池的大小是有限制的，比如磁盘大小200G，但是内存16G，缓冲池大小只有1G，就无法将所有数据都加载到缓冲池里，这时就涉及到优先级顺序，会**优先使用频次高的热数据进行加载**。

**缓冲池的预读特性：**

缓冲池的作用就是为了提升IO效率，而我们进行读取数据的时候存在一个局部性原理，也就是说我们使用了一些数据，**大概还会使用它周围的一些数据**，因此采用“预读”的机制提前加载，可以减少未来可能的磁盘IO操作。



> **查询缓存**

提前把查询结果缓存起来，这样下次不需要执行就可以直接拿结果。在MySQL的查询缓存里，不是缓存查询计划，而是查询的对应的结果。因为命中条件苛刻，而且只要数据表发生变化，查询缓存就会失效，因此命中率低。



### 5.2 缓冲池如何读取数据

缓冲池管理器会尽量将经常使用的数据保存起来，在数据库进行页面读操作的时候，首先会判断该页面是否在缓冲池中，如果存在就直接读取，如果不存在，就会通过内存或者磁盘将页面存放到缓冲池中在进行读取。

缓存在数据库中的结构和作用如下图所示：

![image-20231001220546275](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310012205326.png)

**如果执行SQL语句的时候更新了缓冲池中的数据，那么这些数据会马上同步到磁盘上吗？**

实际上，当我们对数据库中记录进行修改数据时，首先会修改缓冲池中页里面的记录信息，然后数据库会以`一定的频率刷新`到磁盘上。注意并不是每次发生更新操作，都会立刻进行磁盘会写。缓冲池会采用一种叫做 `checkpoint` 的机制将数据回写到磁盘上，这样做的好处就是提升了数据库的整体性能。

比如，当 `缓冲池`不够用时，需要释放掉一些不常用的页，此时就可以强行采用 `checkpoint` 的方式，将==不常用的脏页==回写到磁盘上，然后再从缓冲池中将这些页释放掉。==这里的脏页指的是缓冲池中被修改过的页，与磁盘上的数据页不一致。==



### 5.3 查看/设置缓冲池大小

如果你是用的是Innodb存储引擎，可以通过查看 `innodb_buffer_pool_size` 变量来查看缓冲池的大小。命令如下：

```MySQL
show variables like 'innodb_buffer_pool_size';
```

![image-20231001221852088](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310020043973.png)

我们可以看出Innodb的缓冲池的大小为134217728/1024/1024=128MB。我们可以修改缓冲池的大小，比如改为256MB，方法名如下：

```MySQL
set global innodb_buffer_pool_size = 268435456;
```

![image-20231002004922727](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310020049777.png)

或者：

```MySQL
[server]
innodb_buffer_pool_size = 268435456
```

然后再来看修改后的缓冲池的大小，此时已经成功修改成256M；

![image-20231002005122197](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310020051235.png)

### 5.4 多个Buffer Pool实例

```MySQL
[server]
innodb_buffer_pool_instances = 2;
```

这样就表明我们要创建两个buffer pool实例。

我们看下如何设置缓冲池的个数，使用命令：

```MySQL
show variables like 'innodb_buffer_pool_instances';
```

![image-20231002005443565](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310020054609.png)

那每个Buffer Pool实例实际占多少内存空间呢？其实使用这个公式就可以算出来：

```MySQL
innodb_buffer_pool_size/innodb_buffer_pool_instances
```

也就是说总共的大小除以实例的个数，结果就是每个实例的大小。



### 5.5 引申问题

Buffer Pool是MySQL内存结构中十分必要的一个组成，你可以把他想象成一个黑盒子。

**黑盒下的更新数据流程：**

![image-20231002005936375](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310020059432.png)

更新到一半突然发生了错误，如何回滚到更新之前的版本？

答案：Redo Log  &  Undo Log