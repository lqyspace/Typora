# 索引篇

## count(*)与count(具体字段)效率

问：在MySQL中统计数据表的行数可以使用三种方式：`count(*)`，`count(1)`和`count(具体字段)`，使用这三者之间的查询效率是怎么样的？

答：

在MySQL innodb的存储引擎中，count(*)，count(1)都是对所有结果进行count。如果有where子句，则是对符合筛选条件的数据进行统计；如果没有where子句，则是对数据表的数据行数进行统计。

因此count(*)和count(1)本质上并没有区别，执行的复杂度是O(N)，也就是采用全表扫描，进行循环+计数的方式进行统计。

如果MySQL MyISAM存储引擎，统计数据表的行数只需要O(1)的复杂度，这是因为每张MyISAM数据表都有一个meta信息存储了row_count值，而一致性则有表级锁来保证。因为Innodb支持事务，采用行级锁和MVCC机制，所以无法像MyISAM一样，只维护一个row_count变量，因此需要采用==全表扫描，进行循环+计数==的方式来完成统计。

需要注意的是，在实际执行过程中，count(*)和count(1)的执行时间可能略有差别，不过你还是可以把他两的执行效率看成是相等的。

另外在Innodb引擎中，如果采用count(*)和count(1)来统计数据行数，要尽量采用二级索引。因为主键采用的索引是聚簇索引，聚簇索引包含的信息多，明显会大于二级索引（非聚簇索引）。==对于`count(*)`和count(1)来说，他们不需要查找具体的行，只是统计行数，系统会自动采用占用空间更小的二级索引来进行统计。==

然而如果想要查找具体的行，那么采用主键索引的查询效率更高。如果有多个二级索引，会使用`key_len`小的二级索引进行扫描，当没有二级索引的时候，才会采用主键索引来进行统计。

总结：

- 一般情况下，三者的执行效率为：count(*)=count(1)>count(字段)。我们尽量使用`count(*)`，当然如果你要统计的是某个字段的非空数据行数，则另当别论，毕竟比较执行效率的前提是结果一样才行。
- 如果你要统计count(*)尽量在数据表上建立二级索引，系统会自动采用key_len小的二级索引进行扫描，这样当我们使用`select count(*)`的时候效率才会提升，有时候可以提升几倍甚至更高。

