### 第10章 索引优化与查询优化

#### 0. 概述

都有哪些维度可进行数据库调优？简言之：

- 索引失效，没有充分利用到索引——索引建立
- 关联查询太多join（设计缺陷或不得已的需求）——SQL优化（`一般最好不要超过三张表`）
- 服务器调优或各个参数设置（缓冲，线程池等）——调整my.cnf
- 数据过多——分库分表

虽然SQL查询优化的技术很多，但是大方向上完全可以分为`物理查询优化`和`逻辑查询优化`两大块。

- 物理查询优化是通过`索引`和`表连接方式`等技术来进行优化，这里重点需要掌握`索引的使用`。
- 逻辑查询优化是通过`SQL等价交换`提升查询效率，直白一点就是，换一种查询写法执行效率可能更高。

**数据准备**

> 步骤1：建表

```MySQL
CREATE TABLE `class` (
`id` INT(11) NOT NULL AUTO_INCREMENT,
`className` VARCHAR(30) DEFAULT NULL,
`address` VARCHAR(40) DEFAULT NULL,
`monitor` INT NULL,
PRIMARY KEY (`id`)
) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;

CREATE TABLE `student` (
`id` INT(11) NOT NULL AUTO_INCREMENT,
`stuno` INT NOT NULL ,
`name` VARCHAR(20) DEFAULT NULL,
`age` INT(3) DEFAULT NULL,
`classId` INT(11) DEFAULT NULL,
PRIMARY KEY (`id`)
#CONSTRAINT `fk_class_id` FOREIGN KEY (`classId`) REFERENCES `t_class` (`id`)
) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;
```

> 步骤2：设置参数

命令开启：允许创建函数设置

```MySQL
set global log_bin_trust_function_creators=1;  # 不加global只是当前窗口有效
```

> 步骤3：创建函数

保证每跳数据都不同。

```MySQL
# 随机产生字符串
delimiter //
create function rand_string(n Int) returns varchar(255)
begin
declare chars_str varchar(100) default 'abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ';
declare return_str varchar(255) default '';
declare i int default 0;
while i<n do
	set return_str = concat(return_str, substring(chars_str, floor(1+rand()*52), 1));
	set i = i+1;
end while;
return return_str;
end //
delimiter ;

# 随机产生班级编号
delimiter //
create function rand_num(from_num int, to_num int) returns int(11)
begin
declare i int default 0;
set i = floor(from_num + rand() * (to_num - from_num + 1));
return i;
end //
delimiter ;


# 创建存储过程
delimiter //
create procedure insert_stu(start int, max_num int)
begin
declare i int default 0;
set autocommit = 0;

repeat
set i = i+1;
insert into student(stuno, name, age, classId) values ((start+i), rand_string(6), rand_num(1, 50), rand_num(1,1000));
until i = max_num
end repeat;

commit;

end //
delimiter ;


# 创建存储过程
delimiter //
create procedure insert_class(max_num int)
begin
declare i int default 0;
set autocommit = 0;
repeat
set i = i+1;
insert into class(classname, address, monitor) values(rand_string(8), rand_string(10), rand_num(1, 100000));
until i = max_num
end repeat;

commit;
end //
delimiter ;

# 调用
call insert_class(100000);
call insert_stu(100000, 500000);

# 删除某表上的索引
DELIMITER //
CREATE PROCEDURE `proc_drop_index`(dbname VARCHAR(200),tablename VARCHAR(200))
BEGIN
    DECLARE done INT DEFAULT 0;
    DECLARE ct INT DEFAULT 0;
    DECLARE _index VARCHAR(200) DEFAULT '';
    DECLARE _cur CURSOR FOR SELECT index_name FROM
information_schema.STATISTICS WHERE table_schema=dbname AND table_name=tablename AND
seq_in_index=1 AND index_name <>'PRIMARY' ;
#每个游标必须使用不同的declare continue handler for not found set done=1来控制游标的结束
    DECLARE CONTINUE HANDLER FOR NOT FOUND set done=2 ;
    #若没有数据返回,程序继续,并将变量done设为2
    OPEN _cur;
    FETCH _cur INTO _index;
    WHILE _index<>'' DO
        SET @str = CONCAT("drop index " , _index , " on " , tablename );
        PREPARE sql_str FROM @str ;
        EXECUTE sql_str;
        DEALLOCATE PREPARE sql_str;
        SET _index='';
        FETCH _cur INTO _index;
	END WHILE;
CLOSE _cur;
END //
DELIMITER ;
# 调用
call proc_drop_index('dbname', 'tablename');
```



#### **1.** **索引失效案例**

MySQL中`提高性能`的一个最有效的方式是对数据表`设计合理的索引`。索引提供了访问高效数据的方法，并且加快查询的速度，因此索引对查询的速度有着至关重要的影响。

- 使用索引可以`快速地定位`表中的某条记录，从而提高数据库查询的速度，提高数据库的性能。
- 如果查询时没有使用索引，查询语句就会`扫描表中的所有记录`。在数据量大的情况下，这样查询的速度会很慢。

大多数情况下都（默认）采用`B+树`来构建索引。只是空间列类型的索引使用`R-树`，并且MEMORY表还支持`hash索引`。

其实，用不用索引，最终都是优化器说了算。优化器是基于什么的优化器？基于`cost开销(CostBaseOptimizer)`，它不是基于`规则(Rule-BasedOptimizer)`，也不是基于`语义`。怎么样开销小就怎么来。另外，**SQL语句是否使用索引，跟数据库版本、数据量、数据选择度都有关系。**

##### **1.1** **全值匹配我最爱** 

可以根据select语句中的where中的条件创建联合索引，这样查询所用的时间会更低。

##### **1.2** **最佳左前缀法则**

在MySQL建立联合索引时会遵守`最佳左前缀匹配原则`，即最左优先，在检索数据时从`联合索引的最左边开始匹配`。

结论：MySQL可以为多个字段创建索引，一个索引可以包括==16个字段==。对于**多列索引**，**过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段，索引后面的字段都无法被使用。**==如果查询条件中没有使用这些字段中第1个字段时，多列（或联合）索引不会被使用==。

```MySQL
create index idx_age_classid_name on student(age, classid, name);
```

比如我们上面创建的索引，我们创建了一个联合索引，当我们进行查询的时候，按照最左前缀原则，当查询（age）、（age，classid）、（age，classid，name）这三种组合的时候可以用到我们定义的联合索引。如果我们查询（age，name），那么我们就只能使用到age的索引了。

我们不用太关心索引的先后顺序，什么意思呢？比如使用（age，classid）和（classid，age）效果是一样的。数据库的查询优化器会自动帮助我们优化我们的SQL，看哪个执行的效率更高，最后才生成最后执行的SQL。

**为什么会有最左前缀原则？**

使用b+树作为索引的存储数据结构时，当我们创建联合索引的时候，比如（age，classis，name），b+树建立索引是从左到右来建立搜索树的，比如当我们来查询where age=30 and classid=4 and name='abcd'，b+树会先通过最左边的（建立索引的字段的左边的字段）字段，也就是age来确定下一步要查询的对象，然后找到classid，再通过classid找到name，所以（classis，name）这样的查询命不中索引。因为最左前缀，一定是从最左边的字段开始一次在B+数的子节点查询，然后确定下一个查询的子节点的数据。所以我们可以使用（age），（age，classid），（age，classid，name）这三种查询条件是可以使用到索引的。

![image-20231012200044445](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310122000664.png)

![image-20231012200115846](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310122001926.png)

![image-20231012200151199](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310122001288.png)

从上面的三张截图可以看出，虽然这三种情况都用到了 `idx_age_classid_name` 索引，但是真正使用的 `key_len`  的长度是不一样的。

**联合索引字段先后顺序的影响？**

联合索引中字段的先后顺序，在SQL层面的执行效率，差别不大，是可以忽略的。无非就是当建立联合索引时，更换索引字段的先后顺序，匹配每个字段锁定的数据条数不一样，但是对最终的查询效率没有太大的影响。但是这个字段的顺序真的就不用考虑了吗？`不是的`，我们知道有最左匹配原则，所以我们要考虑我们的业务，比如说我们的业务场景中有一个字段enterprised，这个字段在80%的查询场景中都会遇到，那么我们肯定首选将这个字段放在联合索引字段的第一个位置，这样就能保证查询的高效，能够命中我们建立的索引。



##### **1.3** **主键插入顺序**

![image-20231012200520046](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310122005112.png)

可这个数据页已经满了，再插进来怎么办呢？我们需要把当前`页面分裂`成两个页面，把本页面中的一些记录移动到新创建的这个页面中。页面分裂和记录移动意味着什么？==性能消耗==，所以我们如果想尽量避免这种性能消耗，最好让插入的记录的`主键值依次递增`，这样就不会发生性能消耗了。在插入记录式存储引擎会自动为我们填入自增的主键值。这样的主键占用空间小，顺序写入，减少页面分裂。

**结论：**

对于一个使用`InnoDB`存储引擎的表来说，在我们没有显示的创建索引时，表中的数据实际上都是存储在`聚簇索引`的叶子节点的。而记录又存储在数据页中的，数据页和记录又是按照记录`主键值从小到大`的顺序进行排序，所以如果我们`插入`的记录的`主键值是依次增大`的话，那我们每插满一个数据页就换到下一个数据页继续插，而如果我们插入的`主键值忽小忽大`的话，则可能会造成`页面分裂`和`记录移位`。

##### **1.4** **计算、函数、类型转换(自动或手动)导致索引失效**

##### **1.5** **类型转换导致索引失效**

##### **1.6** **范围条件右边的列索引失效**

> 应用开发中范围查询，例如：金额查询，日期查询往往都是范围查询。**==应将查询条件放置where语句最后==**。（创建的联合索引中，务必把范围涉及到的字段写在最后）

```MySQL
explain select sql_no_cache * from student where age=30 and classid>20 and name='abcd';
```

![image-20231012201853536](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310122018645.png)

![image-20231012201954127](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310122019211.png)

通过上图我们可以发现：

```MySQL
# 将范围查询的条件放置在语句最后
explain select sql_no_cache * from student where age=30 and name='abc' and classid>20;
# 如果是指单单的改变where子句中索引的顺序是没有意义的，因为查询优化器会自动根据联合索引（age，classid，name）进行排序，所以最后还是把name这个索引省略掉了。
```

![image-20231012202349883](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310122023973.png)

==一定要新创建一个联合索引，把范围查询的classid放在最后==。

```MySQL
create index idx_age_name_classid on student(age, name, classid);

explain select sql_no_cache * from student where age=30 and name='abc' and classid>20;
```

![image-20231012210020689](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310122100768.png)

![image-20231012210049106](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310122100211.png)

由上图可以看出，**成功使用上了所有联合索引的字段**。



##### **1.7** **不等于(!= 或者<>)索引失效** 

```mysql
create index idx_name on student(name);

explain select sql_no_cache * from student where name='abcd';
```

![image-20231012210725228](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310122107301.png)

```mysql
explain select sql_no_cache * from student where name<>'abcd';
```

![image-20231012210816861](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310122108948.png)



##### **1.8 is null可以使用索引，is not null无法使用索引**

> 结论：最好在设计数据表的时候就将`字段设置为 NOT NULL 约束`，比如你可以将INT类型的字段，默认值设置为0。将字符类型的默认值设置为空字符串('')
>
> 拓展：同理，在查询中使用`not like`也无法使用索引，导致全表扫描

```mysql
explain select sql_no_cache * from student where age is null;
```

![image-20231012211011379](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310122110502.png)

```mysql
explain select sql_no_cache * from student where age is not null;
```

![image-20231012212903304](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310122129393.png)

```mysql
explain select sql_no_cache * from student where name like 'abc%';
```

![image-20231012213307892](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310122133001.png)

```mysql
explain select sql_no_cache * from student where name not like 'abc%';
```

![image-20231012213343265](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310122133357.png)

##### **1.9 like以通配符%开头索引失效**

> 拓展：Alibaba《Java开发手册》
>
> 【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。

```mysql
explain select sql_no_cache * from student where name like '%abc%';
```

![image-20231012213433355](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310122134437.png)

##### **1.10 OR** **前后存在非索引的列，索引失效**

**在WHERE子句中，如果在OR前的条件列进行了索引，而在OR后的条件列没有进行索引，那么索引会失效**。也就是说，**OR前后的两个条件中的列都是索引时，查询中才使用索引。**

##### **1.11** **数据库和表的字符集统一使用utf8mb4**

统一使用utf8mb4( 5.5.3版本以上支持)兼容性更好，统一字符集可以避免由于字符集转换产生的乱码。不同的`字符集`进行比较前需要进行`转换`会造成**索引失效**。

**一般性建议：**

- 对于单列索引，尽量选择针对当前query过滤性更好的索引
- 在选择组合索引的时候，当前query中过滤性最好的字段在索引字段顺序中，位置越靠前越好
- 在选择组合索引的时候，尽量选择能够当前包含query中的where子句中更多字段的索引
- 在选择组合索引的时候，如果某个字段可能出现范围查询时，尽量把这个字段放在索引次序的最后面。

#### **2.** **关联查询优化**

![image-20231012214542110](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310122145162.png)

此时给book添加索引。book是被驱动表。

```MySQL
create index Y on book(card);

EXPLAIN SELECT SQL_NO_CACHE * FROM `type` LEFT JOIN book ON type.card = book.card;
```

![image-20231012214801768](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310122148925.png)

可以看到第二行的`type`变为`ref`，`rows`也被优化的比较明显。这是由左连接特性决定的。left join 条件用于确定如何从右表搜索行，左边一定都有，所以`右边是我们的关键点`，一定需要建立索引。

如果只能给两个表中的一个表添加索引，那么一定只需要给被驱动表添加索引。

```MySQL
create index X on `type`(card);
explain select sql_no_cache * from `type` left join book on `type`.card = book.card;
```

![image-20231012215352779](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310122153834.png)

接着

![image-20231012215424532](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310122154581.png)

![image-20231012221005749](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310122210810.png)

![image-20231012221145851](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310122211935.png)

![image-20231012221205971](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310122212044.png)

> 结论1：对于内连接来说，查询优化器可以决定谁来作为驱动表，谁作为被驱动表出现（**被驱动表的成本较低**）
>
> 结论2：对于内连接来讲，如果表的连接条件中只能有一个字段有索引，则有索引的字段所在的表会被作为**被驱动表**
>
> 结论3：对于内连接来说，在两个表的连接条件都存在索引的情况下，会选择**小表作为驱动表**。`小表驱动大表`

##### 

**驱动表和被驱动表：**

join方式连接多个表，本质就是各个表之间数据的循环匹配。MySQL5.5版本之前，MySQL只支持一种表间关联方式，就是嵌套循环（Nested Loop Join）。如果关联表的数据量很大，则join关联的执行时间会非常长。在MySQL5.5以后的版本中，MySQL通过引入BNLJ算法来优化嵌套执行。

==驱动表就是主表，被驱动表就是从表、非驱动表。==

- **对于内连接来说**

  ```MySQL
  select * from A join B on ...
  ```

  A一定是驱动表吗，不一定，优化器会根据你查询语句做优化，决定先用哪张表。**先查询的那张表就是驱动表**，反之就是被驱动表，通过`explain`关键字可以查看。

- **对于外连接来说**

  ```MySQL
  select * from A left join B on ...
  # 或
  select * from B right join A on ...
  ```

  ![image-20231012231802114](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310122318294.png)

  ![image-20231012232028813](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310122320931.png)

  每从A中取出一条记录，都会把B表中的全部数据加载到内存中，经过了B表中所有的数据的匹配以后，就会把内存中B表的数据删除。然后再从A中取出一条记录，再把B中的所有数据加载到内存中，不断重复以上操作，所以非驱动表的IO次数很多。如果想减少非驱动表的IO次数，可以减少A表中的条目数。

  ![image-20231012232337256](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310122323328.png)

##### 2.1 Index Nested-Loop Join（索引嵌套循环连接）

Index Nested-Loop Join其优化的思路主要是为了`减少内层表数据的匹配次数`，所以要求**被驱动表**上必须`有索引`才行。

![image-20231012233249857](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310122332955.png)

![image-20231012233358772](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310122333872.png)

##### 2.2 Block Nested-Loop Join（块嵌套循环连接）

如果存在索引，那么会使用index的方式进行join，如果join的列没有索引，被驱动表要扫描的次数太多了。每次访问被驱动表，其表中的记录都会被加载到内存中，然后再从驱动表中取一条与其匹配，匹配结束后清除内存，然后再从驱动表中加载一条记录，然后把被驱动表的记录再加载到内存匹配，这样周而复始，大大增加了IO的次数。为了减少被驱动表的IO次数，就需要让A中的条目数少一点，但是A中的条目数是不可控的，因此就想着从A一块一块的加载记录到内存中，比如从A中一次性加载100条记录到内存中，这样就大大减少了IO次数，于是就出现了`Block Nested-Loop Join`的方式。

不再是逐条获取驱动表的数据，而是一块一块的获取，引入了`join buffer缓冲区`，**将驱动表join相关的部分数据列（大小受join buffer的限制）缓存到join buffer中**，然后全表扫描**被驱动表**，**被驱动表的每一条记录一次性和join buffer中的所有驱动表记录进行匹配（内存中操作）**，将简单嵌套循环中的多次比较合并成一次，**降低了被驱动表的访问频率**。

> 注意：
>
> 这里缓存的不只是关联表的列，select后面的列也会被缓存起来。
>
> 在一个有N个join关联的SQL中会分配N-1个join buffer。所以查询的时候尽量减少不必要的字段，可以让join buffer中可以存放更多的列。

![image-20231012234903764](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202310122349859.png)

##### 2.3 Hash Join

**从MySQL的8.0.20版本开始将废弃BNLJ，因为从MySQL8.0.18版本开始就加入了hash join默认都会使用hash join**

- Nested Loop：对于被连接的数据子集较小的情况下，Nested Loop是个较好的选择。
- Hash Join是做`大数据集连接`时的常用方式，优化器使用两个表中较小（相对较小）的表利用Join Key在内存中建立`散列值`，然后扫描较大的表并探测散列值，找出与Hash表匹配的行。
  - 这种方式适用于较小的表完全可以放入内存中的情况，这样总成本就是访问两个表的成本之和。
  - 在表很大的情况下并不能完全放入内存，这时优化器会将它分割成`若干不同的分区`，不能放入内存的部分就把该分区写入磁盘的临时段，此时要求有较大的临时段从而尽量提高I/O的性能。
  - 它能够很好的工作于没有索引的大表和并行查询的环境中，并提供最好的性能。Hash Join只能应用于等值连接，这是由Hash的特点决定的。

#### **3.** **子查询优化**

**子查询是** **MySQL** **的一项重要的功能，可以帮助我们通过一个** **SQL** **语句实现比较复杂的查询。但是，子查询的执行效率不高。**原因：

① 执行子查询时，MySQL需要为内层查询语句的查询结果`建立一个临时表`，然后外层查询语句从临时表中查询记录。查询完毕后，再`撤销这些临时表`。这样会消耗过多的CPU和IO资源，产生大量的慢查询。

② 子查询的结果集存储的临时表，不论是内存临时表还是磁盘临时表都`不会存在索引`，所以查询性能会受到一定的影响。

③ 对于返回结果集比较大的子查询，其对查询性能的影响也就越大。

**在MySQL中，可以使用连接（JOIN）查询来替代子查询。**连接查询`不需要建立临时表`，其`速度比子查询要快`，如果查询中使用索引的话，性能就会更好。

> 结论：尽量不要使用NOT IN 或者 NOT EXISTS，用LEFT JOIN xxx ON xx WHERE xx IS NULL替代

#### **4.** **排序优化**

1. SQL 中，可以在 WHERE 子句和 ORDER BY 子句中使用索引，目的是在 WHERE 子句中 `避免全表扫描`，在 ORDER BY 子句`避免使用 FileSort 排序`。当然，某些情况下全表扫描，或者 FileSort 排序不一定比索引慢。但总的来说，我们还是要避免，以提高查询效率。

2. 尽量使用 Index 完成 ORDER BY 排序。如果 WHERE 和 ORDER BY 后面是相同的列就使用单索引列；如果不同就使用联合索引。

3. 无法使用 Index 时，需要对 FileSort 方式进行调优。

#### **5. GROUP BY优化**

- group by 使用索引的原则几乎跟order by一致 ，group by 即使没有过滤条件用到索引，也可以直接使用索引。
- group by 先排序再分组，遵照索引建的最佳左前缀法则
- 当无法使用索引列，可以增大`max_length_for_sort_data`和`sort_buffer_size`参数的设置
- where效率高于having，能写在where限定的条件就不要写在having中了
- 减少使用order by，和业务沟通能不排序就不排序，或将排序放到程序端去做。Order by、group by、distinct这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。
- 包含了order by、group by、distinct这些查询的语句，where条件过滤出来的结果集请保持在1000行以内，否则SQL会很慢。

#### **6.** **优化分页查询**

**优化思路一**

在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容。

```mysql
EXPLAIN SELECT * FROM student t,(SELECT id FROM student ORDER BY id LIMIT 2000000,10) a
WHERE t.id = a.id;
```

**优化思路二**

该方案适用于主键自增的表，可以把Limit 查询转换成某个位置的查询。

```mysql
EXPLAIN SELECT * FROM student WHERE id > 2000000 LIMIT 10;
```

#### **7.** **优先考虑覆盖索引**

##### **7.1** **什么是覆盖索引？**

**理解方式一**：索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据；当能通过读取索引就可以得到想要的数据，那就不需要读取行了。**一个索引包含了满足查询结果的数据就叫做覆盖索引。**

**理解方式二**：非聚簇复合索引的一种形式，它包括在查询里的SELECT、JOIN和WHERE子句用到的所有列（即建索引的字段正好是覆盖查询条件中所涉及的字段）。

简单说就是，`索引列+主键`包含`SELECT 到 FROM之间查询的列`。

##### **7.2** **覆盖索引的利弊**

**好处：**

**1.** **避免Innodb表进行索引的二次查询（回表）**

**2.** **可以把随机IO变成顺序IO加快查询效率**

**弊端：**

`索引字段的维护`总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。这是业务DBA，或者称为业务数据架构师的工作。

#### **8.** **索引条件下推**

##### **8.1** **使用前后的扫描过程**

**在不使用ICP索引扫描的过程：**

storage层：只将满足index key条件的索引记录对应的整行记录取出，返回给server层 

server 层：对返回的数据，使用后面的where条件过滤，直至返回最后一行。

**使用ICP扫描的过程：**

storage层：首先将index key条件满足的索引记录区间确定，然后在索引上使用index filter进行过滤。将满足的index filter条件的索引记录才去回表取出整行记录返回server层。不满足index filter条件的索引记录丢弃，不回表、也不会返回server层。

server 层：对返回的数据，使用table filter条件做最后的过滤。

#### **9.** **其它查询优化策略**

##### **9.1 EXISTS** **和** **IN** **的区分**

索引是个前提，其实选择与否还会要看表的大小。你可以将选择的标准理解为`小表驱动大表`。

##### **9.2 COUNT(\*)与COUNT(具体字段)效率**

**环节1：**`COUNT(*)`和`COUNT(1)`都是对所有结果进行`COUNT`，`COUNT(*)`和`COUNT(1)`本质上并没有区别（二者执行时间可能略有差别，不过你还是可以把它俩的执行效率看成是相等的）。如果有WHERE子句，则是对所有符合筛选条件的数据行进行统计；如果没有WHERE子句，则是对数据表的数据行数进行统计。

**环节2：**如果是MyISAM存储引擎，统计数据表的行数只需要`O(1)`的复杂度，这是因为每张MyISAM的数据表都有一个meta信息存储了`row_count`值，而一致性则是由表级锁来保证的。

如果是InnoDB存储引擎，因为InnoDB支持事务，采用行级锁和MVCC机制，所以无法像MyISAM一样，维护一个row_count变量，因此需要采用`扫描全表`，是`O(n)`的复杂度，进行循环+计数的方式来完成统计。

**环节3：**在InnoDB引擎中，如果采用`COUNT(具体字段)`来统计数据行数，要尽量采用二级索引。因为主键采用的索引是聚簇索引，聚簇索引包含的信息多，明显会大于二级索引（非聚簇索引）。对于`COUNT(*)`和`COUNT(1)`来说，它们不需要查找具体的行，只是统计行数，系统会`自动`采用占用空间更小的二级索引来进行统计。

如果有多个二级索引，会使用key_len小的二级索引进行扫描。当没有二级索引的时候，才会采用主键索引来进行统计。

##### **9.3** **关于SELECT(\*)**

在表查询中，建议明确字段，不要使用 * 作为查询的字段列表，推荐使用SELECT <字段列表> 查询。原因：

① MySQL 在解析的过程中，会通过`查询数据字典`将"*"按序转换成所有列名，这会大大的耗费资源和时间。

② 无法使用`覆盖索引`

##### **9.4 LIMIT 1** **对优化的影响**

针对的是会扫描全表的 SQL 语句，如果你可以确定结果集只有一条，那么加上`LIMIT 1`的时候，当找到一条结果的时候就不会继续扫描了，这样会加快查询速度。

如果数据表已经对字段建立了唯一索引，那么可以通过索引进行查询，不会全表扫描的话，就不需要加上`LIMIT 1`了。

##### **9.5** **多使用COMMIT**

只要有可能，在程序中尽量多使用 COMMIT，这样程序的性能得到提高，需求也会因为 COMMIT 所释放的资源而减少。

COMMIT 所释放的资源：

- 回滚段上用于恢复数据的信息

- 被程序语句获得的锁

- redo / undo log buffer 中的空间

- 管理上述 3 种资源中的内部花费

### 