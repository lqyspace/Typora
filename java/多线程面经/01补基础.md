[TOC]

# 1、线程池中提交一个任务的流程是怎么样的

![image-20240312145315102](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202403121453187.png)

![image-20240312144422225](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202403121447318.png)

![image-20240312145422129](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202403121454201.png)



# 2、线程池中有几种状态，分别是如何变化的

![image-20240312145703161](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202403121457242.png)

![image-20240312150049973](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202403121500088.png)



# 3、如何优雅的停止一个线程

![image-20240312150421190](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202403121506864.png)

![image-20240312151740563](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202403121517596.png)



# 4、创建线程池的方式（五种）

## **一、通过Executors类提供的方法**

### 1、newCachedThreadPool

创建一个可缓存的线程池，若线程数超过处理所需，缓存一段时间后会回收，若线程数不够，则新建线程。

代码例子：

```java
private static void createCachedThreadPool() {
        ExecutorService executorService = Executors.newCachedThreadPool();
        for (int i = 0; i < 10; i++) {
            final int index = i;
            executorService.execute(() -> {
                // 获取线程名称,默认格式:pool-1-thread-1
                System.out.println(DateUtil.now() + " " + Thread.currentThread().getName() + " " + index);
                // 等待2秒
                sleep(2000);
            });
        }
    }
```

效果：

![img](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202403261532292.png)

因为初始线程池没有线程，而线程不足会不断新建线程，所以线程名都是不一样的。



### 2、newFixedThreadPool

创建一个固定大小的线程池，可控制并发的线程数，超出的线程会在队列中等待。

代码例子：

```java
private static void createFixedThreadPool() {
        ExecutorService executorService = Executors.newFixedThreadPool(3);
        for (int i = 0; i < 10; i++) {
            final int index = i;
            executorService.execute(() -> {
                // 获取线程名称,默认格式:pool-1-thread-1
                System.out.println(DateUtil.now() + " " + Thread.currentThread().getName() + " " + index);
                // 等待2秒
                sleep(2000);
            });
        }
    }
```

效果：

![img](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202403261533211.png)

因为线程池大小是固定的，这里设置的是3个线程，所以线程名只有3个。因为线程不足会进入队列等待线程空闲，所以日志间隔2秒输出。

### 3、newScheduledThreadPool

创建一个周期性的线程池，支持定时及周期性执行任务。

```java
private static void createScheduledThreadPool() {
        ScheduledExecutorService executorService = Executors.newScheduledThreadPool(3);
        System.out.println(DateUtil.now() + " 提交任务");
        for (int i = 0; i < 10; i++) {
            final int index = i;
            executorService.schedule(() -> {
                // 获取线程名称,默认格式:pool-1-thread-1
                System.out.println(DateUtil.now() + " " + Thread.currentThread().getName() + " " + index);
                // 等待2秒
                sleep(2000);
            }, 3, TimeUnit.SECONDS);
        }
    }
```

效果：

![img](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202403261535421.png)

因为设置了延迟3秒，所以提交后3秒才开始执行任务。因为这里设置核心线程数为3个，而线程不足会进入队列等待线程空闲，所以日志间隔2秒输出。



### 4、newSingleThreadExecutor

创建一个单线程的线程池，可保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。

```java
private static void createSingleThreadPool() {
        ExecutorService executorService = Executors.newSingleThreadExecutor();
        for (int i = 0; i < 10; i++) {
            final int index = i;
            executorService.execute(() -> {
                // 获取线程名称,默认格式:pool-1-thread-1
                System.out.println(DateUtil.now() + " " + Thread.currentThread().getName() + " " + index);
                // 等待2秒
                sleep(2000);
            });
        }
    }
```

效果：

![img](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202403261538557.png)

因为只有一个线程，所以线程名均相同，且是每隔2秒按顺序输出的。



## 二、**通过ThreadPoolExecutor类自定义。**

ThreadPoolExecutor类提供了4种构造方法，可根据需要来自定义一个线程池。

```java
public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler) {
        // 省略...
    }
```







博客参考：[Java中线程池的创建方式以及比较](https://www.cnblogs.com/pcheng/p/13540619.html)

# 4、线程池的核心线程数，最大线程数该如何设置

![image-20240312152329369](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202403121523475.png)

![image-20240312152744915](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202403121527978.png)

![image-20240312152834194](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202403121528261.png)

![image-20240312153037039](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202403121530139.png)

![image-20240312153143508](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202403121531539.png)



# 5、如何理解Java并发中的可见性

![image-20240312153928601](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202403121539685.png)

![image-20240312154054497](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202403121540582.png)



# 6、如何理解Java并发中的原子性

![image-20240312154359419](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202403121543513.png)

![image-20240312154448902](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202403121544992.png)

![image-20240312154502176](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202403121545225.png)

![image-20240312154520365](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202403121545396.png)



# 7、如何理解Java并发中的有序性

![image-20240312154654771](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202403121546843.png)

![image-20240312155119079](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202403121551152.png)

![image-20240312155224373](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202403121552403.png)

![image-20240312155357376](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202403121553456.png)

![image-20240312155437414](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202403121554479.png)



# 8、Java中有几种创建线程的方式

![image-20240312155633547](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202403121556667.png)

![image-20240312155723722](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202403121557816.png)

![image-20240312155744469](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202403121557635.png)

![image-20240312155850217](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202403121558312.png)

![image-20240312155911113](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202403121559258.png)

![image-20240312155931963](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202403121559027.png)

![image-20240312160006306](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202403121600458.png)

 ![image-20240312160145935](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202403121601014.png)

![image-20240312160211495](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202403121602607.png)

![image-20240312160339275](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202403121603339.png)



# 9、为什么不建议使用Executors来创建线程池

![image-20240312160621077](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202403121606189.png)

![image-20240312160819244](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202403121608383.png)



# 10、Synchronized和ReentrantLock有哪些不同点？

![image-20240312161331107](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202403121613174.png)



# 11、ThreadLocal有哪些应用场景，他的底层是如何实现的

![image-20240312161837385](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202403121618238.png)

![image-20240312162030039](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202403121620151.png)

![image-20240312162055884](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202403121620992.png)

![image-20240312162534333](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202403121625392.png)

# 12、ReentrantLock分为公平锁和非公平锁，那底层分别是如何实现的呢

![image-20240312163248777](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202403121632842.png)

![image-20240312163306295](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202403121633410.png)

![image-20240312163754306](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202403121637377.png)

# 13、Synchronized的锁升级过程

![image-20240312164138773](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202403121641917.png)

# 14、tomcat为什么使用自定义类加载器

![image-20240312164659765](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202403121646871.png)

![image-20240312164954255](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202403121649339.png)

# 15、JVM、JRE、JDK的关系

![image-20240312165224917](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202403121652977.png)

# 16、JVM可以运行多种语言吗

![image-20240312165404796](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202403121654842.png)

# 17、JVM有哪些内存区域

![image-20240312165621975](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202403121656020.png)

![image-20240312165708310](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202403121657361.png)

# 18、堆空间如何配置，区域怎么划分

![image-20240312170352117](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202403121703199.png)

![image-20240312170438202](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202403121704231.png)

# 19、JVM中有哪些内存区域会发生内存溢出（OOM）

![image-20240312170642565](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202403121706614.png)

# 20、JVM在创建对象时采用哪些并发安全机制

![image-20240312171638245](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202403121716306.png)

![image-20240312171745184](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202403121717686.png)

# 21、什么是对象头？对象头里面有哪些东西

![image-20240312173106895](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202403121731955.png)

# 22、为什么不要使用Finalize方法

![image-20240312173307221](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202403121733258.png)

# 23、什么是AQS

![image-20240312173504010](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202403121735093.png)

1、**AQS**是一个java线程同步的框架，是JDK很多锁工具的的核心实现框架。

2、在AQS中，维护一个信号量state和一个线程组成的双向链表队列。其中，这个线程队列就是用来给线程排队的，而state就像是一个红绿灯，用来控制线程排队或者放行的。在不同的场景下有不同的意义。

3、在可重入锁的场景下，state用来表示加锁的次数。0表示无锁，每加一次锁，state就加1，释放锁就减1.



# 24、说说对线程安全的理解

当多个线程访问临界区时不会产生紊乱，预期值和最终结果一致。



# 25、守护线程的理解

线程分为用户线程和守护线程，用户线程是普通线程，而守护线程是JVM的后台线程，比如垃圾回收线程就是守护线程，守护线程会在其他的普通线程停止运行之后自动关闭。



# 26、Java死锁如何避免

- 互斥
- 循环等待
- 不可剥夺
- 持有并等待

解决：

- 注意加锁顺序，保证每个线程按照同样的顺序进行加锁
- 注意加锁时限，可以针对锁设置一个超时时间
- 注意死锁检查，这是一种预防机制，确保在第一时间发生死锁并进行解决



# 27、线程池底层工作原理

线程池内部是通过队列+线程实现的，当我们用线程池执行任务时：

- 如果此时线程池中的线程数量小于corePoolSize，即使线程池中的线程都处于空闲状态，也要创建新的线程来处理被添加的任务
- 如果此时线程池中的线程数量等于corePoolSize，但是缓冲队列workQueue没有满，那么任务会被放进缓冲队列里。如果此时线程池中的线程数量大于等于corePoolSize，缓冲队列满，并且线程池中的线程数量小于maximumPoolSize，建新的线程来处理被添加的任务。
- 如果线程池中的线程数量大于corePooolSize，缓冲队列已满，并且线程池中的线程数量等于maximumPoolSize，那么通过handler所指定的拒绝策略来处理此任务
- 当线程池中的线程数量大于corePoolSize，如果某线程空闲时间超过keepAliveTime，线程将被终止。这样，线程池可以动态调整池中的线程数量。

**拒绝策略：**

- **AbortPolicy：**丢弃任务并抛出拒绝执行RejectedExecutionException异常信息。线程池默认的拒绝策略，必须处理好抛出的异常，否则会打断当前的执行流程，影响后续的任务执行。
- **DiscardPolicy：**直接丢弃，啥都没有，不触发任何动作。
- **DiscardOldestPolicy：**当初发拒绝策略，只要线程池没有关闭的话，丢弃阻塞队列**workQueue**中最老的任务，并将新任务加入
  - **使用场景**：这个策略还是会丢弃任务，丢弃时也是毫无声息，但是特点是丢弃的是老的未执行的任务，而且是待执行优先级较高的任务。基于这个特性，我能想到的场景就是，发布消息，和修改消息，当消息发布出去后，还未执行，此时更新的消息又来了，这个时候未执行的消息的版本比现在提交的消息版本要低就可以被丢弃了。因为队列中还有可能存在消息版本更低的消息会排队执行，所以在真正处理消息的时候一定要做好消息的版本比较。
- **CallerRunsPolicy：**当触发拒绝策略，只要线程池没有关闭的话，则使用调用线程直接运行任务。一般在并发比较小，性能要求不高，不允许失败的场景下使用，因为线程池一般情况下不会关闭，也就是提交的任务一定会执行，但是调用者自己运行任务，如果任务提交速度过快，可能导致程序阻塞，性能效率上必然的损失较大

# 28、线程池为什么先添加队列而不是先创建最大线程

**当线程池中的核心线程都在忙时，如果继续往线程池中添加任务，那么任务会先放入队列，队列满了之后，才会新开线程。**这就相当于，一个公司本来有10个程序员，本来这10个程序员能正常的处理各种需求，但是随着公司的发展，需求在慢慢的增加，但是一开始这些需求只会增加在待开发列表中，然后这10个程序员加班加点的从待开发列表中获取需求并进行处理，但是某一天待开发列表满了，公司发现现有的10个程序员是真的处理不过来了，所以就开始新招员工了。



# 29、说一下HashMap的put方法

1、根据key通过哈希算法和与运算得出数组下标

2、如果数组下标位置元素为空，则将key和value封装成Entry对象（JDK1.7是Entry对象，JDK1.8是Node对象）并放入该位置。

3、如果数组下标位置不为空，则要分情况讨论

- 如果jdk1.7，则先判断是否需要扩容，如果需要扩容则进行扩容，如果不用扩容就生成Entry对象，并使用头插法添加到当前位置的链表中

- 如果JDK1.8，则会先判断当前位置的Node类型，看是红黑树Node还是链表Node

  - 如果是红黑树Node，则将key和value封装成一个红黑树节点并添加到红黑树中去，这个过程中会判断红黑树中是否存在当前key，如果存在则更新value
  - 如果此位置上的Node对象是链表节点，则将key和value封装成一个链表Node并通过尾插法插入到链表的最后位置上，因为是尾插法，所以需要遍历链表，在遍历链表的过程中会判断是否存在当前key，如果存在则更新value。当遍历完链表后，将新链表Node插入到链表中，插入到链表后，会看当前链表的节点个数，如果大于等于8，那么则会将该链表转成红黑树
  - 将key和value封装成Node插入到链表就或者红黑树中后，再判断是否需要进行扩容，如果需要就扩容，如果不需要就结束PUT方法。

  

# 30、JDK1.7到JDK1.8 HashMap发生了什么变化

1、1.7中底层是数组+链表，1.8中底层是数组+链表+红黑树，加红黑树的目的是为了提高HashMap插入和查询的整体效率

2、1.7中链表插入使用的是头插法，1.8中链表插入使用的是尾插法，因为1.8中插入key和value时需要判断链表元素的个数，需要遍历链表统计链表元素个数，所以正好就是用了尾插法。

3、1.7中哈希算法比较复杂，存在各种右移或异或运算，1.8中进行了简化，因为复杂的哈希算法是为了提高散列性来提供HashMap的整体效率，而1.8中新增了红黑树，所以可以适当简化哈希算法，节省CPU资源。



