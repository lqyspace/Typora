# 订单超时怎么处理

**使用jdk自带的DelayQueue**

![image-20240409070904805](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202404090709916.png)

使用DelayQueue，重写里面的方法，进行排序，另起一个线程不停的轮询头节点，就出队进行超时处理。

并且更新订单的状态到数据库。

每次重启应用时需要从数据库中加载还未结束的订单到队列中

![image-20240409071152767](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202404090711805.png)



**基于MQ的延迟消息**

![image-20240409071259776](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202404090712815.png)

![image-20240409071417062](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202404090714117.png)



**基于redis的过期监听**

![image-20240409071732024](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202404090717073.png)

在redis中的键值设置过期时间，然后监听redis过期时间

![image-20240409071846336](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202404090718379.png)

数据量小的话，还是可以的 



**定时任务分布式处理**

![image-20240409072102604](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202404090721651.png)

![image-20240409072400155](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202404090724208.png)

![image-20240409072418769](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202404090724808.png)