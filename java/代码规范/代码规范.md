# 总结

## 避免过度设计

1. 不要为了应用设计模式而应用
2. 不以破坏代码可读性为前提
3. 不要为了短期不存在的扩展而费神
4. 持续重构优于提前设计



## 代码命名规范

### 基本命名规范

![image-20250111184741811](https://gcore.jsdelivr.net/gh/lqyspace/mypic@master/img1/202501111847309.png)



### 接口、抽象类、枚举的命名

抽象类：**BaseXXX**、**AbstractXXXX**

接口：ICacheService，CacheService（不推荐）

​            CacheService，CacheServiceImpl（不推荐）

​            CacheService，GuavaCacheService，CacheServiceBasedGuava（推荐）

​             Clonable、RandomAccess、Serializable、Collection（使用able，access结尾的接口）

枚举：PaymentStatus、PaymentStatusEnum、PaymentStatusEnums（常用前两种命名方式，阿里推荐使用第二种命名方式）



### 单元测试的命名比较特殊

类名：UserServiceIntegrationtest、UserServiceTest

方法名：sendSmsCode_VerifyTicketFailed_ThrowSendSmsCodeFailureException

变量：允许数字，比如：User user1= new User()



### 长命名 vs 短命名

- 作用域范围越大，命名越详细

- 作用域范围小，命名可以适当简化，比如：i，j，tmp

- 利用上下文适当简化命名

  ![image-20250111190945234](https://gcore.jsdelivr.net/gh/lqyspace/mypic@master/img1/202501111909255.png)



### 去除没有意义的前后缀单词

Data、Value、Info、Variable、Table、String、Object

![image-20250111190702300](https://gcore.jsdelivr.net/gh/lqyspace/mypic@master/img1/202501111907325.png)



### 命名中使用缩写

![image-20250111191227279](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202501111912304.png)

缩写是可以用的，只要能达成共识。



### 利用业务词汇表统一命名

行业共识、公司共识、团队共识、业务共识、项目共识

- 词汇表
- 设计文档
- 业务领域建模



### 编写项目统一的命名规范

基本命名规范+业务词汇表+项目开发的命名规范

- XXXController、XXXService、XXXDao、XXXRepo、XXXMapper
- getXXX、findXXX、queryXXX、addXXX、createXXX
- 接口、抽象类
- 枚举Enum
- 单复数 Utils、Asserts
- count、num、No、ID
- revenueTotal、totalRevenue



### 遵循已有的命名规范

![image-20250111192432474](https://gcore.jsdelivr.net/gh/lqyspace/mypic@master/img1/202501111924497.png)

写代码时遵循已有的命名规范！



### 命名也可以持续重构

命名可以持续重构，选择更加准确的单词：

```java
WechatUser getWechatUserInfo();
double getMean();
// 可以改成
WechatUser fetchWechatUserInfo();
double computeMeanApiCostTime();
```

在命名的时候可以使用一些更有表现力的单词，比如：

`manager`、`handler`、`processor`



### 命名要易读易写易理解

ActivityOrchestrater -> ActivityPlanner





## 代码注释的艺术

代码无法表达的信息都可以通过注释表达出来。

- 意图注释
- 警戒注释：给与警戒或者提示，比如：慎用该函数等
- 逻辑分割注释
- TODO注释
- 用法注释
- 总结性注释：what、how、why

不要为了注释而注释



破窗效应：一个屋子的窗户破了，如果没有人去修补的话，那么其他的窗户也会莫名其妙的破掉

一个人不写注释的话，那么其他而开始不写注释，如果一个人写烂代码，那么其他的人也开始写烂代码。



## 代码风格之争

**到底用空格还是tab**

尽量一个项目做到统一，要么都用空格，要么都用缩进。

可以idea的设置里设置缩进的空格数：

![image-20250111195137355](https://gcore.jsdelivr.net/gh/lqyspace/mypic@master/img1/202501111951382.png)

当然也可以使用idea的格式检查工具：

![image-20250111195249820](https://gcore.jsdelivr.net/gh/lqyspace/mypic@master/img1/202501111952849.png)

最后在你的代码里右键即可检查代码格式问题：

![image-20250111195349215](https://gcore.jsdelivr.net/gh/lqyspace/mypic@master/img1/202501111953243.png)



## 7个编程技巧

- 函数不能太长或太短，平均长度20行，尽量不要超过50行。如果代码只有几行，尽量不要拆分
- 一个函数只做一件事
  - 怎么判断哪些业务是函数直接相关的呢
    - 可以先写注释，然后判断是否抽取成子函数
- 复杂函数代码模块化
- 避免函数参数过多，一般3个参数
- 谨慎使用参数控制逻辑
- 处理函数的异常情况
- 控制函数的缩进层级，尽量减少缩进超过3层

  - 去除多余的if-else

  - 调整执行顺序来减少嵌套

  - 使用continue、break、return关键字，提前退出嵌套

  - 将部分嵌套逻辑封装成函数调用

  - 提取函数来替代注释

    ![image-20250112181220023](https://gcore.jsdelivr.net/gh/lqyspace/mypic@master/img1/202501121812519.png)



## 防御性编程

> **考虑所有的异常情况**

异常可以简单分为：

- **可恢复性异常**，比如网络临时断开，调用超时，非关键性业务失败，可以去重试或者服务降级
- **无法恢复性异常**，比如数据库报错，要fail-fast，并且尽量隔离影响的范围，记录和保护现场，最大程度的引起程序员注意等
- **未知处理异常**，对于只有调用者可以清楚的如何处理的异常，比如电话号码解析异常，显式地抛给调用者，让调用者来决策，是终止线程，还是忽略，还是做其他的补偿处理。



> **处理函数调用异常**

- 受检异常
- 非受检异常



> **处理外部系统出错**

- 正常返回
- 错误返回



> **记录并且通知异常**

- 健壮
- 可监控
  - 记录在单独的日志里，不要和其他的日志放在一起
- 可维护



> **完善校验函数入参**

- public函数
- private函数



> **尽量避免误用发生**

- 编写详细的注释和文档
- 尽量暴露足够少的接口
- 减少接口之间的依赖
- 避免过多的函数参数
- 避免让用户去选择
- 不使用不确定性对象
- 不可变变量使用final修饰
- 对于List<>等容器入参，不要去修改它的数据
- 对于List<>等容器返回值，如果必须不能被外部修改，那么就使用ImmutableList等不可变容器



> **不要忽略任何警告**

不要忽略任何警告，忽略警告有可能给自己埋下隐患



> **保证不生产脏数据**

数据>程序



> **从错误中快速回复**

- 使用日志
- 使用ab开关
- 回滚



> **考虑数据规模和性能**

设计代码时一定要考虑数据的规模和性能