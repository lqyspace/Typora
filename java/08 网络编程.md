# 1 网络编程入门

## 1.1 网络编程概述

- 计算机网络

  是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统

- 网络编程

  在网络通信协议下，实现网络互连的不同计算机上运行的程序间可以进行数据交换



## 1.2 网络编程三要素

- `IP`地址
- 端口
- 协议



## 1.3 IP地址

`IP`地址：是网络中设备的唯一标识

- `IP`地址分为两大类
  - `IPv4`：是给每个连接在网络上的主机分配一个32`bit`地址。按照`TCP/IP`规定，`IP`地址用二进制来表示，每个`IP`地址长32`bit`，也就是4个字节。例如一个采用二进制形式的`IP`地址是“11000000 1010100000000001 01000010”，这么长的地址，处理起来也太费劲了。为了方便使用，`IP`地址经常被写成十进制的形式，中间使用符号“`.`”分隔不同的字节。于是，上面的`IP`地址可以表示为“192.168.1.66”。`IP`地址的这种表示法叫做“**点分十进制表示法**”，这显然比1和0容易记忆得多
  - `IPv6`：由于互联网的蓬勃发展，`IP`地址的需求量愈来愈大，但是网络地址资源有限，使得`IP`的分配越发紧张。为了扩大地址空间，通过`IPv6`重新定义地址空间，采用128位地址长度，每16个字节一组，分成8组十六进制数，这样就解决了网络地址资源数量不够的问题
- DOS常用命令：
  - `ipconfig`：查看本机`IP`地址
  - `ping IP`地址：检查网络是否连通
- 特殊`IP`地址：
- ·127.0.0.1：是回送地址，可以代表本机地址，一般用来测试使用



## 1.4 InetAddress

`InetAddress`：此类表示Internet协议（`IP`）地址

![image-20230602221436286](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306022214963.png)

代码演示：

```java
public class InetAddressDemo {
    public static void main(String[] args) throws UnknownHostException {
//        InetAddress xiaoYun = InetAddress.getByName("XiaoYun");
        InetAddress xiaoYun = InetAddress.getByName("192.168.159.1");

        String name = xiaoYun.getHostName();// 获取此主机的IP地址
        String ip = xiaoYun.getHostAddress();// 获取此主机的ip地址字符串

        System.out.println("主机名：" + name);
        System.out.println("ip地址：" + ip);
    }
}
```

输出：

```java
主机名：XiaoYun
ip地址：192.168.159.1
```



## 1.5 端口和协议

![image-20230602223741850](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306022237918.png)

![image-20230602223812907](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306022238979.png)



# 2 UDP通信程序

## 2.1 UDP发送数据

![image-20230602224844602](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306022248671.png)

- 发送数据的步骤
  - 创建发送端的 `Socket` 对象(`DatagramSocket`)
  - 创建数据，并把数据打包
  - 调用 `DatagramSocket` 对象的方法发送数据
  - 关闭发送端

代码演示：

```java
public static void main(String[] args) throws IOException {
    // 创建发送端的Socket对象（DatagramSocket）
    // DatagramSocket() 构造数据报套接字并将其绑定在本地主机上的任何可用的端口上
    DatagramSocket ds = new DatagramSocket();

    // 创建数据，并将数据打包
    // DatagramSocket(byte[] buf, int length, InetAddress address, int port)
    // 构造一个数据包，发送长度为 length 的数据包到指定主机上的指定端口号上
    byte[] bys = "hello, udp,我来了".getBytes();

    DatagramPacket dp = new DatagramPacket(bys, bys.length, InetAddress.getByName("192.168.159.1"), 10086);

    // 调用DatagramSocket 对象的方法发送数据
    // void send(DatagramPacket p) 从此套接字发送数据报包
    ds.send(dp);

    //关闭发送端
    // void close() 关闭此数据报套接字
    ds.close();
}
```

![image-20230605135458219](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306051354279.png)





- 接收数据的步骤
  - 创建接收端的Socket对象（`DatagramSocket`）
  - 创建一个数据包用于接收数据
  - 调用`DatagramSocket`对象的方法接受数据
  - 解析数据宝，并把数据在控制台上显示
  - 关闭接收端

代码演示：

```java
public static void main(String[] args) throws IOException {
    // 创建接收端的Socket对象（DatagramSocket）
    // DatagramSocket(int port) 构造数据报套接字并将其绑定到本地主机上的指定端口
    DatagramSocket ds = new DatagramSocket(10086);

    // 创建一个数据包，用于接收数据
    // DatagramPacket(byte[] buf, int length) 构造一个 DatagramPacket用于接收长度为 length数据包
    byte[] bys = new byte[1024];
    DatagramPacket dp = new DatagramPacket(bys, bys.length);

    // 调用DatagramSocket对象的方法接受数据
    ds.receive(dp);

    // 解析数据包，并把数据在控制台显示
    // byte[] getData() 返回数据缓冲区
    byte[] data = dp.getData();

    // int getLength() 返回要发送的数据的实际长度或接收到的数据的长度
    int len = dp.getLength();
    String dataString = new String(data, 0, len);
    System.out.println("数据是："+ dataString);

    // 关闭接收端
    ds.close();
}
```

![image-20230605135407916](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306051354840.png)







## 2.2 UDP通信程序练习

- UDP发送数据：数据来自键盘录入，知道输入的数据是886，发送数据结束
- UDP接受数据：因为接收端不知道发送短什么时候停止发送，故采用是循环接收

```java
// 接收端
public class UDPReceiveTest {
    public static void main(String[] args) throws IOException {
        // 创建DatagramSocket对象（DatagramSocket）
        DatagramSocket ds = new DatagramSocket(10086);

        while (true){
            // 创建一个数据包，用于接受数据
            byte[] bys = new byte[1024];
            DatagramPacket dp = new DatagramPacket(bys, bys.length);

            // 调用DatagramSocket对象的接收方法
            ds.receive(dp);

            // 解析数据包。并把数据显示在控制台
            System.out.println("数据是：" + new String(dp.getData(), 0, dp.getLength()));
        }
    }
}
```

```java
// 发送端
public class UDPSendTest {
    public static void main(String[] args) throws IOException {
        // 创建发送端的DatagramSocket
        DatagramSocket ds = new DatagramSocket();

        // 键盘录入数据
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String line;
        while ((line=br.readLine())!=null){
            if ("886".equals(line))
                break;

            // 创建数据包，并把数据打包
            byte[] bys = line.getBytes();
            DatagramPacket dp = new DatagramPacket(bys, bys.length, InetAddress.getByName("XiaoYun"), 10086);
            // 发送数据
            ds.send(dp);
        }
        ds.close();
    }
}
```



# 3 TCP通信程序

## 3.1 TCP通信原理

![image-20230605143817015](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306051438124.png)





## 3.2 TCP发送数据

发送数据的步骤：

- 创建客户端的Socket对象（Socket）
- 获取输出流，写数据
- 释放资源

```java
// 客户端
public class ClientDemo {
    public static void main(String[] args) throws IOException {
//        创建客户端的Socket对象（Socket）
        // Socket(InetAddress address, int port) 创建流套接字并将其连接到指定IP地址的指定端口号。
//        Socket sc = new Socket(InetAddress.getByName("XiaoYun"), 10000);

//        Socket(String host, int port) 创建流套接字并将其连接到指定主机上的指定端口号。
        Socket xiaoYun = new Socket("XiaoYun", 10001);

        // 获取输出流，写数据
        // OutputStream getOutputStream() 返回此套接字的输出流。
        OutputStream outputStream = xiaoYun.getOutputStream();
        outputStream.write("hello,tcp!".getBytes());

        // 释放资源
        xiaoYun.close();
    }
}
```



## 3.3 TCP接受数据

接收数据的步骤：

- 创建服务端的Socket对象（`ServerSocket`）
- 监听客户端连接，返回一个Socket对象
- 获取输入流，读数据，并把数据显示在控制台
- 释放资源

```java
// 服务器端
public class ServerDemo {
    public static void main(String[] args) throws IOException {
        // 创建服务端的Socket对象（ServerSocket）
        // ServerSocket(int port) 创建绑定到指定端口的服务器套接字。
        ServerSocket ss = new ServerSocket(10001);

        // Socket accept() 侦听要连接到此套接字并接受它。
        Socket connect = ss.accept();

        // 获取输入流，读数据，并把数据显示在控制台
        InputStream is = connect.getInputStream();
        byte[] bys = new byte[1024];
        int len = is.read(bys);
        String data = new String(bys, 0, len);
        System.out.println("数据是：" + data);

        // 释放资源
        ss.close();// 其实只释放这一个就行
        //connect.close();
    }
}
```



## 3.4 TCP通信程序练习

练习1

- 客户端：发送数据，接收服务器反馈
- 服务器：接收数据，给出反馈

```java
// 客户端
public class ClientDemo1 {
    public static void main(String[] args) throws IOException {
        // 创建客户端的Socket
        Socket sc = new Socket("xiaoyun", 10002);

        // 获取输出流，写数据
        OutputStream os = sc.getOutputStream();
        os.write("客户端练习1".getBytes());

        // 接受服务器反馈
        InputStream is = sc.getInputStream();
        byte[] bys = new byte[1024];
        int len = is.read(bys);
        String data = new String(bys, 0, len);
        System.out.println("客户端：" + data);


        // 释放资源
        sc.close();
    }
}
```

```java
// 服务端
public class ServerDemo1 {
    public static void main(String[] args) throws IOException {
        ServerSocket ss = new ServerSocket(10002);

        // 监听客户端连接，返回一个Socket对象
        Socket s = ss.accept();

        // 获取输入流，读数据，并在控制台上显示
        InputStream is = s.getInputStream();
        byte[] bys = new byte[1024];
        int len = is.read(bys);
        String data = new String(bys, 0, len);
        System.out.println("服务器："+data);

        // 给出反馈
        OutputStream os = s.getOutputStream();
        os.write("数据已经收到！".getBytes());

        //释放资源
        ss.close();
    }
}
```



练习2：

- 客户端：数据来自于键盘录入，直到输入的数据是886，发送数据结束
- 服务端：接收到的数据在控制台显示

```java
// 客户端
public class ClientDemo2 {
    public static void main(String[] args) throws IOException {
        // 创建客户端Socket对象
        Socket sc = new Socket("xiaoyun", 10003);

        // 键盘录入
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        // 封装输出流
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(sc.getOutputStream()));
        String line;
        while ((line=br.readLine())!=null){
            if ("886".equals(line)){
                break;
            }

            // 获取输出流对象
//            OutputStream os = sc.getOutputStream();
//            os.write(line.getBytes());

            bw.write(line);
            bw.newLine();
            bw.flush();
        }
        sc.close();
    }
}
```

```java
// 服务端
public class ServerDemo2 {
    public static void main(String[] args) throws IOException {
        // 创建Socket对象
        ServerSocket ss = new ServerSocket(10003);

        // 监听客户端的链接
        Socket s = ss.accept();

        //获取输入流
        InputStream is = s.getInputStream();
        BufferedReader br = new BufferedReader(new InputStreamReader(is));
        String line;
        while ((line=br.readLine())!=null){
            System.out.println(line);
        }
        // 释放资源
        ss.close();
    }
}
```



练习3：

- 客户端：数据来自于键盘录入，直到输入的数据是886，发送数据结束
- 服务端：接收到的数据写入文本

```java
// 客户端
public class ClientDemo2 {
    public static void main(String[] args) throws IOException {
        // 创建客户端Socket对象
        Socket sc = new Socket("xiaoyun", 10003);

        // 键盘录入
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        // 封装输出流
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(sc.getOutputStream()));
        String line;
        while ((line=br.readLine())!=null){
            if ("886".equals(line)){
                break;
            }

            // 获取输出流对象
//            OutputStream os = sc.getOutputStream();
//            os.write(line.getBytes());

            bw.write(line);
            bw.newLine();
            bw.flush();
        }
        sc.close();
    }
}
```

```java
// 服务端
public class ServerDemo2 {
    public static void main(String[] args) throws IOException {
        // 创建Socket对象
        ServerSocket ss = new ServerSocket(10003);

        // 监听客户端的链接,返回一个对应的Socket对象
        Socket s = ss.accept();

        //获取输入流
        InputStream is = s.getInputStream();
        BufferedReader br = new BufferedReader(new InputStreamReader(is));·

        BufferedWriter bw = new BufferedWriter(new FileWriter("myNet.txt"));

        String line;
        while ((line=br.readLine())!=null){
            System.out.println(line);
            bw.write(line);
            bw.newLine();
            bw.flush();
        }
        // 释放资源
        ss.close();
        bw.close();
    }
}
```



练习4：

- 客户端：数据来自于文本
- 服务端：接收到的数据写入文本文件

```java
// 客户端
public class ClientDemo4 {
    public static void main(String[] args) throws IOException {
        // 创建套接字 Socket
        Socket sc = new Socket("xiaoyun", 10000);

        // 封装文本文件的数据
        BufferedReader br = new BufferedReader(new FileReader("newarrbw.txt"));
        // 封装输出流写数据
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(sc.getOutputStream()));

        String line;
        while ((line=br.readLine())!=null){
            bw.write(line);
            bw.newLine();
            bw.flush();
        }

        //释放资源
        bw.close();
        sc.close();
    }
}
```

```java
// 服务端
public class ServerDemo2 {
    public static void main(String[] args) throws IOException {
        // 创建Socket对象
        ServerSocket ss = new ServerSocket(10003);

        // 监听客户端的链接,返回一个对应的Socket对象
        Socket s = ss.accept();

        //获取输入流
        InputStream is = s.getInputStream();
        BufferedReader br = new BufferedReader(new InputStreamReader(is));

        BufferedWriter bw = new BufferedWriter(new FileWriter("myNet.txt"));

        String line;
        while ((line=br.readLine())!=null){
            System.out.println(line);
            bw.write(line);
            bw.newLine();
            bw.flush();
        }
        // 释放资源
        ss.close();
        bw.close();
    }
}
```



练习5：

- 客户端：数据来自于文本，接收服务的反馈
- 服务端：接收到的数据写入文本文件，给出反馈

```java
// 客户端
public class ClientDemo5 {
    public static void main(String[] args) throws IOException {
        Socket s = new Socket("xiaoyun", 10006);

        BufferedReader br = new BufferedReader(new FileReader("newarrbw.txt"));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(s.getOutputStream()));

        String line;
        while ((line= br.readLine())!=null){
            bw.write(line);
            bw.newLine();
            bw.flush();
        }

        // 自定义结束标记
        // 自定义标记缺点：如果文本中存在 886 ，那么会导致程序提前终止，导致数据缺失
//        bw.write("886");
//        bw.newLine();
//        bw.flush();

        // 最好的解决方案
        // void shutdownOutput() 禁用此套接字的输出流。
        s.shutdownOutput();

        // 接收反馈
        BufferedReader brr = new BufferedReader(new InputStreamReader(s.getInputStream()));
        String data = brr.readLine();// 等待读取数据
        System.out.println("服务器的反馈："+data);

        s.close();
        bw.close();
        brr.close();
    }
}
```

```java
// 服务端
public class ServerDemo5 {
    public static void main(String[] args) throws IOException {
        ServerSocket ss = new ServerSocket(10006);
        Socket s = ss.accept();

        //获取输入流
        BufferedReader br = new BufferedReader(new InputStreamReader(s.getInputStream()));

        // 封装输出流
        BufferedWriter bw = new BufferedWriter(new FileWriter("mysss.txt"));

        String line;
        while ((line=br.readLine())!=null){// 等待读取数据
            // 使用自定义结束标记的缺点：如果文本中存在886，那么会导致程序提前终止，导致数据缺失
//            if ("886".equals(line))
//                break;
            bw.write(line);
            bw.newLine();
            bw.flush();
        }

        // 给出反馈
        BufferedWriter bww = new BufferedWriter(new OutputStreamWriter(s.getOutputStream()));
        bww.write("文件上传成功！");
        bww.newLine();
        bww.flush();


        s.close();
        bw.close();
    }
}
```

**注意：**

- 中间出现过问题：程序一直等待
- 原因：读数据的方法是阻塞式的
- 解决方法：自定义结束标记；使用 `shutdownOutput()`方法（推荐）



练习6：

- 客户端：数据来自于文本，接收服务的反馈
- 服务端：接收到的数据写入文本文件，给出反馈，代码使用线程器进行封装，为每一个客户开启一个线程。

```java
// 客户端
public class ClientDemo5 {
    public static void main(String[] args) throws IOException {
        Socket s = new Socket("xiaoyun", 10006);

        BufferedReader br = new BufferedReader(new FileReader("newarrbw.txt"));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(s.getOutputStream()));

        String line;
        while ((line= br.readLine())!=null){
            bw.write(line);
            bw.newLine();
            bw.flush();
        }

        // 自定义结束标记
        // 自定义标记缺点：如果文本中存在 886 ，那么会导致程序提前终止，导致数据缺失
//        bw.write("886");
//        bw.newLine();
//        bw.flush();

        // 最好的解决方案
        // void shutdownOutput() 禁用此套接字的输出流。
        s.shutdownOutput();

        // 接收反馈
        BufferedReader brr = new BufferedReader(new InputStreamReader(s.getInputStream()));
        String data = brr.readLine();// 等待读取数据
        System.out.println("服务器的反馈："+data);

        s.close();
        bw.close();
        brr.close();
    }
}
```

```java
// 服务端
public class ServerThread implements Runnable {
    private Socket s;
    public ServerThread(Socket s) {
        this.s = s;
    }

    @Override
    public void run() {
        try {
            // 接收数据写到文件夹
            BufferedReader br = new BufferedReader(new InputStreamReader(s.getInputStream()));
//            BufferedWriter bw = new BufferedWriter(new FileWriter("copy.txt"));

            int count = 0;
            File file = new File("copy["+count+"].txt");
            while (file.exists()){
                count++;
                file = new File("copy["+count+"].txt");
            }
            BufferedWriter bw = new BufferedWriter(new FileWriter(file));

            String line;
            while ((line=br.readLine())!=null) {
                bw.write(line);
                bw.newLine();
                bw.flush();
            }

            // 给出反馈
            BufferedWriter bwServer = new BufferedWriter(new OutputStreamWriter(s.getOutputStream()));
            bwServer.write("文件上传成功！");
            bwServer.newLine();
            bwServer.flush();

            // 释放资源
            s.close();

        }catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```
