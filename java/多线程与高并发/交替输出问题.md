# 交替输出问题

**注意：**

关于线程同步的面试题，凡是从**时间角度**或者是**优先级角度**考虑解题的思路，基本上全不对。凡是从 `join` 考虑的， 99.99%不对。

![image-20230608151533608](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306081515698.png)

![image-20230608152124923](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306081521071.png)



## 解法1：使用LockSupport的park和unpark

```java
package 交替输出;

import java.util.concurrent.locks.LockSupport;

public class LockSupportDemo {
    static Thread t1 = null, t2=null;

    public static void main(String[] args) {
        char[] c1 = "1234567".toCharArray();
        char[] c2 = "ABCDEFG".toCharArray();

        t1 = new Thread(()->{
            for (char c: c1){
                System.out.print(c);
                LockSupport.unpark(t2); // 唤醒 t2
                LockSupport.park(); // t1阻塞，当前线程阻塞
            }
        }, "t1");

        t2 = new Thread(()->{
            for (char c: c2){
                LockSupport.park();
                System.out.print(c);
                LockSupport.unpark(t1);
            }
        }, "t2");

        t1.start();
        t2.start();
    }
}
```

思考：

1. `t1`线程能不能先阻塞自己，然后再唤醒t2？

   不能，因为将 `t1`阻塞了以后，就不可能往下执行叫醒 `t2`

2. `t2`可能还没有将自己阻塞，`t1`就过来将其唤醒，那之后 `t2`的状态如何？

   一般情况下，一定是先 `wait` 然后 `notify`，并且唤醒一定是被别人唤醒，不能自己唤醒自己。

   但是 `pack` 和 `unpack`是不一样的，`unpack`实是在内存中做了个标记，原来是 0 ，现在改成 1了，当 `pack`的时候，看见是 1，然后他就不挂起了，只是把 1改成了0。

   `pack`和 `unpack`在比较新的`jdk`里面有，老版的`jdk`里面没有。



## 解法2：经典解法

![image-20230608163816752](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306081638886.png)

```java
package 交替输出;

public class T01_sync_wait_notify {
    public static void main(String[] args) {
        final Object o = new Object();

        char[] c1 = "1234567".toCharArray();
        char[] c2 = "ABCDEFG".toCharArray();

        new Thread(()->{
            synchronized(o){
                for (char c: c1){
                    System.out.print(c);
                    try {
                        o.notify();
                        o.wait();//让出锁
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                }
                o.notify();// 必须，否则无法停止程序
            }
        }, "t1").start();

        new Thread(()->{
            synchronized (o) {
                for (char c: c2) {
                    System.out.print(c);
                    try {
                        o.notify();
                        o.wait();
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                }
                o.notify();
            }
        }, "t2").start();
    }
}
```

注意：

1. 这个代码是存在漏铜的，有可能会输出：”A1B2C3D4E5F6G7“
2. 之所以在每个线程的最后加一个 `notify` 是为了保证，谁先结束就负责把另一方唤醒，避免程序无法停止。



## 解法3：CountDownLatch解法

```java
package 交替输出;

import java.util.concurrent.CountDownLatch;

public class CountDownLatchDemo {
    private static CountDownLatch latch = new CountDownLatch(1);// 门栓

    public static void main(String[] args) {
        final Object o = new Object();

        char[] c1 = "1234567".toCharArray();
        char[] c2 = "ABCDEFG".toCharArray();

        new Thread(()->{
            try {
                latch.await();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            synchronized (o) {
                for (char c: c1) {
                    System.out.print(c);
                    try {
                        o.notify();
                        o.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                o.notify();
            }
        }, "t1").start();


        new Thread(()->{
            synchronized (o) {
                for (char c:c2) {
                    System.out.print(c);
                    latch.countDown();

                    try {
                        o.notify();
                        o.wait();// 让出锁
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                o.notify();
            }
        }, "t2").start();

    }
}
```

输出：”A1B2C3D4E5F6G7“

**注意：**

1. **wait**是一把锁的等待队列，一个线程调用了 **wait**，相当于让这个线程去了等待队列，让出了这把锁。
2. **notify**唤醒一个线程，但是唤醒的是一个随机的线程；**notifyAll**则是唤醒等待队列的所有的线程，这些线程都唤醒了以后，让他们去抢夺 CPU资源。
3. `wait` 和 `notify/notifyAll` 必须包含在 `synchronized` 代码块里面。
4.  必须先 `wait`，再 `notify` 才可以唤醒阻塞的线程。



## 解法4：ReentrantLock可重入锁

```java
package 交替输出;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class CountDownLatchLockCondition {
    public static void main(String[] args) {
        char[] c1 = "1234567".toCharArray();
        char[] c2 = "ABCDEFG".toCharArray();

        Lock lock = new ReentrantLock();
        Condition conditionT1 = lock.newCondition();// 队列1
        Condition conditionT2 = lock.newCondition();// 队列2

        CountDownLatch latch = new CountDownLatch(1);

        new Thread(()->{
            try {
                latch.await();// 加上一个门栓
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            lock.lock();

            try {
                for (char c: c1) {
                    System.out.print(c);
                    conditionT2.signal();
                    conditionT1.await();
                }
                conditionT2.signal();

            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }
        }, "t1").start();

        new Thread(()->{
            lock.lock();
            try {
                for (char c: c2){
                    System.out.print(c);
                    latch.countDown();
                    conditionT1.signal();
                    conditionT2.await();
                }
                conditionT1.signal();
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }

        }, "t2").start();
    }
}
```

输出：“A1B2C3D4E5F6G7”



## 解法5：使用同步队列

```java
package 交替输出;

import java.util.concurrent.LinkedTransferQueue;
import java.util.concurrent.TransferQueue;

public class TransferQueueDemo {
    public static void main(String[] args) {
        char[] c1 = "1234567".toCharArray();
        char[] c2 = "ABCDEFG".toCharArray();

        TransferQueue<Character> queue = new LinkedTransferQueue<>();
        new Thread(()->{
            try {
                for (char c: c1) {
                    System.out.print(queue.take()); // 取字符
                    queue.transfer(c); // 存字符
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "t1").start();

        new Thread(()->{
            try {
                for (char c: c2) {
                    queue.transfer(c); // 存字符
                    System.out.print(queue.take()); // 取字符
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "t2").start();
    }
}
```

输出：“A1B2C3D4E5F6G7”