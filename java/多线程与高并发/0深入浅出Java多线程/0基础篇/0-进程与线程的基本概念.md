原博客：[https://redspider.gitbook.io/concurrent/di-yi-pian-ji-chu-pian/1](https://redspider.gitbook.io/concurrent/di-yi-pian-ji-chu-pian/1)

# 上下文切换

## 1 进程和线程的区别

进程是一个独立的运行环境，而线程是在进程中执行的一个任务。他们两个本质的区别是**是否单独占有内存地址空间及其它系统资源（比如I/O）**：

- 进程单独占有一定的内存地址空间，所以进程间存在内存隔离，数据是分开的，数据共享复杂但是同步简单，各个进程之间互不干扰；而线程共享所属进程占有的内存地址空间和资源，数据共享简单，但是同步复杂。
- 进程单独占有一定的内存地址空间，一个进程出现问题不会影响其他进程，不影响主程序的稳定性，可靠性高；一个线程崩溃可能影响整个程序的稳定性，可靠性较低。
- 进程单独占有一定的内存地址空间，进程的创建和销毁不仅需要保存寄存器和栈信息，还需要资源的分配回收以及页调度，开销较大；线程只需要保存寄存器和栈信息，开销较小。

另外一个重要区别是，**进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位**，即CPU分配时间的单位 。



## 2 上下文切换

上下文切换（有时也称做进程切换或任务切换）是指 CPU 从一个进程（或线程）切换到另一个进程（或线程）。上下文是指**某一时间点 CPU 寄存器和程序计数器的内容。**

> 寄存器是cpu内部的少量的速度很快的闪存，通常存储和访问计算过程的中间值提高计算机程序的运行速度。
>
> 程序计数器是一个专用的寄存器，用于表明指令序列中 CPU 正在执行的位置，存的值为正在执行的指令的位置或者下一个将要被执行的指令的位置，具体实现依赖于特定的系统。
>
> 举例说明 线程A - B
>
> 1.先挂起线程A，将其在cpu中的状态保存在内存中。
>
> 2.在内存中检索下一个线程B的上下文并将其在 CPU 的寄存器中恢复,执行B线程。
>
> 3.当B执行完，根据程序计数器中指向的位置恢复线程A。

CPU通过为每个线程分配CPU时间片来实现多线程机制。CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。

但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以任务从保存到再加载的过程就是一次上下文切换。

上下文切换通常是计算密集型的，意味着此操作会**消耗大量的 CPU 时间，故线程也不是越多越好**。如何减少系统中上下文切换次数，是提升多线程性能的一个重点课题。



## 3 如何减少上下文切换

减少上下文切换的方法有：无锁并发编程，CAS算法，使用最少线程和使用协程。

- **无锁并发编程。**多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的ID按照Hash算法取模分段，不同线程处理不同段的数据。
- **CAS算法。**Java的Atomic包使用CAS算法来更新数据，而不需要加锁。
- **使用最少线程。**避免创建不需要的线程，比如任务很少，但是创建了很多的线程来处理，这样会造成大量的线程处于等待状态。
- **协程：**在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。



# 死锁

锁是个非常有用的工具，运用场景非常多，因为它使用起来非常简单，而且易于理 解。但同时它也会带来一些困扰，那就是可能会引起死锁，一旦产生死锁，就会造成系 统功能不可用。让我们先来看一段代码，这段代码会引起死锁，使线程 t1 和线程 t2 互相 等待对方释放锁。

```java
public class MainLockDead {
    private static String A = "A";
    private static String B = "B";

    public static void main(String[] args) {
        deadLock();
    }

    public static void deadLock(){
        Thread t1 = new Thread(()->{
            synchronized(A){
                try {
                    Thread.currentThread().sleep(2000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized(B){
                    System.out.println("1");
                }
            }
        });

        Thread t2 = new Thread(()->{
           synchronized(B){
               synchronized(A){
                   System.out.println("2");
               }
           }
        });

        t1.start();
        t2.start();
    }
}
```



介绍几种避免死锁的常见方法：

- 避免一个线程同时获取多个锁
- 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。
- 尝试使用定时锁，使用lock.tryLock(timeout) 来代替使用内部锁机制。
- 对于数据库锁，加锁和解锁必须在一个数据库链接里，否则会出现解锁失败的情形。









