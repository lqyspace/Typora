# 哲学家就餐

![image-20230608140923634](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306081409107.png)

**注意几点问题：**

1. 哲学家们都先去拿自己右手边的筷子，然后再去拿左手边的筷子，这就导致每个哲学家循环等待左手边的筷子，而形成死锁。
2. 解决死锁的办法：
   1. **一次性分配所有筷子**，这就相当于对所有的筷子只加了一把锁，因此哲学家只能一个一个的访问，所以并不会形成死锁。之所以会形成死锁是因为对每个筷子都加了一把锁，每个哲学家占有了一把锁但是却在等待另外一把锁，因此形成死锁。
   2. **让其中的一个人是左撇子**，这个人先拿他左手边的筷子，然后再去拿他右手边的筷子。这样其中有一个人就能拿到完整的筷子，等这个人吃完了释放了筷子，那其他的哲学家也就可以拿起筷子吃完。

例1：会形成死锁的代码

筷子类：

```java
package day01;

public class Chopsticks {
}
```

哲学家类：

```java
package day01;

public class Philosopher extends Thread {
    private Chopsticks left, right;
    private int index;

    public Philosopher(String name, int index, Chopsticks left, Chopsticks right){
        this.setName(name);
        this.index = index;
        this.left = left;
        this.right = right;
    }

    @Override
    public void run() {
        synchronized (left) {// 先给左筷子加锁
            try {
                Thread.sleep(1000 + index*1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            synchronized (right) {// 再给右筷子加锁
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                System.out.println(index+"号哲学家已经吃完");
            }

        }
    }
}
```

测试类：

```java
package day01;

public class PhilosopherDemo {
    public static void main(String[] args) {
        Chopsticks cs1 = new Chopsticks();
        Chopsticks cs2 = new Chopsticks();
        Chopsticks cs3 = new Chopsticks();
        Chopsticks cs4 = new Chopsticks();
        Chopsticks cs5 = new Chopsticks();

        Philosopher p1 = new Philosopher("p1", 0, cs1, cs2);
        Philosopher p2 = new Philosopher("p2", 1, cs2, cs3);
        Philosopher p3 = new Philosopher("p3", 2, cs3, cs4);
        Philosopher p4 = new Philosopher("p4", 3, cs4, cs5);
        Philosopher p5 = new Philosopher("p5", 4, cs5, cs1);

        p1.start();
        p2.start();
        p3.start();
        p4.start();
        p5.start();
    }
}
```

运行会形成死锁



解决办法：

当所有的人都先拿右手边的筷子时，让其中的一个人先拿左手边的筷子，这样必能让其中某一个人拿到完整的筷子进餐。

```java
@Override
public void run() {
    if (index==0) {
        synchronized (left) {// 先给左筷子加锁
            try {
                Thread.sleep(1000 + index * 1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            synchronized (right) { // 再给右筷子加锁
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                System.out.println(index + "号哲学家已经吃完");
            }
        }
    }else {
        synchronized (right) {// 先给右筷子加锁
            try {
                Thread.sleep(1000 + index * 1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            synchronized (left) { // 再给左筷子加锁
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                System.out.println(index + "号哲学家已经吃完");
            }
        }
    }
}
```

不过这个方法有点低效。

可以让奇数位的哲学家先左后右，让偶数位的哲学家先右后左。这样必能保证其中两个人可以同时进餐。这种方法高效一些。

```java
@Override
public void run() {
    if (index%2==1) {
        synchronized (left) {// 先给左筷子加锁
            try {
                Thread.sleep(1000 + index * 1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            synchronized (right) { // 再给右筷子加锁
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                System.out.println(index + "号哲学家已经吃完");
            }
        }
    }else {
        synchronized (right) {// 先给右筷子加锁
            try {
                Thread.sleep(1000 + index * 1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            synchronized (left) { // 再给左筷子加锁
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                System.out.println(index + "号哲学家已经吃完");
            }

        }
    }
}
```

