[TOC]

# 十一、实现多线程

## 1、进程和线程

- **进程**：是正在运行的程序

  是系统进行资源分配和调度的独立单位

  每一个进程都有他自己的内存空间和系统资源

- **线程**：是进程中的单个顺序的控制流，是一条执行路径

  单线程：一个进程如果只有一条执行路径，则称为单线程程序

  多线程：一个进程如果有多个执行路径，则称为多线程程序。



## 2、实现多线程方式一：继承Thread类

![image-20230402004746291](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202304020048813.png)

代码演示：

MyThreadDemo测试类：

```java
public class MyThreadDemo {
    public static void main(String[] args) {
        MyThread my = new MyThread();
        MyThread my1 = new MyThread();

//        my.run();// 使用此调用方式并没有成功的启动多线程同时运行，而是my运行完了再my1运行
//        my1.run();

        my.start();
        my1.start();// 两个线程同时运行
    }
}
```

MyThread子类：

```java
public class MyThread extends Thread {
    @Override
    public void run() {
        for (int i=0; i<100; i++){
            System.out.println(i);
        }
    }
}
```

**注意：**

1、为什么要重写run()方法

​	因为run()是用来封装被线程执行的代码

2、run()方法和start()方法的区别？

​	run()：封装线程执行的代码，直接调用，相当于普通方法的调用

​	start()：启动线程，然后由jvm调用此线程的run()方法





## 3、设置和获取线程名称

![image-20230402010705799](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202304020107850.png)

代码1示例：

方式一：

```java
public class MyThreadDemo {
    public static void main(String[] args) {
        MyThread my = new MyThread();
        MyThread my1 = new MyThread();

        my.setName("高铁");
        my1.setName("飞机");

        my.start();
        my1.start();// 两个线程同时运行
    }
}
```

方式二：

```java
public class MyThreadDemo {
    public static void main(String[] args) {
//        MyThread my = new MyThread();
//        MyThread my1 = new MyThread();
//
//        my.setName("高铁");
//        my1.setName("飞机");
        // 带参构造
        MyThread my = new MyThread("高铁");
        MyThread my1 = new MyThread("完成");

        my.start();
        my1.start();// 两个线程同时运行
    }
}
```

```java
public class MyThread extends Thread {
    public MyThread(){

    }
    public MyThread(String name){
        super(name);
    }

    @Override
    public void run() {
        for (int i=0; i<100; i++){
            System.out.println(this.getName() + ":" +i);
        }
    }

    /*
    // Thread 类的属性名
      private String name;
    *
    // 无参构造方法
    * public Thread() {
        this(null, null, "Thread-" + nextThreadNum(), 0);
    }
    // 带参构造方法
    public Thread(String name) {
        this(null, null, name, 0);// 调用下面这个方法
    }
    *
    * public Thread(ThreadGroup group, Runnable target, String name,
                  long stackSize) {
        this(group, target, name, stackSize, null, true);
    }
        // 私有构造方法
      private Thread(ThreadGroup g, Runnable target, String name,
                   long stackSize, AccessControlContext acc,
                   boolean inheritThreadLocals) {

        this.name = name;
       }

      // 获取类名
    * public final String getName() {
        return name;
     }
    // 设置类名
     public final synchronized void setName(String name) {
        this.name = name;
    }
    * private static int threadInitNumber;//0 默认从0开始
      private static synchronized int nextThreadNum() {
        return threadInitNumber++;// 0  , 1
    }
    * */
}
```



代码2示例：

```java
public class MyThreadDemo {
    public static void main(String[] args) {
//        MyThread my = new MyThread();
//        MyThread my1 = new MyThread();
//
//        my.setName("高铁");
//        my1.setName("飞机");
//        // 带参构造
//        MyThread my = new MyThread("高铁");
//        MyThread my1 = new MyThread("完成");
//
//
//        my.start();
//        my1.start();// 两个线程同时运行
        // static Thread currentThread()返回 对 当前正在执行的 线程对象 的引用
        System.out.println(Thread.currentThread().getName()); // main
    }
}
```

![image-20230402013433783](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202304020134844.png)



## 4、线程优先级

- 线程调度

  - 两种调度方式：

    - 分时调度模型：所有线程轮流使用CPu的使用权，平均分配每个线程占用CPU的时间片
    - 占式调度模型：优先让优先级高的线程使用CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的CPU时间片相对多一些

  - java使用的是抢占式调度模型

  - 随机性

    假设计算机只有一个CPU，那么CPU在某一时刻只能执行一条指令，线程只有得到CPU的时间片，也就是使用权，才可以执行指令，所以说多线程程序的执行使具有随机性的，因为谁抢到CPU的使用权是不一定的

- 优先级相关方法

  ![image-20230402014227306](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202304020142366.png)

代码示例：

```java
public class ThreadPriorityDemo {
    public static void main(String[] args) {
        ThreadPriority tp1 = new ThreadPriority();
        ThreadPriority tp2 = new ThreadPriority();
        ThreadPriority tp3 = new ThreadPriority();

        tp1.setName("tp1");
        tp2.setName("tp2");
        tp3.setName("tp3");

        // 获取优先级，默认是5
//        System.out.println("tp1:" +tp1.getPriority());//5
//        System.out.println("tp3:" +tp3.getPriority());//5
//        System.out.println("tp2:" +tp2.getPriority());//5

//        tp1.setPriority(500); // 设置优先级，1-10之间，否则抛出：IllegalArgumentException
//        tp1.setPriority(5);
//        tp3.setPriority(6);
//        tp2.setPriority(7);

        // 优先级范围1-10
//        System.out.println(Thread.MAX_PRIORITY); // 10
//        System.out.println(Thread.MIN_PRIORITY); // 1
//        System.out.println(Thread.NORM_PRIORITY); // 默认：5

        tp1.setPriority(5);
        tp3.setPriority(6);
        tp2.setPriority(7);

//        tp1.start();
//        tp2.start();
//        tp3.start();

    }
}
```

**注意：**

1、线程默认的优先级是5；线程优先级的范围是：1-10

2、线程优先级高仅仅表示线程获取CPU时间片的几率高，但是要在次数比较多，或者多次运行的时候才能看到想要的效果。



## 5、线程控制

- 相关方法

  ![image-20230402201108900](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202304022011135.png)

sleep方法：使当前正在运行的程序暂停指定参数秒

join方法：其他的线程必须等待调用此方法的线程执行完毕，其他的线程才有机会继续执行

setDaemon方法：将线程标记为守护线程以后，当**主线程**执行完毕以后，java虚拟机不会等待守护线程执行完毕才退出，而是主线程执行完毕后立马就退出。



示例代码：

> **sleep方法**

线程类：

```java
public class ThreadPriority extends Thread{
    @Override
    public void run() {
        for (int i=0; i<100; i++){
            System.out.println(getName() + ":" + i);
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

测试类：

```java
public class ThreadSleepDemo {
    public static void main(String[] args) {
        ThreadPriority ts1 = new ThreadPriority();
        ThreadPriority ts2 = new ThreadPriority();
        ThreadPriority ts3 = new ThreadPriority();

        ts1.setName("曹操");
        ts2.setName("刘备");
        ts3.setName("孙权");

        ts1.start();
        ts2.start();
        ts3.start();
    }
}
```

输出：

```java
刘备:0
曹操:0
孙权:0
曹操:1
刘备:1
孙权:1
孙权:2
刘备:2
曹操:2
孙权:3
刘备:3
曹操:3
曹操:4
孙权:4
刘备:4
曹操:5
刘备:5
孙权:5
曹操:6
孙权:6
刘备:6
```

总结：使每个线程都会去暂停1秒，但是一秒以后，这三个线程在执行的时候仍然是抢占资源的。



> **join方法**

线程类：

```java
public class ThreadPriority extends Thread{
    @Override
    public void run() {
        for (int i=0; i<100; i++){
            System.out.println(getName() + ":" + i);
        }
    }
}
```

测试类：

```java
public class ThreadSleepDemo {
    public static void main(String[] args) throws InterruptedException {
        ThreadPriority ts1 = new ThreadPriority();
        ThreadPriority ts2 = new ThreadPriority();
        ThreadPriority ts3 = new ThreadPriority();

        ts1.setName("曹操");
        ts2.setName("刘备");
        ts3.setName("孙权");
        ts1.start();
        ts1.join();
        ts2.start();
        ts3.start();
    }
}
```

输出结果：等曹操线程输出完毕，刘备和孙权现成开始争夺CPU资源。



> **setDaemon方法**

线程类：

```java
public class ThreadPriority extends Thread{
    @Override
    public void run() {
        for (int i=0; i<100; i++){
            System.out.println(getName() + ":" + i);
        }
    }
}
```

测试类：

```java
public class ThreadSleepDemo {
    public static void main(String[] args) throws InterruptedException {
        ThreadPriority ts1 = new ThreadPriority();
        ThreadPriority ts2 = new ThreadPriority();
        ThreadPriority ts3 = new ThreadPriority();

        ts1.setName("曹操");
        ts2.setName("刘备");
        ts3.setName("孙权");

        ts1.setDaemon(true);// 设置为守护线程
        ts2.setDaemon(true);// 设置为守护线程
        ts3.setDaemon(true);// 设置为守护线程


        ts1.start();
        ts2.start();
        ts3.start();

        Thread.currentThread().setName("主线程");

        for (int i=0; i<10;i++){
            System.out.println(Thread.currentThread().getName() + ":" + i);
        }
    }
}
```

输出结果：这三个守护线程并没有执行完，而是主线程停止后很快就停止了。

**总结**：当主线程执行完毕，程序中仅剩守护线程时，java虚拟机会直接退出，不会等守护线程执行完毕。



## 6、线程的生命周期

![image-20230402221106018](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202304022211097.png)

1、创建线程对象之后通过 start() 方法运行，线程进入 就绪态，此时有执行资格但是没有执行权。

2、当线程抢到了CPU的执行权，那么线程就拥有了执行权，线程进入运行态。

3、当run()方法结束，或者调用了 stop方法，线程就会死忙，然后变成垃圾。

4、在线程处于运行态时，如果线程调用了sleep方法，或者其他的阻塞式方法，线程就会进入阻塞态，此时的线程没有执行资格也没有执行权。

5、处于阻塞态的线程的sleep方法调用结束，或者其他的阻塞方法结束，线程又开始进入就绪态，此时的线程拥有执行资格，但是没有执行权。

6、如果线程再次抢到了CPU的执行权，线程就进入运行态。





## 7、实现多线程的方式二：实现Runnable的接口

![image-20230402221953624](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202304022219686.png)

![image-20230402222006540](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202304022220596.png)

代码示例：

线程类：

```java
public class MyRunnable implements Runnable{
    @Override
    public void run() {
        for (int i=0; i<100; i++){
//            System.out.println(getName + ":"+i);
            // 不能使用getName方法，因为这个方法并没有继承Thread类
            // 可以通过 Thread.currentThread().getName() 获取名字
            System.out.println(Thread.currentThread().getName() + ":"+i);
        }
    }
}
```

测试类：

```java
public class MyThreadDemo {
    public static void main(String[] args) {
        MyRunnable my = new MyRunnable();

//        Thread t1 = new Thread(my);
//        Thread t2 = new Thread(my);
        Thread t1 = new Thread(my, "hello");
        Thread t2 = new Thread(my, "java");

        t1.start();
        t2.start();
    }
}
```



**总结**：

> 实现多线程的方式有两种

- 继承Thread类
- 实现Runnable接口



> 相比继承Thread类，实现Runnable接口的好处

- 避免了单继承的局限性
  - 在实现一个接口的同时可以继承一个类
- 适合多个相同程序的代码去处理同一个资源的情况，把线程和程序的代码，数据有效分离，较好的体现了面向对象的设计思想



**案例：**

![image-20230403221625714](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202304032216362.png)

![image-20230403231148177](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202304032311320.png)

![image-20230403232036269](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202304032320362.png)

![image-20230403232056710](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202304032320806.png)

![image-20230403232136468](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202304032321569.png)

![image-20230403232152844](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202304032321968.png)





## 8、线程同步

> 数据安全问题

- 是否是多线程环境
  - 单线程不存在数据安全问题
- 是否有共享数据
- 是否是多条语句操作共享数据



> 如何解决多线程数据安全问题

- 基本思想：让程序没有安全问题的环境



> 怎么实现

- 将共享数据锁起来，每个时间只能有一个线程执行访问
- java提供了同步代码块的方式解决



> **同步代码块格式**

```java
synchronized(任意对象){
	多条语句操作共享数据的代码
}
```

synchronized(任意对象)：就相当于给代码块加锁，任意对象就可以看成是一把锁



- 同步的好处和弊端
  - 好处：解决了多线程的数据安全问题
  - 弊端：当线程很多时，因为每个线程都会去判断同步上的锁，这是很耗费资源的，会降低程序的运行效率。



代码示例：

线程类：

```java
public class SellTicket implements Runnable{
    private int tickets = 100;
    private Object obj = new Object(); // 必须使用同一个obj，如果把它写在synchronized（new Object()）的里面，相当于加了三把锁，所以是锁不住的
    @Override
    public void run() {
        while (true){
            synchronized (obj){
                // t1进来，加锁
                if (tickets>0){
                    try {
                        Thread.sleep(100);
                        // t1休息100ms
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(Thread.currentThread().getName() + "正在出售第" + tickets + "张票。");
                    tickets--;
                }
            }
            // t1 出来，释放锁
        }
    }
}
```

测试类：

```java
public class SellTicketDemo {
    public static void main(String[] args) {
        SellTicket st = new SellTicket();

        Thread st1 = new Thread(st, "窗口1");
        Thread st2 = new Thread(st, "窗口2");
        Thread st3 = new Thread(st, "窗口3");

        st1.start();
        st2.start();
        st3.start();
    }
}
```



> **同步方法**

```java
public class SellTicket implements Runnable{
    private int tickets = 100;
    private Object obj = new Object(); // 必须使用同一个obj，如果把new Object()写在synchronized的里面，相当于加了三把锁，所以是锁不住的
    private int x  =0;
    @Override
    public void run() {
        while (true) {
            if (x % 2 == 0) {
                synchronized (obj) {
                    if (tickets > 0) {
                        try {
                            Thread.sleep(100);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        System.out.println(Thread.currentThread().getName() + "正在出售第" + tickets + "张票。");
                        tickets--;
                    }
                }
            }else{
                synchronized (obj) {
                    if (tickets > 0) {
                        try {
                            Thread.sleep(100);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        System.out.println(Thread.currentThread().getName() + "正在出售第" + tickets + "张票。");
                        tickets--;
                    }
                }
            }
            x++;
        }
    }
}
```

注意：由于if和else语句中执行的是相同的代码块，且上了同一把锁，因此不会出现数据安全问题



**改进：把上面重复的代码写成一个方法：**

抽取出上面的代码：

```java
public class SellTicket implements Runnable{
    private int tickets = 100;
    private Object obj = new Object(); // 必须使用同一个obj，如果把new Object()写在synchronized的里面，相当于加了三把锁，所以是锁不住的
    private int x  =0;
    @Override
    public void run() {
        while (true) {
            if (x % 2 == 0) {
                synchronized (obj) {
                    if (tickets > 0) {
                        try {
                            Thread.sleep(100);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        System.out.println(Thread.currentThread().getName() + "正在出售第" + tickets + "张票。");
                        tickets--;
                    }
                }
            }else{
                selltickets();
            }
            x++;
        }
    }

    public void selltickets(){
        synchronized (obj) {
            if (tickets > 0) {
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + "正在出售第" + tickets + "张票。");
                tickets--;
            }
        }
    }
}
```

这个代码的运行也是没有问题的。从上例可以看出，这个锁是加在方法的里面，那么接下来我们可以把它加载方法上：

```java
public class SellTicket implements Runnable{
    private int tickets = 100;
    private Object obj = new Object(); // 必须使用同一个obj，如果把new Object()写在synchronized的里面，相当于加了三把锁，所以是锁不住的
    private int x  =0;
    @Override
    public void run() {
        while (true) {
            if (x % 2 == 0) {
                synchronized (obj) {
                    if (tickets > 0) {
                        try {
                            Thread.sleep(100);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        System.out.println(Thread.currentThread().getName() + "正在出售第" + tickets + "张票。");
                        tickets--;
                    }
                }
            }else{
                selltickets();
            }
            x++;
        }
    }

    public synchronized void selltickets(){
        if (tickets > 0) {
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + "正在出售第" + tickets + "张票。");
            tickets--;
        }
    }
}
```

从运行结果可以看出，同步并没有成功，是因为加的锁不是同一把，第一个synchronized加的是obj对象，而第二个同步方法加的锁默认是 `this`

因此做以下修改：

```java
public class SellTicket implements Runnable{
    private int tickets = 100;
    private Object obj = new Object(); // 必须使用同一个obj，如果把new Object()写在synchronized的里面，相当于加了三把锁，所以是锁不住的
    private int x  =0;
    @Override
    public void run() {
        while (true) {
            if (x % 2 == 0) {
                synchronized (this) {
                    if (tickets > 0) {
                        try {
                            Thread.sleep(100);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        System.out.println(Thread.currentThread().getName() + "正在出售第" + tickets + "张票。");
                        tickets--;
                    }
                }
            }else{
                selltickets();
            }
            x++;
        }
    }

    public synchronized void selltickets(){
        if (tickets > 0) {
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + "正在出售第" + tickets + "张票。");
            tickets--;
        }
    }
}
```

此时发现，运行结果正常，也说明了同步方法的锁是 `this`

![image-20230404005306506](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202304040053738.png)

![image-20230404005423154](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202304040054239.png)



![image-20230404005818001](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202304040058102.png)



代码演示：

```java
public class SellTicket implements Runnable{
//    private int tickets = 100;
    private static int tickets = 100;
    private Object obj = new Object(); // 必须使用同一个obj，如果把new Object()写在synchronized的里面，相当于加了三把锁，所以是锁不住的
    private int x  =0;
    @Override
    public void run() {
        while (true) {
            if (x % 2 == 0) {
//                synchronized (this) {
                synchronized (SellTicket.class) {
                    if (tickets > 0) {
                        try {
                            Thread.sleep(100);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        System.out.println(Thread.currentThread().getName() + "正在出售第" + tickets + "张票。");
                        tickets--;
                    }
                }
            }else{
                selltickets();
            }
            x++;
        }
    }

//    public synchronized void selltickets(){
//        if (tickets > 0) {
//            try {
//                Thread.sleep(100);
//            } catch (InterruptedException e) {
//                e.printStackTrace();
//            }
//            System.out.println(Thread.currentThread().getName() + "正在出售第" + tickets + "张票。");
//            tickets--;
//        }
//    }
    public static synchronized void selltickets(){
        if (tickets > 0) {
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + "正在出售第" + tickets + "张票。");
            tickets--;
        }
    }
}
```

总结：以上代码说明了静态方法的锁是：**类名.class**



## 9、线程安全的类

![image-20230404010249331](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202304040102524.png)

代码示例：

```java
StringBuilder sb = new StringBuilder();// 线程不安全
StringBuffer sb2 = new StringBuffer();// 线程安全

Vector<String> v = new Vector<>();// 线程安全
ArrayList<String> a = new ArrayList<>();// 线程不安全

Hashtable<Integer, Integer> ht = new Hashtable<>();// 线程安全
HashMap<Integer, Integer> hm = new HashMap<>();// 线程不安全

//        返回由指定列表支持的同步（线程安全）列表。
List<String> objects = Collections.synchronizedList(new ArrayList<>());// 把集合包装成线程安全的类
//        返回由指定地图支持的同步（线程安全）映射。
Map<Integer, Integer> integerIntegerMap = Collections.synchronizedMap(new HashMap<Integer, Integer>());

```



## 10、Lock

![image-20230404011653919](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202304040116033.png)

代码示例：

```java
public class SellTickets implements Runnable{
    private int tickets=100;
    private Lock lock = new ReentrantLock();
    @Override
    public void run() {
        while (true) {
            lock.lock();// 为了避免在下面代码执行的过程中，如果出现问题，导出锁无法释放，因此不经常这么用
            if (tickets > 0) {
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + "正在出售第" + tickets + "张票。");
                tickets--;
            }
            lock.unlock();
        }
    }
}
```

为了避免在锁内部的代码运行过程中，如果出现问题，导出锁无法释放，因此不经常这么用，因此将其改为：在外部加上`try... finally....`

```java
public class SellTickets implements Runnable{
    private int tickets=100;
    private Lock lock = new ReentrantLock();
    @Override
    public void run() {
        while (true) {
            try{
                lock.lock();
                if (tickets > 0) {
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(Thread.currentThread().getName() + "正在出售第" + tickets + "张票。");
                    tickets--;
                }
            } finally {
                lock.unlock();
            }
        }
    }
}
```



## 11、生产者消费者

![image-20230404013003653](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202304040130862.png)

![image-20230404013050011](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202304040130252.png)

![image-20230404013326732](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202304040133984.png)

代码实例：

Box类：

```java
public class Box {
//    表示第几瓶奶
    private int milk;
    // 定义一个变量，表示奶箱的状态
    private boolean state = false;

    //存储牛奶
    public synchronized void put(int milk){
        // 如果有奶，等待消费
        if (state){
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        //如果没有牛奶，就生产牛奶
        this.milk = milk;
        System.out.println("送奶工将第"+this.milk+"瓶奶放入奶箱");

        // 生产完毕之后修改奶箱的状态
        state = true;

        // 唤醒其他的线程
        notifyAll();

    }

    // IllegalMonitorStateException：抛出以表示线程已尝试在对象的监视器上等待或通知其他线程等待对象的监视器，而不拥有指定的监视器
    // 这个监视器可以理解为：锁对象
//    之所以报出这个异常，是因没没有进行原子操作
//    将两个方法加上 synchronized 以进行原子操作。
    public synchronized void get(){
        // 如果没有奶，等待生产
        if (!state){
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
//        如果有奶牛，就消费奶牛
        System.out.println("用户拿到第"+this.milk+"瓶奶");
//      消费完毕之后，修改奶箱状态
        state = false;

        // 唤醒其他线程
        notifyAll();
    }
}
```

Procedurer类：

```java
public class Procedurer implements Runnable {
    private Box b;
    public Procedurer(Box b) {
        this.b = b;
    }

    @Override
    public void run() {
        for (int i=1; i<=5;i++){
            b.put(i);
        }
    }
}
```

Customer类：

```java
public class Customer implements Runnable{
    private Box b;
    public Customer(Box b) {
        this.b = b;
    }

    @Override
    public void run() {
        while (true){
            b.get();
        }
    }
}
```

测试类：

```java
public class BoxDemo {
    public static void main(String[] args) {
        // 创建奶箱对象
        Box b = new Box();

        // 创建生产者对象
        Procedurer p = new Procedurer(b);

        // 创建消费者对象
        Customer c = new Customer(b);

        Thread t1 = new Thread(p);// 消费者线程
        Thread t2 = new Thread(c);// 生成者线程

        // 启动线程
        t1.start();
        t2.start();
    }
}
```

结果输出：

```java
送奶工将第1瓶奶放入奶箱
用户拿到第1瓶奶
送奶工将第2瓶奶放入奶箱
用户拿到第2瓶奶
送奶工将第3瓶奶放入奶箱
用户拿到第3瓶奶
送奶工将第4瓶奶放入奶箱
用户拿到第4瓶奶
送奶工将第5瓶奶放入奶箱
用户拿到第5瓶奶
```









































