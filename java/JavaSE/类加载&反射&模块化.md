# 类加载

![image-20230629194416129](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306291944247.png)

## 类加载

- 类加载的描述

  当程序需要使用某个类时，如果该类还未被加载到内存中，则系统会通过类的加载，类的链接，类的初始化这三个步骤完成类的初始化。如果不出现意外，`JVM` 将会连续完成这三个步骤，所以有时也把这三个步骤统称为类加载或者类初始化。

- 类的加载

  - 就是将class文件读入内存中，并为之创建一个 `java.lang.Class` 对象
  - 任何类被使用时，系统都会为之建立一个 `java.lang.Class` 对象

- 类的连接

  - **验证阶段**：用于检验被加载的类是否有正确的内部结构，并和其他的类协调一致
  - **准备阶段**：负责为类的类变量分配内存，并设置默认初始化值
  - **解析阶段**：将类的二进制数据中的符号引用替换为直接引用

- 类的初始化

  - 在该阶段，主要就是对**类变量**进行初始化

- 类的初始化步骤

  - 假如类还未被加载和连接，则程序先加载并连接该类
  - 假如该类的直接父类还未被初始化，则先初始化其直接父类
  - 假如类中有初始化语句，则系统依次执行这些初始化语句
  - 注意：在执行第二个步骤的时候，系统对直接父类的初始化步骤也遵循初始化步骤1-3

- 类的初始化时机

  - 创建类的实例会初始化该类
  - 调用类的**类方法**
  - 访问类或者接口的**类变量**，或者为该**类变量**赋值
  - 使用反射方式来强制创建某个类或接口对应的 `java.lang.Class`对象
  - 初始化某个类的子类
  - 直接使用 `java.exe`命令来运行某个主类



## 类加载器

### 类加载器的作用

负责将.class文件加载到内存中，并为之生成对应的 `java.lang.Class`对象，虽然我们不用过分关心类加载机制，但是了解这个机制有利于我们更好地理解程序的运行！



### JVM的类加载机制

- 全盘负责：当一个类加载器负责加载某个class时，该class所依赖的和引用的其他Class也将由该类加载器载入，除非显示使用另外一个类加载器载入
- 父类委托：就是当一个类加载器加载某个Class时，先让父类加载器试图加载该Class，只有在父类加载器无法加载该Class时，才尝试从自己的类路径中加载该类。
- 缓存机制：保证所有被加载过的Class都会被缓存，当程序需要使用某个Class对象时，类加载器先从缓冲区中搜索该Class，只有当缓冲区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存储到缓冲区中。



### Java中的内置类加载器

- Bootstrap class loader：它是虚拟机的内置类加载器，通常表示为null，并且没有父null，它是根类加载器。
- Platform class loader：平台类加载器可以看到所有的平台类，平台类包括由平台类加载器或其祖先定义的JavaSE平台API，其实现类和JDK特定的运行时类
- System class loader：它也被称为应用程序类加载器，与平台类加载器不同，系统类加载器通常用于定义应用程序类路径，模块路径和JDK特定工具上的类。
- 类加载器的继承关系：System的父加载器为Platform，而Platform的父加载器为Bootstrap



### ClassLoader中的两个方法

- 方法分类

  | 方法名                                    | 说明                       |
  | ----------------------------------------- | -------------------------- |
  | static ClassLoader getSystemClassLoader() | 返回用于委派的系统类加载器 |
  | ClassLoader getParent()                   | 返回父类加载器进行委派     |

- 实例代码

  ```java
  public class ClassLoaderDemo {
      public static void main(String[] args) {
          // static ClassLoader getSystemClassLoader()：返回用于委派的系统类加载器
          ClassLoader c = ClassLoader.getSystemClassLoader();
          System.out.println(c);// AppClassLoader
  
          ClassLoader c2 = c.getParent();
          System.out.println(c2);// PlatformClassLoader
  
          ClassLoader c3 = c2.getParent();
          System.out.println(c3);// null
      }
  }
  ```

   

# 反射

## 反射的概述

是指在运行期去获取类的变量和方法信息，然后通过获取的信息来**创建对象**，**调用方法**的一种机制。

由于这种动态性，可以极大地增强程序的灵活性，程序不用在编译器就完成确定，在运行期仍然可以扩展。

我们想通过反射去使用一个类，首先我们要获取该类的字节码对象，也就是类型为Class类型的对象



## 获取Class类对象的三种方式

- 类名.class属性
- `对象名.getClass()`方法：该方法是Object类中的方法，所有的Java对象都可以调用该方法
- `Class.forName(全类名)`方法



实例代码：

```java
public class ReflectDemo {
    public static void main(String[] args) throws ClassNotFoundException {
//        使用类的class属性来获取该类对应的Class对象
        Class<Student> c1 = Student.class;
        System.out.println(c1);//class 反射与类加载.Student

        Class<Student> c2 = Student.class;
        System.out.println(c1==c2);// true,一个类在字节中只有一个字节码文件
        System.out.println("-------------------");

        // 调用对象的getClass()方法，返回该对象所属类对应的Class对象
        Student s = new Student();
        Class<? extends Student> c3 = s.getClass();
        System.out.println(c1==c3);//true
        System.out.println("------------------");

        // 使用Class类中的静态方法forName（String className）
        Class<?> c4 = Class.forName("反射与类加载.Student");
        System.out.println(c1==c4);//true
    }
}
```

**总结**：

1. 同一个字节码文件（*.class）在一次程序运行中，只被加载一次，不论通过哪种方式获取的Class对象都是同一个。
2. `Class.forName()`在执行期间发生了什么？会导致类加载，类加载就会执行静态代码块。如果你想让某个类只执行静态代码块，可以使用这个方法。

## 反射获取构造方法并使用

### Class类获取构造方法对象的方法

| 方法名                                                       | 说明                           |
| ------------------------------------------------------------ | ------------------------------ |
| Constructor<?>[] getConstructors()                           | 返回所有公共构造方法对象的数组 |
| Constructor<?>[] getDeclaredConstructors()                   | 返回所有构造方法对象的数组     |
| Constructor getConstructor(Class<?>... parameterTypes)       | 返回单个公共构造方法对象       |
| Constructor getDeclaredConstructor(Class<?>... parameterTypes) | 返回单个构造方法对象           |

**Constructor类用于创建对象的方法**

| 方法名                            | 说明                       |
| --------------------------------- | -------------------------- |
| T newInstance(Object... initargs) | 根据指定的构造方法创建对象 |



代码实例：

```java
package 反射与类加载;

public class Student {

    // 成员变量：一个私有，一个默认，一个公共
    private String name;
    int age;
    public String address;

    // 构造方法：一个私有，一个默认，两个公共


    public Student() {
    }

    private Student(String name) {
        this.name = name;
    }

    Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public Student(String name, int age, String address) {
        this.name = name;
        this.age = age;
        this.address = address;
    }

    // 成员方法：一个私有，四个公共
    private void function(){
        System.out.println("function");
    }
    public void method1(){
        System.out.println("method");
    }
    public void method2(String s){
        System.out.println("method"+s);
    }
    public String method3(String s, int i){
        return s + "," + i;
    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", address='" + address + '\'' +
                '}';
    }
}
```

---

```java
// 获取class对象
Class<?> c = Class.forName("反射与类加载.Student");
// Constructor<?>[] getConstructors() 返回一个包含Constructor对象的数组
// Constructor对象反映了由该class对象表示的类的所有公共构造函数
Constructor<?>[] cons = c.getConstructors();
for (Constructor con: cons){
    System.out.println(con);
}

// 输出
```

```
public 反射与类加载.Student(java.lang.String,int,java.lang.String)
public 反射与类加载.Student()
```

这个方法只能拿到公共的构造方法，私有的和默认的构造方法都没有拿到。

---

```java
// 获取class对象
Class<?> c = Class.forName("反射与类加载.Student");
// Constructor<?>[] getDeclaredConstructors() 返回反映由该对象Class表示的类声明的
// 所有构造函数的 Constructor 对象的数组
Constructor<?>[] cons = c.getDeclaredConstructors();
for (Constructor con: cons){
    System.out.println(con);
}
```

输出：

```
public 反射与类加载.Student()
public 反射与类加载.Student(java.lang.String,int,java.lang.String)
反射与类加载.Student(java.lang.String,int)
private 反射与类加载.Student(java.lang.String)
```

这个方法可以返回所有的构造方法，里面包括公共的构造方法，私有的构造方法，默认的构造方法。

---

```java
// 获取class对象
Class<?> c = Class.forName("反射与类加载.Student");
// Constructor<T> getConstructor(Class<?>... parameterTypes) 返回一个Constructor
// 对象，该对象反映由此 Class 对象表示的类的指定的公共构造函数

// Constructor<T> getDeclaredConstructor(Class<?>... parameterTypes)返回一个Constructor对象，
// 该对象反映由此 Class 对象表示的类或接口的指定构造函数
// 参数：你要获取的构造方法的参数的个数和数据类型对应的字节码文件对象

Constructor<?> con = c.getConstructor();// 获取无参的构造方法

// Constructor 提供了一个类的单个构造函数的信息和访问权限
// T newInstance(Object... initargs) 使用由此 Constructor 对象表示的构造函数，
// 使用指定的初始化参数来创建和初始化 构造函数的声明类的新实例
Object obj = con.newInstance();
System.out.println(obj);
```

输出：

```
Student{name='null', age=0, address='null'}
```

总结：关于反射获取构造方法的使用方法

1. 先使用 `forName`方法获取Class类对象
2. 然后使用 `getConstructor`方法获取具体地单个构造方法
3. 最后使用 `newInstance`方法得到具体的实例



### 反射获取构造方法并使用练习

> **练习1**

通过反射获取共有构造方法并创建对象

学生类如上。

测试类：

```java
public class ReflectDemo2 {
    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {
        // 获取Class对象
        Class<?> c = Class.forName("反射与类加载.Student");
        // public Student(String name, int age, String address)
        // Constructor<?> getConstructor(Class<?>... parameterTypes)
        Constructor<?> con = c.getConstructor(String.class, int.class, String.class);
        // 可以发现：基本数据类型也可以通过.class得到对应的Class类型

        // T newInstance(Object... initargs)
        Object obj = con.newInstance("林青霞",32,"西安");
        System.out.println(obj);
    }
}
```

输出：

```
Student{name='林青霞', age=32, address='西安'}
```



> **练习2**

通过反射获取私有方法并创建对象

代码实现：

```java
public class ReflectDemo3 {
    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {
        Class<?> c = Class.forName("反射与类加载.Student");
        // private Student(String name)
        // Constructor<T> getDeclaredConstructor(Class<?>... parameterTypes)
        Constructor<?> con = c.getDeclaredConstructor(String.class);

        // 暴力反射
        // public void setAccessible(boolean flag):值为true，取消访问检查
        con.setAccessible(true);// 可以访问私有的构造方法

        Object obj = con.newInstance("林青霞");
        System.out.println(obj);
    }
}
```

输出：

```
Student{name='林青霞', age=0, address='null'}
```

总结：在普通的对象实例化中，私有的构造方法是不被允许访问的。但是在反射中，可以使用私有的构造方法进行实例化。



## 反射获取成员变量并使用

| 方法名                                | 说明                           |
| ------------------------------------- | ------------------------------ |
| Field[] getFields()                   | 返回所有公共成员变量对象的数组 |
| Field[] getDeclaredFields()           | 返回所有成员变量对象的数组     |
| Field[] getField(String name)         | 返回单个公共成员变量对象       |
| Field[] getDeclaredField(String name) | 返回单个成员变量的对象         |

---

```java
public class ReflectDemo4 {
    public static void main(String[] args) throws ClassNotFoundException {
        Class<?> c = Class.forName("反射与类加载.Student");

        // Field[] getFields() 返回一个包含 Field对象的数组，Field对象反映 由该Class对象表示的类或接口的所有可访问的公共字段
        // Field[] getDeclaredFields() 返回一个Field对象的数组，反映了由该 Class 对象表示的类或接口声明的所有字段
        Field[] fields = c.getFields();
        for (Field f : fields)
            System.out.println(f);
        System.out.println("---------------");
    }
}
```

输出：

```
public java.lang.String 反射与类加载.Student.address
```

---

```java
public class ReflectDemo4 {
    public static void main(String[] args) throws ClassNotFoundException {
        Class<?> c = Class.forName("反射与类加载.Student");

        // Field[] getFields() 返回一个包含 Field对象的数组，Field对象反映 由该Class对象表示的类或接口的所有可访问的公共字段
        // Field[] getDeclaredFields() 返回一个Field对象的数组，反映了由该 Class 对象表示的类或接口声明的所有字段
        Field[] fields = c.getDeclaredFields();
        for (Field f : fields)
            System.out.println(f);
        System.out.println("---------------");
    }
}
```

输出：

```
private java.lang.String 反射与类加载.Student.name
int 反射与类加载.Student.age
public java.lang.String 反射与类加载.Student.address
```

---

| 方法名                           | 说明                               |
| -------------------------------- | ---------------------------------- |
| void set(Object obj, Object val) | 给obj对象的成员变量赋值为val       |
| Object get(Object obj)           | 返回指定对象上此字段表示的字段的值 |

```java
public class ReflectDemo4 {
    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {
        Class<?> c = Class.forName("反射与类加载.Student");

        // Field[] getFields() 返回一个包含 Field对象的数组，Field对象反映 由该Class对象表示的类或接口的所有可访问的公共字段
        // Field[] getDeclaredFields() 返回一个Field对象的数组，反映了由该 Class 对象表示的类或接口声明的所有字段
//        Field[] fields = c.getFields();
        Field[] fields = c.getDeclaredFields();
        for (Field f : fields)
            System.out.println(f);
        System.out.println("---------------");

        // Field getField(String name) 返回一个Field对象，该对象反映由该 Class 对象表示的类或接口的指定公共成员字段
        // Field getDeclaredField(String name) 返回一个Field对象，该对象反映由该 Class 对象表示的类或接口的指定声明的字段
        Field addressField = c.getField("address");

        // 获取无参构造方法创建对象
        Constructor<?> con = c.getConstructor();
        Object obj = con.newInstance();

//        obj.addressField = "西安";// 这种方式是不对的
        // Field提供有关类或接口的单个字段的信息和动态访问
        // void set(Object obj, Object val)将指定的对象参数中由此 Field对象表示的字段设置为指定的新值
        addressField.set(obj, "西安");
        System.out.println(obj);
    }
}
```

输出：

```
private java.lang.String 反射与类加载.Student.name
int 反射与类加载.Student.age
public java.lang.String 反射与类加载.Student.address
---------------
Student{name='null', age=0, address='西安'}
```



> **练习**

```java
public class ReflectDemo5 {
    public static void main(String[] args) throws NoSuchMethodException, ClassNotFoundException, InvocationTargetException, InstantiationException, IllegalAccessException, NoSuchFieldException {
        // 获取Class对象
        Class<?> c = Class.forName("反射与类加载.Student");

        // Student s = new Student()
        Constructor<?> con = c.getConstructor();
        Object obj = con.newInstance();
        System.out.println(obj);// 输出：Student{name='null', age=0, address='null'}

        // s.name = "林青霞"
//        Field nameField = c.getField("name");// NoSuchFieldException:name
        Field nameField = c.getDeclaredField("name");
        nameField.setAccessible(true);
        nameField.set(obj, "林青霞");
        System.out.println(obj);

        // s.age = 30
        Field ageField = c.getDeclaredField("age");
        ageField.setAccessible(true);// 如果不是私有的话，这个地方可以省略
        ageField.set(obj, 30);
        System.out.println(obj);

        // s.address = "西安"
//        Field addressField = c.getField("address");
        Field addressField = c.getDeclaredField("address");
        addressField.setAccessible(true);// 如果不是私有的话，这个地方可以省略
        addressField.set(obj, "西安");
        System.out.println(obj);
    }
}
```

输出：

```
Student{name='null', age=0, address='null'}
Student{name='林青霞', age=0, address='null'}
Student{name='林青霞', age=30, address='null'}
Student{name='林青霞', age=30, address='西安'}
```



## 反射获取成员方法并使用

### Class类获取成员方法对象的方法

| 方法名                                                       | 说明                                       |
| ------------------------------------------------------------ | ------------------------------------------ |
| Method[] getMethods()                                        | 返回所有公共成员方法对象的数组，包括继承的 |
| Method[] getDeclaredMethods()                                | 返回所有成员方法对象的数组，不包括继承的   |
| Method getMethod(String name, Class<?>... parameterTypes)    | 返回单个公共成员方法对象                   |
| Method getDeclaredMethod(String name, Class<?>... parameterTypes) | 返回单个成员方法对象                       |

```java
public class ReflectDemo6 {
    public static void main(String[] args) throws ClassNotFoundException {
        Class<?> c = Class.forName("反射与类加载.Student");

        Method[] methods = c.getMethods();// 包括继承的所有公共方法
        for (Method m: methods)
            System.out.println(m);

        System.out.println("--------------");
    }
}
```

输出：

```
public java.lang.String 反射与类加载.Student.toString()
public void 反射与类加载.Student.method1()
public java.lang.String 反射与类加载.Student.method3(java.lang.String,int)
public void 反射与类加载.Student.method2(java.lang.String)
public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException
public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException
public final void java.lang.Object.wait() throws java.lang.InterruptedException
public boolean java.lang.Object.equals(java.lang.Object)
public native int java.lang.Object.hashCode()
public final native java.lang.Class java.lang.Object.getClass()
public final native void java.lang.Object.notify()
public final native void java.lang.Object.notifyAll()
--------------
```

---

```java
public class ReflectDemo6 {
    public static void main(String[] args) throws ClassNotFoundException {
        Class<?> c = Class.forName("反射与类加载.Student");

//        Method[] methods = c.getMethods();// 包括继承的所有公共方法
        Method[] methods = c.getDeclaredMethods();
        for (Method m: methods)
            System.out.println(m);

        System.out.println("--------------");
    }
}
```

输出：

```
public java.lang.String 反射与类加载.Student.toString()
private void 反射与类加载.Student.function()
public void 反射与类加载.Student.method1()
public java.lang.String 反射与类加载.Student.method3(java.lang.String,int)
public void 反射与类加载.Student.method2(java.lang.String)
--------------
```

---

```java
public class ReflectDemo6 {
    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {
        Class<?> c = Class.forName("反射与类加载.Student");

//        Method[] methods = c.getMethods();// 包括继承的所有公共方法
        Method[] methods = c.getDeclaredMethods();
        for (Method m: methods)
            System.out.println(m);

        System.out.println("--------------");

//        Method m = c.getMethod("method1");
        Method m = c.getMethod("method2", String.class);
        Constructor<?> con = c.getConstructor();
        Object obj = con.newInstance();

        // 在类或接口上提供单一的信息和访问权限
        // Object invoke(Object obj, Object... args)在具有指定参数的指定对象上调用此方法
        // 对象表示的基础方法
        // Object: 返回值类型
        // obj: 调用方法的对象
        // args: 方法需要的参数
        m.invoke(obj, "hello");
    }
}
```

输出：

```
public void 反射与类加载.Student.method2(java.lang.String)
public java.lang.String 反射与类加载.Student.method3(java.lang.String,int)
public void 反射与类加载.Student.method1()
public java.lang.String 反射与类加载.Student.toString()
private void 反射与类加载.Student.function()
--------------
methodhello
```

| 方法名                                    | 说明                                              |
| ----------------------------------------- | ------------------------------------------------- |
| Object invoke(Object obj, Object... args) | 调用obj对象的成员方法，参数是args，返回值是Object |

> **练习**

```java
public class ReflectDemo7 {
    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {
        Class<?> c = Class.forName("反射与类加载.Student");

        Constructor<?> con = c.getConstructor();
        Object obj = con.newInstance();

        Method m1 = c.getMethod("method1");
        m1.invoke(obj);

        Method m2 = c.getMethod("method2", String.class);
        m2.invoke(obj, "林青霞");

        Method m3 = c.getMethod("method3", String.class, int.class);
        Object o = m3.invoke(obj, "林青霞", 30);
        System.out.println(o);

        //function
        Method function = c.getDeclaredMethod("function");
        function.setAccessible(true);
        function.invoke(obj);
    }
}
```

输出：

```
method
method林青霞
林青霞,30
function
```



## 反射的案例

### 反射练习之越过泛型检查

通过反射技术，向一个泛型为Integer的集合中添加一些字符串数据

```java
public class ReflectDemo8 {
    public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {
        ArrayList<Integer> arrayList = new ArrayList<>();

        Class<? extends ArrayList> c = arrayList.getClass();
        Method m = c.getMethod("add", Object.class);

        m.invoke(arrayList, "hello");
        m.invoke(arrayList, "world");
        m.invoke(arrayList, "java");
        m.invoke(arrayList, "python");
        System.out.println(arrayList);
    }
}
```

输出：

```
[hello, world, java, python]
```



### 运行配置文件中指定类的指定方法

通过反射技术，运行配置文件中指定类的指定方法

```java
class文件
className=reflectdemo.Student
methodName=study
    
public class Student {
    public void study(){
        System.out.println("好好学习，天天向上");
    }
}

public class Teacher {
    public void teach(){
        System.out.println("用爱成就学员！");
    }
}

public class ReflectDemo01 {
    public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {
//        Student s = new Student();
//        s.study();
//
//        Teacher t = new Teacher();
//        t.teach();

        /*
        * class.txt
        *   className=xxx
        *   methodName=xxx
        *
        * */
        // 加载数据
        Properties prop = new Properties();
        FileReader fr = new FileReader("class");
        prop.load(fr);
        fr.close();

        String className = prop.getProperty("className");
        String methodName = prop.getProperty("methodName");

        Class<?> c = Class.forName(className);
        Constructor<?> con = c.getConstructor();
        Object obj = con.newInstance();

        Method m = c.getMethod(methodName);
        m.invoke(obj);
    }
}
```







# 模块化

## 模块化概述

Java语言随着这些年的发展已经成为了一门影响深远的编程语言，无数平台，系统都采用Java语言编写程序。但是，伴随着发展，Java也越来越庞大，逐渐发展成为一门 ”臃肿“的语言。而且无论运行一个大型的软件系统，还是运行一个小的程序，即使程序只需要使用Java的部分核心功能，JVM也要加载整个JRE环境，为了给Java”瘦身“，让Java实现轻量化，Java9正式推出模块化系统。Java拆分为N多个模块，并允许Java程序可以根据需要选择加载程序必须的Java模块，这样就可以让Java以轻量化的方式来运行。

其实，Java7的时候已经推出了模块化的概念，但是由于过于复杂，Java7，Java8都一直未能真正退出，直到Java9才真正成熟起来。对于Java语言来说，模块化系统是一次真正的自我革新，这种革新使得“古老而庞大”的Java语言重新焕发年轻的活力。

![image-20230629144022298](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306291440490.png)





## 模块的基本使用

模块使用的基本步骤

- 创建模块（创建模块，创建包，创建类，定义方法）
  - 为了体现模块的使用，我们创建2个模块，一个是`myOne`，另一个是`myTwo`
- 在模块的`src`目录下新建一个名为 `module-info.java`的描述性文件，该文件专门定义模块名，访问权限，模块依赖等信息
  - 描述性文件中使用模块到处和模块依赖来进行配置并使用
- 模块中所有未导出的包都是模块私有的，他们是不能在模块外被访问的
  - 在`myOne`这个模块下的描述性文件中配置模块导出
  - 模块导出格式：`exports 包名`
- 一个模块要访问其他的模块，必须明确指定依赖哪些模块，未明确指定依赖的模块不能访问
  - 在myTwo这个模块下的描述性文件中配置模块依赖
  - 模块依赖的格式：`requires 模块名`
  - 注意：写模块名报错，需要按下 `Alt+Enter`提示，然后选择模块依赖

创建的项目截图如下：

![image-20230629163419298](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306291634381.png)

![image-20230629163442776](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306291634850.png)

![image-20230629163501297](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306291635393.png)



几点注意事项：

1. 创建了一个新项目之后，需要在 `File--->Project structure`中配置模块的`jdk`版本

   ![image-20230629162746488](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306291627579.png)

2. 如果`myTwo`不能引入`myOne`的模块，常常报一下两种错误时：

   1. `java`: 错误: 不支持发行版本 20

      此时需要检查Java编译器的版本与 `Project Structure`中模块的Java版本是否一致

      ![image-20230629163018175](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306291630263.png)

   2. java: 找不到模块

      此时需要检查所依赖的模块是否真的被引入，可以打开 File——>Project Structure进行检查

      ![image-20230629163258303](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306291632395.png)

      

## 模块服务的基本使用

1、在myOne模块中新建一个包，提过一个接口和两个实现类

![image-20230629165415978](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306291654076.png)

2、在myOne模块中修改 module-info.java文件，添加如下内容：

![image-20230629165512606](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306291655683.png)

3、在myTwo模块中修改 module-info.java 文件，添加内容如下：

![image-20230629165627614](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306291656680.png)

4、在myTwo模块中新建一个测试类

![image-20230629170502192](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306291705276.png)

输出：

```
学IT，来黑马！
```



注意：如果想执行两个或多个的话，可以使用如下方式

![image-20230629170659760](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306291706830.png)

此时输出：

```
学IT，来黑马！
上大学，来传智学院，一所不一样的大学，收货不一样的你！
```
