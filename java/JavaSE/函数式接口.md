# 函数式接口

## 1.1 函数式接口概述

函数式接口有且仅有一个抽象方法的接口

Java中的函数式编程体现的就是Lambda表达式，所以函数式接口就是可以适用于Lambda使用的接口，只有确保接口中有且仅有一个抽象方法，Java中的Lambda才能顺利地进行推导

- 概念

  有且仅有一个抽象方法的接口

- 如何检测一个接口是不是函数式接口

  @FunctionalInterface

  放在定义接口的上方：如果接口是函数式接口，编译通过；如果不是函数式接口，则编译失败。

- 注意事项

  我们自己定义函数式接口的时候，@FunctionalInterface是可选的，就算我们不写这个注解，只要保证了函数式接口的规范，也照样是函数式接口。但是，建议加上。

```java
@FunctionalInterface
public interface MyInter {
    void show();
//    void m();
}


public class MyInterfaceDemo {
    public static void main(String[] args) {
        // 这个就相当于重写了show方法
        MyInter my = () -> System.out.println("函数是接口");
        my.show();
    }
}
```

总结：**函数式接口可以使用Lambda表达式的形式进行编写**



## 1.2 函数式接口作为方法的参数

- 需要分析

  定义一个类（RunnableDemo），在类中提供两个方法

  一个方法是：startThread(Runnable r)方法参数Runnable是一个函数式接口

  一个方法是主方法，在主方法中调用startThread方法

- 代码演示

  ```java
  public class RunnableDemo {
      public static void main(String[] args) {
          // 匿名内部类
          startThread(new Runnable() {
              @Override
              public void run() {
                  System.out.println(Thread.currentThread().getName() + "线程启动了。");
              }
          });
  
          startThread(()-> System.out.println(Thread.currentThread().getName()+"线程启动了"));
  
      }
      private static void startThread(Runnable r){
  //        Thread t = new Thread(r);
  //        t.start();
  
          new Thread(r).start();
      }
  }
  ```

注意：如果方法的**参数是一个函数式接口**，我们可以使用Lambda表达式作为参数传递

- `startThread(()->System.out.println(Thread.currentThread().getName()+"线程启动了") );`

- Runnable就是一个函数式接口



## 1.3 函数式接口作为方法的返回值

需求

- 定义一个类（ComparatorDemo），在类中提供两个方法

  一个方法是：Comparator<String> getComparator() 方法返回值Comparator是一个函数式接口

  一个方法是主方法，在主方法中调用getComparator方法

- 代码演示

  ```java
  public class ComparatorDemo {
      public static void main(String[] args) {
          // 定义集合，存储字符串元素
          ArrayList<String> arr = new ArrayList<>();
          arr.add("cccc");
          arr.add("aa");
          arr.add("b");
          arr.add("ddd");
          System.out.println("排序前"+arr);
          Collections.sort(arr, getComparator());
          System.out.println("排序后"+arr);
      }
      private static Comparator<String> getComparator(){
          // 匿名内部类
  //        return new Comparator<String>() {
  //            @Override
  //            public int compare(String o1, String o2) {
  //                return o1.length() - o2.length();
  //            }
  //        };
          // 如果方法的返回值是一个接口，我们可以使用Lambda表达式作为结果返回
          return (s1, s2)->s1.length() - s2.length();
      }
  }
  ```

  注意：**如果方法的返回值是一个函数式接口，我们可以使用Lambda表达式作为结果返回。**

  ```java
  private static Comparator<String> getComparator(){
      return (s1, s2)->s1.length() - s2.length();
  }
  ```

  

## 1.4 常用的函数式接口

`Java8`在`java.util.function`包下预定义了大量的函数式接口供我们使用

重点学习下面的4个接口：

- Supplier接口
- Consumer接口
- Predicate接口
- Function接口



### 1.4.1 Supplier接口

Supplier<T>:包含一个无参的方法

- T get(): 获得结果
- 该**方法不需要参数**，它会按照某种实现逻辑（由Lambda表达式实现）返回一个数据
- Supplier<T>接口也被称为生产型接口，如果我们指定了接口的泛型是什么类型，那么接口中的get方法就会返回什么类型的数据供我们使用

```java
public class SupplierDemo {
    public static void main(String[] args) {
//        String s = getString(()->{
//            return "林青霞";
//        });
        String s = getString(()->"林青霞");
        System.out.println(s);

        System.out.println(getInteger(()->12));
    }

    private static String getString(Supplier<String> supplier){
        return supplier.get();
    }

    private static Integer getInteger(Supplier<Integer> sup){
        return sup.get();
    }
}
```

总结：

- `getString`方法的参数是函数式接口，我采用了Lambda表达式作为参数进行传递
- 我在调用`getString`这个方法的时候，传入的是Lambda形式的参数
- 由于`getString`方法有返回值，因此我使用 `String s` 进行接收。
- lambda表达式里面的返回值，其实是具体抽象方法的返回值。



> 练习

定义一个类（`SupplierTest`），在类中提供两个方法

1、一个方法是：int `getMax`(Supplier<Integer> sup) 用于返回int数组中的最大值

2、一个方法是主方法，在主方法中调用`getMax`方法

```java
public class SupplierTest {
    public static void main(String[] args) {
        int[] arr = {19,40,28,37,46};
        // lambda
        // 手动实现具体的代码逻辑
        Integer maxValue = getMax(()->{
           int max = arr[0];
           for (int i=0; i< arr.length; i++)
               if (arr[i]>max)
                   max = arr[i];
           return max;
        });

        System.out.println(maxValue);
    }
    private static Integer getMax(Supplier<Integer> sup){
        return sup.get();
    }
}
```

总结：**其实get方法中的具体的代码还是得我们自己去实现，用lambda实现。**



### 1.4.2 Consumer接口

Consumer<T>：包含两个方法

- void accept(T t)：对**给定的参数**执行此操作
- default Consumer<T> `andThen(Consumer<? super T> after)` ：返回一个组合的 `Consumer` ，按顺序执行该操作，然后执行 `after`操作。如果任一操作抛出异常，那么它将会被转发到组和操作的调用者，且after操作将不会被执行。
- Consumer<T>接口也被称为消费型接口，它消费的数据的数据类型由泛型指定

```java
public class ConsumerDemo {
    public static void main(String[] args) {
        // lambda
        operatorString("林青霞", s-> System.out.println(s));
        operatorString("林青霞", System.out::println);
        operatorString("林青霞", s->{
            System.out.println(new StringBuilder(s).reverse().toString());
        });
        operatorString("林青霞", s-> System.out.println(new StringBuilder(s).reverse().toString()));

        System.out.println("------------------");
        operatorString("林青霞",s-> System.out.println(s), s-> System.out.println(new StringBuilder(s).reverse().toString()));

    }

    // 用不同的方式，消费同一个字符串两次
    private static void operatorString(String name, Consumer<String> con1, Consumer<String> con2){
//        con1.accept(name);
//        con2.accept(name);
        con1.andThen(con2).accept(name);// 这个代码的作用，和上面的两步的效果其实是一样的
    }

    private static void operatorString(String name, Consumer<String> con){
        con.accept(name);
    }
}
```

总结：

1、accept实际上是接受一个参数，然后交给accept方法进行使用，因此Consumer<T>函数式接口实际上是一个**带参且无返回值**的函数式接口

2、上面代码中的lambda表达式实际上是对accept函数的实现

3、一个方法可以同时带**其他参数**和**函数式接口**这两种参数

4、在Consumer<T>接口中，可以实现多个Consumer的组合使用，如果任一操作抛出异常，它将会被转发到组合操作的调用者，并且after将不会被执行。



> **练习**

![image-20230617180756948](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306171807033.png)

```java
public class ConsumerTest {
    public static void main(String[] args) {
        String[] strArr = {"林青霞, 30", "张曼玉, 32", "王祖贤, 34"};
        for (String s:strArr){
            operatorString(s, ss->{// 注意这个地方的ss相当于是一个变量名，不能和已经声明的变量重名
                String[] slist = ss.split(",");
                System.out.print("姓名："+slist[0]+",");
            }, ss->{
                String[] slist = ss.split(",");
                System.out.println("年龄："+slist[1]);
            });
        }

        System.out.println("---------------------");
        operatorString1(strArr, sa->{
            String[] slist = sa.split(",");
            System.out.print("姓名："+slist[0]+",");
        }, sa->{
            String[] slist = sa.split(",");
            System.out.println("年龄："+slist[1]);
        });
        System.out.println("---------------------");
        operatorString1(strArr, sa->
            System.out.print("姓名："+sa.split(",")[0]+","), sa->
            System.out.println("年龄："+sa.split(",")[1]));

    }

    private static void operatorString(String str, Consumer<String> con1, Consumer<String> con2){
        con1.andThen(con2).accept(str);
    }
    private static void operatorString1(String[] str, Consumer<String> con1, Consumer<String> con2){
        for (String s: str){
            con1.andThen(con2).accept(s);
        }

    }
}
```

输出：

```java
姓名：林青霞,年龄： 30
姓名：张曼玉,年龄： 32
姓名：王祖贤,年龄： 34
---------------------
姓名：林青霞,年龄： 30
姓名：张曼玉,年龄： 32
姓名：王祖贤,年龄： 34
---------------------
姓名：林青霞,年龄： 30
姓名：张曼玉,年龄： 32
姓名：王祖贤,年龄： 34
```

总结：

1、注意，在使用lambda表达式进行传参时，参数不能和已经声明的参数重名，因此lambda里面的参数也是重新声明的，否则会报错；



### 1.4.3 Predicate接口

Predicate<T>：常用的是个方法

- boolean test<T t>：对给定的参数进行判断（判断逻辑由Lambda表达式实现），返回一个boolean值
- default Predicate <T> negate()：返回一个逻辑的否定，对应逻辑非
- default Predicate<T> and(Predicate other)：返回一个组合判断，对应短路与
- default Predicate<T> or(Predicate other)：返回一个组合判断，对应逻辑或
- Predicate<T>接口通常用于判断参数是否满足指定的条件

```java
public class PredicateDemo1 {
    public static void main(String[] args) {
//        boolean b1 = checkString("hello", (String s)->{
//            return s.length()>8;
//        });
        boolean b1 = checkString("hello", s -> s.length()>8);
        System.out.println(b1);

        boolean b2 = checkString("helloworld", s -> s.length()>8);
        System.out.println(b2);
    }

    // 判断给定的字符串是否满足要求
    private static boolean checkString(String s, Predicate<String> pre){
//        return pre.test(s);// 具体的判断逻辑由lambda实现
        // 取逻辑非
//        return !pre.test(s);
        return pre.negate().test(s);// 取逻辑非
    }
}
```

总结：

1、test方案的具体实现由lambda实现

2、取非时可以先使用negate方法，然后再用test判断，negate方法的源码也是取逻辑非的



```java
public class PredicateDemo1 {
    public static void main(String[] args) {
//        boolean b1 = checkString("hello", (String s)->{
//            return s.length()>8;
//        });
        boolean b1 = checkString("hello", s -> s.length()>8);
        System.out.println(b1);

        boolean b2 = checkString("helloworld", s -> s.length()>8);
        System.out.println(b2);

        System.out.println("--------------------------------");
        boolean b3 = checkString("hello", s->s.length()>8, s->s.length()<15);
        System.out.println(b3);

        boolean b4 = checkString("helloworld", s->s.length()>8, s->s.length()<15);
        System.out.println(b4);
    }

    // 同一个字符串给出两种不同的判断条件，最后把两种结果的逻辑运算的结果作为最终的结果
    private static boolean checkString(String s, Predicate<String> pre1, Predicate<String> pre2){
//        boolean b1 = pre1.test(s);
//        boolean b2 = pre2.test(s);
//        boolean b = b1 && b2;
//        return b;
//        return pre1.and(pre2).test(s);
        return pre1.or(pre2).test(s);
    }

    // 判断给定的字符串是否满足要求
    private static boolean checkString(String s, Predicate<String> pre){
//        return pre.test(s);// 具体的判断逻辑由lambda实现
        // 取逻辑非
//        return !pre.test(s);
        return pre.negate().test(s);// 取逻辑非
    }
}
```

注意：

1、可以对`Predicate`进行组合使用，组合以后重新调用`test`方法即可进行判断

2、`Predicate`中的`and`和`or`方法的底层也是用逻辑与 `&&` 和 `||`实现的。



> **练习**

![image-20230617225606082](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306172256183.png)

```java
public class PredicateDemo2 {
    public static void main(String[] args) {
        String[] strArr = {"林青霞, 37", "柳岩, 34", "张曼玉, 35", "貂蝉, 31", "王祖贤, 33"};
        ArrayList<String> arr = new ArrayList<>();
        for (String s: strArr){
            boolean f = checkCondition(s, s1->{
                String name = s1.split(",")[0];
                return name.length()>2;
            }, s1 -> {
                int age = Integer.parseInt(s1.split(",")[1].strip());
                return age>33;
            });

            if (f)
                arr.add(s);
        }

        for (String s: arr){
            System.out.println(s);
        }

    }

    private static boolean checkCondition(String str, Predicate<String> pre1, Predicate<String> pre2){
        return pre1.and(pre2).test(str);
    }
}
```

另一种写法：

```java
public class PredicateDemo3 {
    public static void main(String[] args) {
        String[] strArr = {"林青霞, 37", "柳岩, 34", "张曼玉, 35", "貂蝉, 31", "王祖贤, 33"};
        ArrayList<String> arr = checkString(strArr, s -> s.split(",")[0].length()>2, s-> Integer.parseInt(s.split(",")[1].strip()) > 33);
        for (String a: arr){
            System.out.println(a);
        }
    }

    private static ArrayList<String> checkString(String[] strArr, Predicate<String> pre1, Predicate<String> pre2){
        ArrayList<String> arr = new ArrayList<>();

        for (String s: strArr){
            if (pre1.and(pre2).test(s)){
                arr.add(s);
            }
        }

        return arr;
    }
}
```



### 1.4.4 Function接口

Function<T, R>：常用的两个方法

- R apply(T t)：将此函数应用于给定的参数
- default <V> Function `andThen(Function after)`：返回一个组合函数，首先将该函数应用于输入，然后将after函数应用于结果
- Function<T, R>接口通常用于对参数进行处理，转换(处理逻辑由Lambda表达式实现)，然后返回一个新的值

```java
public class FunctionDemo1 {
    public static void main(String[] args) {
        convert("12", str -> Integer.parseInt(str));
        convert("12", Integer::parseInt);
        System.out.println("-------------------");

        convert(100, i->String.valueOf(i+566));
        System.out.println("-----------------------");
        convert("100", Integer::parseInt, i-> String.valueOf(i+566));
    }

    //定一个方法，把一个字符串转换为int类型，在控制台输出
    private static void convert(String s, Function<String, Integer> fun){
//        Integer i = fun.apply(s);
        int i = fun.apply(s);
        System.out.println(i);
    }

    // 定义一个方法，把一个int类型的数据加上一个整数之后，转为字符串在控制台输出
    private static void convert(int i, Function<Integer, String> fun){
        String apply = fun.apply(i);
        System.out.println(apply);
    }
    // 定义一个方法，把一个字符串转为int类型，加上一个整数之后，转为字符串类型
    private static void convert(String s, Function<String, Integer> fun1, Function<Integer, String> fun2){
//        Integer i = fun1.apply(s);
//        String ss = fun2.apply(i);
//        System.out.println(ss);
        String ss = fun1.andThen(fun2).apply(s);
        System.out.println(ss);
    }
}
```

> **练习**

![image-20230618085110029](https://raw.githubusercontent.com/lqyspace/mypic/master/PicBed/202306180851117.png)

```java
public class FunctionDemo2 {
    public static void main(String[] args) {
        String s = "林青霞,30";
        //lambda
        getInteger(s, (String ss)->{
            return s.split(",")[1];
        }, (String ss)->{
            return Integer.parseInt(ss);
        }, (Integer i)->{
            return i+70;
        });
        // lambda
        getInteger(s, ss->s.split(",")[1], ss->Integer.parseInt(ss), i->i+70);
        //方法引用
        getInteger(s, ss->s.split(",")[1], Integer::parseInt, i->i+70);
    }

    private static void getInteger(String str, Function<String, String> fun1, Function<String, Integer> fun2, Function<Integer, Integer> fun3){
        int res = fun1.andThen(fun2).andThen(fun3).apply(str);
        System.out.println(res);
    }
}
```



































































