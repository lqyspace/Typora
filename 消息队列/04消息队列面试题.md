[TOC]

# 1、消息队列如何保证消息可靠传输

消息可靠传输代表了两层意思，既不能多也不能少。

为了保证消息不多，也就是消息不能重复，也就是生产者不能重复的生产消息，或消费者不能重复消费消息：

- 首先要确保消息不多发，这个不常出现，也比较难控制，因为如果出现了多发，很大的原因是生产者自己的原因，如果要避免出现问题，就需要在消费端做控制
- 要避免不重复消费，最保险的机制就是消费者实现幂等性，保证就算重复消费，也不会有问题，通过幂等性，也能解决生产者重复发送消息的问题

消息不能少，意思就是消息不能丢失，生产者发送的消息，消费者一定要能消费到，对于这个问题，就要考虑两个方面：

- 生产者发送消息时，要确认broker确实收到并持久化了这条消息，比如RabbitMQ的confirm机制，Kafka的ack机制都可以保证生产者能正确的将消息发送给broker
- broker要等待消费者真正确认消费到了消息时才删除掉消息，这里通常就是消费端ack机制，消费者接收到一条消息后，如果确认没问题了，就可以给broker发送一个ack，broker接收到ack后才会删除消息



# 2、如何实现幂等性





# 3、消息队列有哪些作用

- 解耦：使用消息队列作为两个系统直接的通讯方式，两个系统不需要相互依赖了
- 异步：系统A给消费队列发送完消息之后，就可以继续做其他的事情了
- 流量削峰：如果使用消息队列的方式来调用某个系统，那么消息将在队列中排队，由消费者自己控制消费速度



# 4、如何保证消息不被重复消费

幂等：一个数据或者一个请求，重复来多次，确保对应的数据是不会改变的，不能出错。

思路：

- 如果是redis，就没有问题，反正每次都是set，天然幂等性
- 生产者发送消息的时候带上一个全局唯一的id，消费者拿到这个消息之后，现根据这个ID去redis里面查一下，之前有没有在消费过，如果没有消费就处理，并且写入这个id到redis，如果消费过了就不处理。
- 基于数据库的唯一键



# 5、消息队列的优缺点、使用场景

优点：

- 解耦：降低系统之间的依赖
- 异步：不需要同步等待
- 流量削峰填谷：如果使用消息队列的方式来调用某个系统，那么消息将在队列中排队，由消费者自己控制消费速度；将流量从高峰期引到低谷期进行处理（主要是通过将任务放在MQ队列里，将峰值的请求放到MQ里，等待低谷期时就可以尽情处理那些队列里面的任务）



缺点：

- 增加了系统的复杂性，幂等、重复消费、消息丢失等问题的带入
- 系统的可用性降低，MQ的故障会影响系统的可用性
- 一致性，消费端可能失败



**使用场景**：日志采集、发布订阅等



# 6、死信队列是什么，延时队列是什么

1、死信队列也是一个消息队列，它是用来存放那些没有成功消费的消息的，通常可以用来作为消息重试

2、延时队列就是用来存放需要在指定时间被处理的消息的队列，通常用来处理一些具有过期性操作的业务，比如10分钟内未支付则取消订单



# 7、简述kafka的rebalance机制

consumer group中的消费者与topic下的partition重新匹配的过程

何时会产生rebalance：

- consumer group 中的成员个数发生变化
- consumer消费超时
- group 订阅的topic个数发生变化
- group订阅的topic的分区数发生变化



coordinator：通常是partition的leader节点所在的broker，负责监控group中的consumer的存活，consumer维持到coordinator的心跳，判断consumer的消费超时

- coordinator通过心跳返回通知consumer进行rebalance
- consumer请求coordinator加入组，coordinator选举产生leader consumer
- leader consumer从coordinator获取所有的consumer，发送syncGroup（分配信息）给到coordinator
- coordinator通过心跳机制将syncGroup下发给consumer
- 完成rebalance

coordinator负责监控group中consumer的存活，并不知道topic，partition的变化；leader consumer监控topic的变化，通知coordinaor触发rebalance。

**可能存在以下错误：**

如果C1消费消息超时，触发了rebalance，重新分配后，该消息有可能会被其他的消费者C2消费，但是此时C1消费者把该消息消费完成提交了offset，那么C2在提交时就会触发错误。

解决：coordinator每次rebalance，会标记一个Generation给到consumer，每次rebalance该Generation会+1，consumer提交offset时，coordinator会对比Generation，不一致则拒绝提交。



# 8、简述Kafka的副本同步机制

一般来说leader进行读写请求，follow一般来说不进行客户端请求，follow一般来说只负责同步数据，当leader挂了以后，follow才开始选举新的leader来处理客户端的请求。

![image-20240329165048847](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202403291650926.png)

LEO：下一条待写入的位置

firstUnstableOffset：第一条未提交的数据

LastStableOffset：最后一条已提交的数据

LogStartOffset：起始位置

isolation.level=read_committed：只能消费到LastStableOffset，read_uncommited可以消费到HM的的上一条数据。

一个partition对应的ISR（ISR是一个链表，维护一个最小的HW，ISR中维护若干个follow和一个leader）中最小的LEO作为分区的HW，consumer最多只能消费到HW所在的位置

leader收到写消息后会**更新本地的LEO**，**leader还会维护follower的LEO即远程LEO**，即**follower发出fetch同步数据请求时（携带自身的LEO）、leader会更新remote LEO**，更新分区的HW，然后将数据响应给follower，follower更新自身HW（取响应中的HW和自身的LEO中的较小值），LEO+1

ISR：如果一个follower落后于leader不超过某个时间的阈值，那么则在ISR中，否则将放在OSR中。



同步副本时，follower获取leader的LEO和LogStartOffset，与本地对比、如果本地的LogStartOffset超出了leader的值，则超过这个值的数据删除，再进行同步，如果本地的小于leader的，则直接同步



# 9、kafka的架构设计

![image-20240329174631503](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202403291746544.png)

- producer：发布消息的对象称之为主题生产者（Kafka topic producer），向kafka broker发消息
- topic：KafKa将消息分门别类，每一类的消息称之为一个主题（Topic），理解为一个队列
- consumer：订阅消息并发布消息的对象称之为主题消费者（Consumer），向kafka broker获取消息。
- broker：一台broker就是一台服务器。已发布的消息保存在一组服务器中，称之为Kafka集群。消费者可以订阅一个或多个主题（topic），并从kafka拉取数据，从而消费这些已经发布的消息。
- Consumer Group（CG）：消费者组，由多个consumer组成。**消费者组内每个消费者负责消费不同分区的数据，一个分区只能由一个组内一个或多个消费者消费；消费者组之间互不影响。所有的消费者都属于某个消费者组，即消费者组是逻辑上的一个订阅者。**
- partition：为了实现扩展性，一个非常大的topic可以分布到多个broker（即服务器）上，**一个topic可以分成多个partition**，每个**partition是一个有序队列。**（100T数据在topicA中放不下，放在多个服务器上同一个主题的不同分区中）
- replica：副本。一个topic的每个分区都有若干个副本，一个Leader和若干个Follower。
- leader：每个分区多个副本的“主”，生产者发送数据的对象，以及消费者消费数据的对象都是 Leader。
- follower：每个分区多个副本中的“从”，实时从 Leader 中同步数据，保持和Leader 数据的同步。Leader 发生故障时，某个 Follower 会成为新的 Leader——主备模式，follow一般不起作用，平时从leader上拉取数据。读写请求都是在leader上进行。
- **zookeeper**：记录集群中哪些broker在服务，记录leader副本的信息；（经典版本中是由ZK的，但是高版本取消了ZK）

consumer3和consumer4可以同时消费同一个分区，不过这两个消费者存在互斥关系，当消息发送到consumer3上时就不会给consumer4发送，当消费发送到consumer4就不会给consumer3发送，从而形成互斥。所以consumer3和consumer4逻辑上是一个消费者。形成负载均衡。
