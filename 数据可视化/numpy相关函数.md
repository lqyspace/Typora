[TOC]
# numpy 相关函数

## numpy.floor()
> 作用

    返回不大于输入参数的最大整数

```python
import numpy as np

print(np.floor(3.4))
print(np.floor(3.6))

-----输出结果------
3.0
3.0
```

## numpy.random.random([num])
> 作用

    随机生成0到1的数或者数组

```python
print(np.random.random())
print(np.random.random(3))

-----输出------
0.9263847668228068
[0.31964098 0.6513603  0.3222023 ]
```

## numpy.array()

> 作用

    一言以蔽之，生成数组

参见两个博客：
[python中数组（numpy.array）的基本操作](https://blog.csdn.net/fu6543210/article/details/83240024)

[Numpy.array()详解 、np.array与np.asarray辨析、 np.array和np.ndarry的区别](https://blog.csdn.net/sinat_28576553/article/details/89047893)

## numpy.random.seed([num])

> 作用

    当seed里面设置了数字，则会使每次生成的随机数都是一样的；如果没有设置，则每次的随机数不一样

```python
np.random.seed(0)
np.random.rand(10)
Out[357]: 
array([0.5488135 , 0.71518937, 0.60276338, 0.54488318, 0.4236548 ,
       0.64589411, 0.43758721, 0.891773  , 0.96366276, 0.38344152])
np.random.rand(10)
Out[358]: 
array([0.79172504, 0.52889492, 0.56804456, 0.92559664, 0.07103606,
       0.0871293 , 0.0202184 , 0.83261985, 0.77815675, 0.87001215])
```
      出现以上问题的原因是：你只设置了一次seed，第二次没有设置，要想每次的随机数都一样的话，
    需要在每次生成随机数之前都得设置一次seed
    
    如下：

```python
np.random.seed(0)
np.random.rand(4,3)
Out[362]: 
array([[0.5488135 , 0.71518937, 0.60276338],
       [0.54488318, 0.4236548 , 0.64589411],
       [0.43758721, 0.891773  , 0.96366276],
       [0.38344152, 0.79172504, 0.52889492]])
np.random.seed(0)
np.random.rand(4,3)
Out[364]: 
array([[0.5488135 , 0.71518937, 0.60276338],
       [0.54488318, 0.4236548 , 0.64589411],
       [0.43758721, 0.891773  , 0.96366276],
       [0.38344152, 0.79172504, 0.52889492]])
         
```


```python
def rng():
    for i in range(5):
        np.random.seed(123)
        print(np.random.rand(4))
        
rng()
>>>[0.69646919 0.28613933 0.22685145 0.55131477]
   [0.69646919 0.28613933 0.22685145 0.55131477]
   [0.69646919 0.28613933 0.22685145 0.55131477]
   [0.69646919 0.28613933 0.22685145 0.55131477]
   [0.69646919 0.28613933 0.22685145 0.55131477]
def rng_n():
    np.random.seed(123)
    for i in range(5):
        print(np.random.rand(4))
        
rng_n()
>>>[0.69646919 0.28613933 0.22685145 0.55131477]
   [0.71946897 0.42310646 0.9807642  0.68482974]
   [0.4809319  0.39211752 0.34317802 0.72904971]
   [0.43857224 0.0596779  0.39804426 0.73799541]
   [0.18249173 0.17545176 0.53155137 0.53182759]
   
```

## numpy.random

参见以下内容：
[numpy.random用法](https://blog.csdn.net/weixin_42029738/article/details/81977492)

[numpy.random.RandomState() numpy里random总结](https://blog.csdn.net/jieshaoxiansen/article/details/82255191)

## numpy.mgird[]
> 用法

    np.mgrid[起始值:结束值:步长,起始值:结束值:步长,...]


​    
```python
>>> np.mgrid[1:3:1,2:4:0.5]
array([[[1. , 1. , 1. , 1. ],
        [2. , 2. , 2. , 2. ]],
       [[2. , 2.5, 3. , 3.5],
        [2. , 2.5, 3. , 3.5]]])
        
        
        
>>> np.mgrid[1:3:0.5,2:4:0.5]
array([[[1. , 1. , 1. , 1. ],
        [1.5, 1.5, 1.5, 1.5],
        [2. , 2. , 2. , 2. ],
        [2.5, 2.5, 2.5, 2.5]],
       [[2. , 2.5, 3. , 3.5],
        [2. , 2.5, 3. , 3.5],
        [2. , 2.5, 3. , 3.5],
        [2. , 2.5, 3. , 3.5]]])


>>> np.mgrid[1:3:0.5,2:4:0.2]
array([[[1. , 1. , 1. , 1. , 1. , 1. , 1. , 1. , 1. , 1. ],
        [1.5, 1.5, 1.5, 1.5, 1.5, 1.5, 1.5, 1.5, 1.5, 1.5],
        [2. , 2. , 2. , 2. , 2. , 2. , 2. , 2. , 2. , 2. ],
        [2.5, 2.5, 2.5, 2.5, 2.5, 2.5, 2.5, 2.5, 2.5, 2.5]],
       [[2. , 2.2, 2.4, 2.6, 2.8, 3. , 3.2, 3.4, 3.6, 3.8],
        [2. , 2.2, 2.4, 2.6, 2.8, 3. , 3.2, 3.4, 3.6, 3.8],
        [2. , 2.2, 2.4, 2.6, 2.8, 3. , 3.2, 3.4, 3.6, 3.8],
        [2. , 2.2, 2.4, 2.6, 2.8, 3. , 3.2, 3.4, 3.6, 3.8]]])


```
体会一下以上二者的区别：
    可以发现，第一维行的值相同，是按照列的值进行递增；第二维列的值相同，是按照行的值进行递增；
    第一维的行数决定了第二维的行数，第二维的列数决定了第一维的列数。
    
## x.ravel()
> 作用

将x变为一维数组，把 . 前变量拉直

```python
>>> a = [[1,2,3],[4,5,6]]
>>> a = np.array(a)
>>> a
array([[1, 2, 3],
       [4, 5, 6]])
       
>>> a.ravel()
array([1, 2, 3, 4, 5, 6])

```

## np.c_[]
> 作用

    使返回的间隔数值点配对
    
    np.c_[数组1，数组2，...]

```python
import numpy as np
import tensorflow as tf

# 生成等间隔数值点
x, y = np.mgrid[1:3:1, 2:4:0.5]
# 将x, y拉直，并合并配对为二维张量，生成二维坐标点
grid = np.c_[x.ravel(), y.ravel()]
print("x:\n", x)
print("y:\n", y)
print("x.ravel():\n", x.ravel())
print("y.ravel():\n", y.ravel())
print('grid:\n', grid)

-------------输出数组---------------
x:
 [[1. 1. 1. 1.]
 [2. 2. 2. 2.]]
y:
 [[2.  2.5 3.  3.5]
 [2.  2.5 3.  3.5]]
x.ravel():
 [1. 1. 1. 1. 2. 2. 2. 2.]
y.ravel():
 [2.  2.5 3.  3.5 2.  2.5 3.  3.5]
grid:
 [[1.  2. ]
 [1.  2.5]
 [1.  3. ]
 [1.  3.5]
 [2.  2. ]
 [2.  2.5]
 [2.  3. ]
 [2.  3.5]]

```