[toc]

## 1、引入依赖

```java
<dependency>
    <groupId>org.apache.shiro</groupId>
    <artifactId>shiro-core</artifactId>
    <version>2.0.1</version>
</dependency>
```



## 2、INI文件

Shiro获取权限相关信息可以通过数据库获取，也可以通过ini配置文件获取。

1、创建文件，在resources文件夹里创建！

![image-20241104015144490](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202411040151524.png)

## 3、登录认证

> 登录认证概念

- 身份验证：一般需要提供如身份ID等一些标识信息来表明登录者的身份，如提供email，用户名/密码来证明
- 在shiro中，用户需要提供principals（身份）和credentials（证明）给shiro，从而应用能验证用户身份
- principals：身份，即主题的标识属性，可以是任何属性，如用户名、邮箱等，唯一即可。一个主体可以有多个principals，但只有一个Primary principals，一般是用户名/邮箱/手机号
- credentials：证明/凭证，即只有主体知道的安全值，如密码/数字证书等。
- 最常见的principals和credentials组合就是用户名/密码

> 登录认证基本流程图

- 手机用户身份/凭证，即如用户名/密码

- 调用Subject login进行登录，如果失败将得到相应的 AuthenticationException异常，根据异常提示用户错误信息，否则登陆成功。

- 创建自定义的Realm类，继承org.apache.shiro.realm.AuthenticationRealm类，实现doGetAuthenticationInfo()方法

  ![image-20241106002951135](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202411060029230.png)



> 登录认证实例

```java
public class ShiroRun {
    public static void main(String[] args) {
        // 1、初始化获取SecurityManager安全管理器工厂
        IniSecurityManagerFactory iniSecurityManagerFactory = new IniSecurityManagerFactory("classpath:shiro.ini");
        // 通过安全管理器工厂创建一个安全管理器
        SecurityManager securityManager = iniSecurityManagerFactory.getInstance();
        // 将安全管理器放入安全工具类  自动使用
        SecurityUtils.setSecurityManager(securityManager);

        // 2、通过安全管理工具获取主题对象，获取Subject
        Subject subject = SecurityUtils.getSubject();

        // 3、创建token对象、web应用的用户名密码从页面传递
        AuthenticationToken token = new UsernamePasswordToken("zhangsan", "admin");

        try {
            // 4、完成登录
            subject.login(token);
            System.out.println("登陆成功");
        } catch (UnknownAccountException e) {
            e.printStackTrace();
            System.out.println("用户不存在");
        } catch (IncorrectCredentialsException e) {
            e.printStackTrace();
            System.out.println("密码错误");
        } catch (AuthenticationException e) {
            e.printStackTrace();
            System.out.println("授权异常");
        }
    }
}
```



## 4、角色、授权

> **1、授权概念**

- **授权：**也叫访问控制，及在应用中控制谁访问哪些资源（如访问页面、编辑数据、页面操作），在授权中需了解的几个关键对象：主体（Subject）、资源（Resource）、权限（Permission）、角色（Role）
- **主体（Subject）：**访问应用的用户，在Shiro中使用Subject代表该用户。用户只有授权后才允许访问相应的资源。
- **资源（Resource）：**在应用中用户可以访问的URL，比如访问JSP页面、查看编辑某些数据、访问某个业务方法，打印文本等等都是资源。用户只有授权后才能访问。
- **权限（Perssion）：**安全策略中的源自授权单位，通过权限我们可以表示在应用中用户有没有操作某个资源的权力。即权限表示在应用中用户能不能访问某个资源。如：访问用户列表页面查看/新增/修改/删除用户数据（即很多时候都是CRUD（增删改查）式权限控制）等。权限代表了某个用户有没有操作某个资源的权利，即反映在某个资源上的操作允许不允许。
- Shiro支持粗粒度（如用户模块的所有权）和细粒度权限（操作某个用户的权限，即实例级别）
- **角色（Role）**：权限的集合，一般情况下会赋予用户角色而不是权限，即这样的用户用户可以拥有 **一组权限**，赋予权限时比较方便。典型的如：项目经理，技术总监，CTO，开发工程师等都是角色，不同的角色拥有一组不同的权限。



> **2、授权方式**

（1）编程式：通过写 `if/else`授权代码块完成

```java
if(subject.hasRole("admin")) {
    // 有权限
} else {
    // 无权限
}
```

（2）注解式：通过在执行的Java方法上放置相应的注解完成，没有权限将抛出相应异常。

```java
@RequiresRoles("admin")
public void sayHello(){
    // 有权限
}
```

（3）JSP/GSP标签：在JSP/GSP页面通过相应的标签完成

```java
<shiro:hasRole name="admin">
    <!--有权限-->
</shiro:hasRole>
```



> **3、授权流程**

（1）首先调用`Subject.isPermitted*/hasRole*`接口，其会委托给SecurityManager，而SecurityManager接着会委托给Authorizer

（2）Authorizer是真正的授权者，如果调用如isPermitted("user:view")，其首先会通过PermissionResolver把字符串转换成相应的Permission实例；

（3）在进行授权之前，其会调用相应的Realm获取Subject相应的角色/权限用于匹配传入的角色/权限；

（4）Authorizer会判断Realm的角色/权限是否和传入的匹配，如果**有多个Realm**，会委托给ModularRealmAuthorizer进行**循环判断**，如果匹配如`isPermitted*/hasRole*`会返回true，否则返回false表示授权失败。

![image-20241112194148248](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202411121941625.png)

> **4、授权实例**

（1）获取角色信息

```ini
# shiro.ini增加角色配置
[users]
zhangsan=admin, role1, role2
lisi=lisi
```

然后在代码块中添加如下代码：

```java
// 5. 判断是否有相关的角色
boolean hasRole = subject.hasRole("role1");
```

（2）判断权限信息

```ini
# shiro.ini 增加权限配置
[roles]
role1=user:insert,user:select
```

然后在代码块中添加如下代码，判断用户是否有指定权限

```java
boolean isPermitted=subject.isPermitted("user:insert");
// 或者checkPermission方法，但没有返回值，没权限抛AuthenticationException异常
subject.checkPermission("user:select");
```



整体代码：

```java
public class ShiroRun {
    public static void main(String[] args) {
        // 1、初始化获取SecurityManager安全管理器工厂
        IniSecurityManagerFactory iniSecurityManagerFactory = new IniSecurityManagerFactory("classpath:shiro.ini");
        // 通过安全管理器工厂创建一个安全管理器
        SecurityManager securityManager = iniSecurityManagerFactory.getInstance();
        // 将安全管理器放入安全工具类  自动使用
        SecurityUtils.setSecurityManager(securityManager);

        // 2、通过安全管理工具获取主题对象，获取Subject
        Subject subject = SecurityUtils.getSubject();

        // 3、创建token对象、web应用的用户名密码从页面传递
        AuthenticationToken token = new UsernamePasswordToken("zhangsan", "admin");

        try {
            // 4、完成登录
            subject.login(token);
            System.out.println("登陆成功");
            // 5. 判断是否有相关的角色
            boolean hasRole = subject.hasRole("role1");
            System.out.println("是否拥有此角色 = " + hasRole);
            // 6. 判断是否有权限
            boolean permitted = subject.isPermitted("user:insert");
            System.out.println("是否拥有此权限 = " + permitted);
            subject.checkPermission("user:select");
        } catch (UnknownAccountException e) {
            e.printStackTrace();
            System.out.println("用户不存在");
        } catch (IncorrectCredentialsException e) {
            e.printStackTrace();
            System.out.println("密码错误");
        } catch (AuthenticationException e) {
            e.printStackTrace();
            System.out.println("授权异常");
        }
    }
}
```



## 5、shiro加密

实际系统开发中，一些敏感信息需要进行加密，比如说用户的密码。Shiro内嵌很多常用的加密算法，比如MD5加密。Shiro可以很简单的使用信息加密。

1、使用Shiro进行密码加密

```java
import org.apache.shiro.crypto.hash.Md5Hash;
import org.apache.shiro.crypto.hash.SimpleHash;

/**
 * @ClassName: ShiroMD5
 * @Description:
 * @Author: Lengqy
 * @Date: 2024/11/12 20:28
 **/
public class ShiroMD5 {
    public static void main(String[] args) {
        // 密码明文
        String password = "123456";
        // 使用md5加密
        Md5Hash md5Hash = new Md5Hash(password);
        // 下面这两输出是一样的
        System.out.println("md5 加密 = " + md5Hash);
        System.out.println("md5 加密 = " + md5Hash.toHex());

        // 带盐的md5加密，盐就是在密码明文后拼接新字符串，然后再进行加密
        Md5Hash md5Hash2 = new Md5Hash(password, "abc");
        System.out.println("带盐的  md2Hash = " + md5Hash2.toHex());

        // 带盐的多次迭代加密
        Md5Hash md5Hash3 = new Md5Hash(password, "abc", 3);
        System.out.println("带盐的多次迭代加密  md3Hash = " + md5Hash3.toHex());

        // 使用父类进行加密
        // 这种方式和上面的方式出来的加密是一样的
        SimpleHash simpleHash = new SimpleHash("md5", password, "abc", 3);
        System.out.println("使用父类指定md5加密类型带盐的3次加密 = " + simpleHash.toHex());
    }
}
```

输出：

```
md5 加密 = e10adc3949ba59abbe56e057f20f883e
md5 加密 = e10adc3949ba59abbe56e057f20f883e
带盐的  md2Hash = 0659c7992e268962384eb17fafe88364
带盐的多次迭代加密  md3Hash = da22e1674b0cfc8eccf66e7414a1080f
使用父类指定md5加密类型带盐的3次加密 = da22e1674b0cfc8eccf66e7414a1080f
```



## 6、Shiro自定义登录认证

Shiro默认的登录认证是不带加密的，如果想要实现加密认证需要自定义登录认证，自定义Realm。

**思路重点：创建自定义的Realm类，继承org.apache.shiro.realm.AuthenticationRealm类，实现doGetAuthenticationInfo()方法**

1、自定义登录认证

```java
/**
 * @ClassName: MyRealm
 * @Description: 自定义登录认证
 * @Author: Lengqy
 * @Date: 2024/11/12 20:44
 **/
public class MyRealm extends AuthenticatingRealm {
    // 自定义登录认证方法，shiro的login方法的底层会调用该类的认证方法进行认证
    // 需要配置自定义的Realm生效，在shiro.ini文件中配置，或者在springBoot中配置
    // 该方法只是获取进行对比的信息，认证逻辑还是按照shiro的底层认证逻辑完成
    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {
        // 获取身份信息
        String userName = authenticationToken.getPrincipal().toString();
        // 获取认证凭证
        String password = new String((char[]) authenticationToken.getCredentials());
        System.out.println("认证用户信息：" + userName + "; 用户凭证：" + password);
        // 获取数据库中存储的用户信息
        if (userName.equals("zhangsan")) {
            // 数据库中存储的加盐3次迭代的密码
            String pwdInfo = "da22e1674b0cfc8eccf66e7414a1080f";
            // 创建封装校验逻辑对象，封装数据返回
            AuthenticationInfo info = new SimpleAuthenticationInfo(
                    authenticationToken.getPrincipal(),
                    pwdInfo,
                    ByteSource.Util.bytes("abc"), // 指定加盐信息
                    authenticationToken.getPrincipal().toString()
            );
            return info;
        }
        return null;
    }
}
```

**注意：**该方法只是进行对比信息是否匹配，真正的认证逻辑还是由Shiro的底层逻辑去实现。

接下来完善realm的配置信息。**这个地方有点模糊，需要重点去学习一下！！！**

```ini
[main]
md5CredentialsMatcher=org.apache.shiro.authc.credential.Md5CredentialsMatcher
md5CredentialsMatcher.hashIterations=3

myrealm=com.lqy.shirologin.test.MyRealm
myrealm.credentialsMatcher=$md5CredentialsMatcher
securityManager.realms=$myrealm

[users]
zhangsan=da22e1674b0cfc8eccf66e7414a1080f, role1, role2
lisi=root

[roles]
role1=user:insert, user:select
```

