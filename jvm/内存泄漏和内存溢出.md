> **内存泄漏 memory leak**

指无用对象（不再使用的对象）**持续占有内存**或**无用对象的内存得不到及时的释放**，从而造成的内存空间的浪费称为**内存泄漏**。

程序运行过程中分配临时内存给变量，但是用完之后却没有被GC回收，始终占用着内存，**既不能用也不能分配给其他的程序**，于是就发生了内存泄漏。

指程序申请内存后，**无法释放已申请的内存空间**，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存，迟早会被耗光。

内存泄露有时不严重且不易被察觉，这样开发者就不知道存在内存泄露，但有时也会很严重，会提示你 out of memory。



以发生的方式分类，内存泄漏可以分为4类：

1. 常发性内存泄漏：发生内存泄露的代码会被多执行到，每次被执行的时候都会导致一块内存泄漏。
2. 偶发性内存泄漏：发生内存泄露的代码只有在某些特定环境或操作过程下才会发生。常发性和偶发性是相对的，对于特定的环境，偶发性的也许就变成了常发性的。所以测试环境和测试方法对于检测内存泄露至关重要。
3. 一次性内存泄露：发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块且仅有一块内存发生泄漏。比如在类的构造函数中分配内存，在析构函数中却没有释放该内存，所以内存泄露只会发生一次。
4. 隐式内存泄漏：程序在运行的过程中不停的分配内存但是直到结束的时候才释放内存。严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。但是对于一个服务器程序，运行几天，几周甚至几个月，不及时释放内存也可能导致最终耗尽系统的所有内存，所以我们称这类内存泄漏为隐式内存泄漏。

从用户适用程序的角度来看，内存泄漏本身不会产生什么危害，作为一般的用户，根本感觉不到内存泄漏的存在。真正有危害的是内存泄漏的堆积，这回最终消耗尽下系统的所有内存。从这个角度来说，一次性内存泄露并没有什么危害，因为他不会堆积，而隐式内存泄漏的危害性特别大，因为较之常发性和偶发性内存泄漏他更难被检测到。



**下面总结了几种常见的内存泄漏：**

**1、静态集合类引起的内存泄漏：**

像HashMap，Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，他们所引用的所有对象Object也不能被释放，而从造成了内存泄漏，因为他们也将一直被Vector等引用着

```c++
Vector<Object> v=new Vector<Object>(100); 
for (int i = 1; i<100; i++) 
{ 
Object o = new Object(); 
v.add(o); 
o = null; 
} 
```

在这个例子，循环申请Object对象，并将所申请的对象放入一个Vector中，**如果仅释放引用本身（o=null），那么Vector仍然引用该对象**，所以这个对象对GC来说是不可回收的，因此，如果对象加入到Vector后，还必须从Vector中删除，那么最简单的方法就是将Vector对象设置为null。



**2、修改HashSet中对象的参数值，且参数是计算哈希值的字段**

当一个对象被存储到HashSet集合中以后，修改了这个对象中那些参与计算哈希值的字段后，这个对象的哈希值与最初存储在集合中的就不同了，这种情况下，用contains方法在集合中检索对象是找不到的，这就导致无法从HashSet中删除当前对象，造成内存泄露，代码如下：

```java
Set<Person> set = new HashSet<Person>(); 
 Person p1 = new Person("张三","1",25); 
 Person p2 = new Person("李四","2",26); 
 Person p3 = new Person("王五","3",27); 
 set.add(p1); 
 set.add(p2); 
 set.add(p3); 
 System.out.println("总共有:"+set.size()+" 个元素!"); //结果：总共有:3 个元素! 
 p3.setAge(2); //修改p3的年龄,此时p3元素对应的hashcode值发生改变 
 set.remove(p3); //此时remove不掉，造成内存泄漏 
 set.add(p3); //重新添加，可以添加成功 
 System.out.println("总共有:"+set.size()+" 个元素!"); //结果：总共有:4 个元素! 
  
 for (Person person : set){ 
 System.out.println(person); 
```



**3、监听器**

在java 编程中，我们都需要和监听器打交道，通常一个应用当中会用到很多监听器，我们会调用一个控件的诸如`addXXXListener()`等方法来增加监听器，但往往在释放对象的时候却没有记住去删除这些监听器，从而增加了内存泄漏的机会。



**4、各种连接**

比如数据库连接(`dataSourse.getConnection()`)，网络连接(`socket`)和`io`连接，除非其显式的调用了其`close()` 方法将其连接关闭，否则是不会自动被`GC` 回收的。对于`Resultset` 和`Statement` 对象可以不进行显式回收，但`Connection` 一定要显式回收，因为`Connection` 在任何时候都无法自动回收，而`Connection`一旦回收，`Resultset` 和`Statement` 对象就会立即为NULL。但是如果使用连接池，情况就不一样了，除了要显式地关闭连接，还必须显式地关闭`Resultset Statement` 对象(关闭其中一个，另外一个也会关闭)，否则就会造成大量的Statement 对象无法释放，从而引起内存泄漏。这种情况下一般都会在try里面去连接，在`finally`里面释放连接。

```lass
lass A{ 
 public A(){ 
 B.getInstance().setA(this); 
 } 
 .... 
} 
//B类采用单例模式 
class B{ 
 private A a; 
 private static B instance=new B(); 
 public B(){} 
  
 public static B getInstance(){ 
 return instance; 
 } 
  
 public void setA(A a){ 
 this.a=a; 
 } 
 //getter... 
} 
```

显然B采用singleton模式，它持有一个A对象的引用，而这个A类的对象将不能被回收。想象下如果A是个比较复杂的对象或者集合类型会发生什么情况。



**避免内存泄漏的几点建议**：

1、尽早释放无用对象的引用。

2、避免在循环中创建对象。

3、使用字符串处理时避免使用String，应使用StringBuffer。

4、尽量少使用静态变量，因为静态变量存放在永久代，基本不参与垃圾回收。 





> **内存溢出  out of memory**

简单来说就是指程序申请的内存大于系统能够提供的内存，导致无法申请到足够的内存，于是就发生了**内存溢出**。

**注：内存泄漏最终会导致内存溢出。**



**内存溢出常见的几种情况：**

**1、java.lang.OutOfMemoryError: PermGen space (持久带溢出)**

我们知道`jvm`通过持久带实现了`java`虚拟机规范中的方法区，而运行时常量池就是保存在方法区中的，因此发生这种溢出可能是运行时常量池溢出，或是由于程序中使用了大量的jar或class，使得方法区中保存的class对象没有被及时回收或者class信息占用的内存超过了配置的大小。



**2、java.lang.OutOfMemoryError: Java heap space (堆溢出)**

发生这种溢出的原因一般是创建的对象太多，在进行垃圾回收之前对象数量达到了最大堆的容量限制。

解决这个区域异常的方法一般是通过内存映像分析工具对Dump出来的堆转储快照进行分析，看到底是内存溢出还是内存泄漏。如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链，定位出泄漏代码的位置，修改程序或算法;如果不存在泄漏，就是说内存中的对象确实都还必须存活，那就应该检查虚拟机的堆参数-Xmx(最大堆大小)和-Xms(初始堆大小)，与机器物理内存对比看是否可以调大。



**3、虚拟机栈和本地方法栈溢出**

如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError。

如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError。 





**内存溢出的原因以及解决方法**：

1.内存中加载的数据量过于庞大，如一次从数据库取出过多数据；

2.集合类中有对对象的引用，使用完后未清空，使得JVM不能回收；

3.代码中存在死循环或循环产生过多重复的对象实体；

4.使用的第三方软件中的BUG；

5.启动参数内存值设定的过小

内存溢出的解决方案：

第一步，修改JVM启动参数，直接增加内存。(-Xms，-Xmx参数一定不要忘记加。)

第二步，检查错误日志，查看“OutOfMemory”错误前是否有其它异常或错误。

第三步，对代码进行走查和分析，找出可能发生内存溢出的位置。

重点排查以下几点：

1.检查对数据库查询中，是否有一次获得全部数据的查询。一般来说，如果一次取十万条记录到内存，就可能引起内存溢出。这个问题比较隐蔽，在上线前，数据库中数据较少，不容易出问题，上线后，数据库中数据多了，一次查询就有可能引起内存溢出。因此对于数据库查询尽量采用分页的方式查询。

2.检查代码中是否有死循环或递归调用。

3.检查是否有大循环重复产生新对象实体。

4.检查List、MAP等集合对象是否有使用完后，未清除的问题。List、MAP等集合对象会始终存有对对象的引用，使得这些对象不能被GC回收。

第四步，使用内存查看工具动态查看内存使用情况