# SpringBoot的配置文件和自动配置原理

## 1 使用Spring Initializer快速创建Spring Boot项目

> **具体流程**

- **创建父级项目**：选择File->New->Project->Spring Initializr，然后填写配置信息

  ![image-20240118170725574](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401181707641.png)

  由于是创建父级项目，可以不用写代码，是用来给子项目继承的，所以依赖可以不用选，直接点击创建。

- **创建子项目：**右键项目，选择Module——>New Module，其他的基本跟父流程一样

  ![image-20240118172327877](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401181723941.png)

  然后选择必要的依赖，点击创建即可。

- 通过观察，我们发现父项目的`pom.xml`和子项目的`pom.xml`几乎一样，而且子项目的parent继承的也是`spring-boot-starter-parent`，因此就导致了父子项目之间不存在继承关系，为了实现其继承关系，我们可以把父项目的信息复制到子项目的`pom.xml`的`parent`里，如下图所示：

  ![image-20240118173036574](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401181730628.png)

  ![image-20240118173125556](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401181731617.png)

1、IDEA：使用Spring Initializr快速创建项目

- 继承关系-springboot的maven项目

- 使用spring initializr新建一个父maven，type选择POM

- 再使用spring initializr新建一个子maven，type选择maven project

- 修改子项目中的继承方式

  修改前：

  ```xml
  <parent>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-parent</artifactId>
      <version>3.2.1</version>
      <relativePath/> <!-- lookup parent from repository -->
  </parent>
  ```

  修改后：

  ```xml
  <parent>
      <groupId>com.tuling.springboot</groupId>
      <artifactId>springboot_parent</artifactId>
      <version>0.0.1-SNAPSHOT</version>
  </parent>
  ```

IDEA都支持使用Spring的项目创建向导快速创建一个SpringBoot项目：选择我们需要的模块，向导会联网创建Spring Boot项目；

默认生成的Spring Boot项目：

- 主程序已经生成好了，我们只需要我们自己的逻辑
- resources文件夹中目录结构
  - static：保存所有的静态资源：js css images
  - templates：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面）；可以使用模板引擎（freemarker，thymeleaf）
  - application.properties：Spring Boot应用的配置文件；可以修改一些默认配置。



## 2 自定义SpringApplication

如果SpringApplication默认设置不符合您的喜好，则可以创建一个本地实例并对其进行自定义。例如，要关闭横幅，您可以编写：

```java
import org.springframework.boot.Banner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class SpringinitializrApplication {

    public static void main(String[] args) {
//        SpringApplication.run(SpringinitializrApplication.class, args);
        SpringApplication springApplication = new SpringApplication(SpringinitializrApplication.class);
        springApplication.setBannerMode(Banner.Mode.OFF);// 关闭横幅
        springApplication.run(args);
    }

}
```

通过构造者模式流式构造**SpringApplication**：

```java
new SpringApplicationBuilder(SpringinitializrApplication.class)
    .bannerMode(Banner.Mode.OFF)
    .run(args);
```

当然我也可以自定义自己的横幅，当我们把自己的banner.jpg放入到resources文件夹中时，在重新启动时就可以看到自己的banner图标，切记：此时不要把横幅给关闭了。

![image-20240118203754764](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401182038757.png)



## 3 配置文件的使用

### 3.1 配置文件的介绍

SpringBoot使用一个全局的配置文件 **核心配置文件**，配置文件名**在约定的情况下名字是固定的**；

配置文件的使用：修改SpringBoot自动配置的默认值；SpringBoot在底层都给我们自动配置好了；

- application.properties
- application.yml
- application.yaml

YAML(YAML Ain't Markup Language)

YAML A Markup Language：是一个标记语言

YAML isn't Markup Language：不是一个标记语言

### 3.2 配置文件的格式

在SpringBoot框架中，resources文件夹里可以存放配置的文件有两种：properties和yml

1、application.properties的用法：扁平的k/v格式

```properties
server.port=8080
server.servlet.context-path=/tuling
```

2、application.yml的用法：树形结构

```yaml
server:
	port: 8080
	servlet: 
		context-path: /tuling
```

建议使用后者，因为后者的可读性更强。可以看到要转换成YML我们只需要把properties里按.拆分即可。

YML文件中间不允许添加注释！



### 3.3 yml基本语法

k: (空格)v：表示一对键值对（空格必须有）；

以空格的缩进来控制层级关系；只要是左对齐的一列数据，都是同一层级的；

属性和值也是大小写敏感的；

如果有特殊字符% & 记得用单引号(')包起来



### 3.4 配置文件的加载顺序

```xml
<includes>
 <include>**/application*.yml</include>
 <include>**/application*.yaml</include>
 <include>**/application*.properties</include>
</includes>
```

如果同时存在不同后缀名的文件则按照这个顺序加载主配置文件；互补配置；



### 3.5 外部约定配置文件加载顺序

SpringBoot启动还会扫描以下位置的application.properties或者application.yml文件作为SpringBoot的默认配置文件：

优先级从低到高如下：

1、classpath根目录下

2、classpath根config/目录下

3、项目根目录下

4、项目根config/目录下

5、项目直接子项目的config/目录下

- classpath根目录下的

  ![image-20240118210954316](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401182109375.png)

- classpath根config/目录下

  ![image-20240118211102085](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401182111123.png)

- 项目根目录下

  如果当前项目是继承/耦合关系maven项目的话，项目根目录=父maven项目的根目录

  ![image-20240118213027528](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401182130577.png)

- 项目根目录config/

  ![image-20240118213159242](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401182131287.png)

- 项目直接子目录config/

  我们将子项目进行打包jar，发现报错：

  ![image-20240118213600487](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401182136547.png)

  此时我们需要在父POM里面添加：`<packaging>pom</packaging>`，意思就是说它不是一个具体的项目，而是作为一个父项目进行继承。

  重新打包一切正常。

  ```shell
  java -jar spring_initializr-0.0.1-SNAPSHOT.jar
  ```

  惊奇的发现，项目运行的端口号居然是子项目的resources目录下config的配置文件的端口号。

  ![image-20240118214343859](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401182143922.png)

因为`约定大于配置`，项目的配置文件一定要在项目的classpath路径下，这样编译的时候才是合规的。

下面我们自定义配置信息：

```shell
java -jar spring_initializr-0.0.1-SNAPSHOT.jar --server.port=8087
```

那么启动的时候就会以端口号8087启动。

指定配置文件路径：

```shell
java -jar spring_initializr-0.0.1-SNAPSHOT.jar --spring.config.location=D:\config/
```

**如果config是一个文件夹，则结尾处的`/`是必不可少的。**

命令行上指定配置的优先级是最高的。

官网上最详细的加载顺序，从低到高：

```shell
optional:classpath:/
optional:classpath:/config/
optional:file:./
optional:file:./config/
optional:file:./config/*/
optional:classpath:custom-config/     # --spring.config.location
optional:file:./custom-config/        # --spring.config.location
```



### 3.6 Profile文件的加载

Profile的意思是配置，对于应用程序来说，不同的环境需要不同的配置。

SpringBoot框架提供了多Profile的管理功能，我们可以使用profile功能来区分不同环境的配置。

> **1、多profile文件**

1、Spring官方给出的语法规则是application-{profile}.properties (.yml/.yaml)

2、如果需要创建自定义的properties文件时，可以使用application-xxx.properties的命名方式，根据实际的情况，我们创建了一个开发环境下使用的properties文件和一个生产环境下使用的properties文件，其中只对端口号进行了配置，如下图所示：

1）开发环境如下：

![image-20240118220547124](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401182205178.png)

2）生产环境如下：

![image-20240118220658847](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401182206898.png)

3）若我们需要在两种环境下进行切换，只需要在application.properties中加入如下内容即可：

![image-20240118220951959](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401182209014.png)

![image-20240118221001239](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401182210328.png)

切记：**先按照位置来读取优先级**，在同一位置下`profiles`优先级最高，如果没有指定profile，先yml-yaml-properties

> **举例**

![image-20240118221534897](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401182215953.png)

如上图所示，端口号一定加载的是config文件夹下的application.properties中的端口号，然后再去激活application-dev.properties中的配置，如果application-dev.properties中也有端口号的配置，则是被直接忽略的。但是application-dev.properties中有的配置（但是application.properties中没有的配置）则是优先级最高的。其他的则互补。

> **举例**：控制器也分dev或prod，只不过需要使用@Profile("dev")或@Profile("prod")

![image-20240118222429202](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401182224274.png)

当我的config下的application.properties里的配置文件激活的是`prod`配置文件时，那么我的Controller也会调用有prod的HelloControllerProd（如果我的controller配置了`@Profile`注解的话），下面是两个controller的代码：

![image-20240118222638483](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401182226554.png)

![image-20240118222657384](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401182226460.png)

此时如果进行localhost:8080/tuling_prod/hello/world的请求的话，则输出的一定是：

![image-20240118222801184](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401182228226.png)

此时，如果我给这两个controller都把注解`@Profile`注释掉，那么就会报错，因为存在两个一样请求路径，报错如下：

![image-20240118223210626](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401182232690.png)

**但是**如果我只留这两个中其中一个注解`@Profile`，那么就不会报错：如果我留下的是@Profile("dev")这个注解，由于这个controller是dev的，所以如果我在配置文件中激活的是prod的话，那么程序就会使用HelloControllerProd这个控制器，因为根据排除法得到的；如果我留下的是@Profile("prod")，那么我的程序就会直接使用HelloControllerProd这个控制器。



> **举例：**命令行激活配置文件

```shell
java -jar spring_initializr-0.0.1-SNAPSHOT.jar --spring.profiles.activate=dev
```

根据上面的配置，在resources下有一个config/application.properties配置文件，即使在命令行里指定了激活dev版本，但是位置优先，所以会先按照resources/config/application.properties里面的配置，然后再按照application-dev.properties里的配置**进行补充**。

还是那一句话：**先按照位置进行配置，在同一位置下Profile的优先级最高，如果没有指定profile，则按照yml-yaml-properties**



> **举例：**使用下面的方式不会进行互补
>
> --spring.config.location 直接改变默认的配置文件，不会进行互补

```shell
java -jar spring_initializr-0.0.1-SNAPSHOT.jar --spring.config.location=D:/application.properties
```

**注意：**此处的application.properties是一个文件，所以结尾处不必添加`/`。

![image-20240118225656292](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401182256365.png)

注意：**也可以使用这个方式**；但是缺点就是不能互补。

有一点需要注意，当你使用下面的方式时：

```shell
java -jar .\spring_initializr-0.0.1-SNAPSHOT.jar --spring.config.location=classpath:application-dev.properties
```

如果`application-dev.properties`配置文件中没有配置`spring.profiles.active=prod`的属性的话，那么控制器controller上面的注解`@Profile`便无法被匹配，因此就会报404错误；但是如果`application-dev.properties`配置文件中使用了`spring.profiles.active=prod`属性的话，那么controller上的注解`@Profile`就可以生效，就不会报404错误。

**注意：**使用这个方式是**不会使用互补配置**的；而且由于我们指定的了配置文件的路径，所以`spring`是**不会按照官方默认的读取配置文件的方式去读**，而是直接来到指定位置读取配置文件。

另外使用`--spring.config.name`来**改变默认的配置文件**，也是不会互补的：

```shell
java -jar .\spring_initializr-0.0.1-SNAPSHOT.jar --spring.config.name=application
或
java -jar .\spring_initializr-0.0.1-SNAPSHOT.jar --spring.config.name=application-dev
```



### 3.7 所有配置文件按照以下顺序考虑：优先级从低到高

1、打包在jar中的配置文件

2、打包在jar中profile

3、打包的jar之外的配置文件

4、打包的jar之外的profile

```shell
java -jar .\spring_initializr-0.0.1-SNAPSHOT.jar 
# jar包之外的配置文件 ./config/      yml——yaml——properties 优先级高
# jar包之外的配置文件 ./config/*/    yml——yaml——properties
# jar包之外的配置文件 ./             yml——yaml——properties

# 其次
# optional：classpath：/config/     yml——yaml——properties
# optional：classpath：/			  yml——yaml——properties 优先级低
```

上面的代码的意思是：当命令行后面不加参数时，默认先在jar包的外面，也就是jar包的同级目录下找application的配置文件，按照yml——yaml——properties的顺序查找。当jar外面找不到时，就会去resources的/config/目录下查找，最后去resources的根目录下查找application配置文件，也是按照yml——yaml——properties的顺序查找。**配置文件互补。**（这个互补可以实现application*.properties之间的互补，也就是application.properties可以和application-dev.properties互补）



```shell
java -jar .\spring_initializr-0.0.1-SNAPSHOT.jar --spring.profiles.activate=dev
# jar包之外的配置文件 ./config/      profile-dev——yml——yaml——properties 优先级高
# jar包之外的配置文件 ./config/*/    profile-dev——yml——yaml——properties
# jar包之外的配置文件 ./             profile-dev——yml——yaml——properties 

# 其次
# optional：classpath：/config/     profile-dev——yml——yaml——properties
# optional：classpath：/			  profile-dev——yml——yaml——properties 优先级低
```

同理，会先去找profile-dev的配置，然后按照yml——yaml——properties的顺序查找，**配置文件互补**。



**但是如果指定了具体的配置文件，优先级最大，所以不会和默认的约定配置文件进行互补。**

```shell
java -jar .\spring_initializr-0.0.1-SNAPSHOT.jar --spring.profiles.location=D:/application-dev.properties
```



### 3.8配置文件的读取方式 （优先级由低到高）

1、默认属性（通过设置指定的`SpringApplication.setDefaultProperties`)

​		**注意：**会和约定的配置文件形成互补

```java
@SpringBootApplication
public class Application {

    public static void main(String[] args) throws IOException {
        SpringApplication app = new SpringApplication(Application.class);
        // 创建Properties对象
        Properties properties = new Properties();
        InputStream is = Application.class.getClassLoader().getResourceAsStream("app.properties");// 手动配置
        properties.load(is);

        app.setDefaultProperties(properties);
        app.run(args);
    }
}
```

2、`@PropertySource`是 `@Configuration`类上的注释，要在配置类上使用。请注意，`Environment`在刷新应用程序上下文之前，不会将此类属性源添加到中。现在配置某些属性（如`logging.*`和`spring.main.*`在刷新开始之前先读取）为时已晚。

​		**注意：**会和约定的配置文件形成**互补**；一定要指定`.properties`或`.yml`或`.yaml`配置

```java
@PropertySource("classpath:appSource.properties")
@SpringBootApplication
public class Application {

    public static void main(String[] args) throws IOException {
        SpringApplication app = new SpringApplication(Application.class);
        // 创建Properties对象
        Properties properties = new Properties();
        InputStream is = Application.class.getClassLoader().getResourceAsStream("app.properties");
        properties.load(is);

        app.setDefaultProperties(properties);
        app.run(args);
    }
}
```

3、配置数据（例如application.properties文件），它是约定的配置文件

4、操作系统环境变量

​	a. idea，选择编辑运行配置，然后添加环境变量，最后设置环境变量

![image-20240119100708657](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401191007768.png)

这种方式会使约定的配置文件失效，不会和约定的配置进行互补，但是会和我们手动指定的配置文件互补。

​	b. windows （设置环境变量）

![image-20240119101814838](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401191018900.png)

这种方式会使约定的配置文件失效，不会和约定的配置文件互补，但是会和手动的配置文件互补。

**注意**：不建议在idea的终端中运行，请在cmd中运行，在idea的终端中运行有可能测试失误。

5、java系统属性

​	a. idea

会使约定的配置文件失效，不会和约定的配置文件互补，但是会和手动配置的文件进行互补。注意有一个大写的`-D`

![image-20240119103208309](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401191032400.png)

b.windows

会使约定的配置文件失效，不会和约定的配置文件互补，但是会和手动配置的文件进行互补。注意有一个大写的`-D`

![image-20240119104554777](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401191045847.png)

6、JNDI属性`java:comp/env`

7、`ServletContext`初始化参数

```xml
ServletContext 的配置标签需要写到 web‐app （根标签）中 ，具体如下：
 <context‐param>
     <param‐name>spring.config.location</param‐name>
     <param‐value>xxx.properties</param‐value>
 </context‐param>
```

8、`ServletConfig`初始化参数

```xml
ServletConfig 的配置标签需要写到 Servlet 标签中，标签如下：
 <init‐param>
     <param‐name>spring.config.location</param‐name>
     <param‐value>xxx.properties</param‐value>
 </init‐param>
```

9、来自属性`SPRING_APPLICATION_JSON`（嵌入在环境变量或系统属性中的嵌入式JSON）

10、命令行参数

会使约定配置失效。

```shell
java -jar .\spring_initializr-0.0.1-SNAPSHOT.jar --spring.profiles.location=D:/application-dev.properties
```

11、`properties`测试中的属性。可[用于测试应用程序的特定部分](https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-testing-spring-boot-applications-testing-autoconfigured-tests)`@SpringBooTest`的[测试注释](https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-testing-spring-boot-applications-testing-autoconfigured-tests)和[注释](https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-testing-spring-boot-applications-testing-autoconfigured-tests)

12、[@TestPropertiesSource](https://docs.spring.io/spring/docs/5.3.1/javadoc-api/org/springframework/test/context/TestPropertySource.html)测试中的注释

​	用在单元测试上的！

```java
@TestPropertySource("classpath:appSource.properties")
```

13、$HOME/.config/spring-boot当devtools处于活动状态时，目录中的[Devtools全局设置属性](https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-devtools-globalsettings)。



## 4 属性注入

### 4.1 将YAML映射到属性

- 字面量：普通的值（数字、字符串、布尔）

  - k：v  字面直接写

  - **字符串默认不用加上单引号或双引号**

  - ""：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思

    name: "zhangsan \n lisi"；输出：zhangsan 换行 lisi

  - ''：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据

    name: 'zhangsan \n lisi'；输出：zhangsan \n lisi

- 对象、Map（属性和值）（键值对）

  - k：v；在下一行；来写对象的属性和值的关系；注意缩进

  - 对象还是k：v的方式

    ```xml
    friends:
    	lastName: zhangsan
    	age: 20
    ```

    行内写法：

    ```xml
    friends: {lastName: zhangsan, age: 18}
    ```
  
- 数组（List、Set）

  用 `-`表示数组中的一个元素：

  ```xml
  pets:
  	- cat
  	- dog
  	- pig
  ```

  行内写法：

  ```xml
  pets: [cat, dog, pig]
  ```

- 配置文件

  ```xml
  person:
   lastName: hello
   age: 18
   boss: false
   birth: 2017/12/12
   maps: {k1: v1,k2: 12}
   lists:
   ‐ lisi
   ‐ zhaoliu
   dog:
    name: 小狗
    age: 12
  ```

- javaBean：

  ```java
   @Component
   @ConfigurationProperties(prefix = "person")
   public class Person {
       private String lastName;
       private Integer age;
       private Boolean boss;
       private Date birth;
       private Map<String,Object> maps;
       private List<Object> lists;
       private Dog dog;
  ```

  将配置文件中配置的每一个属性的值，映射到这个组件中。

  `@ConfigurationProperties`：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定。

  `prefix="person"`：配置文件中`person`下面所有的属性进行一一映射。

  只有这个组件是容器中的组件，容器才能提供`@ConfigurationProperties`功能。

  

> **示例：属性注入**

首先创建一个类`User`，并使用`@Component`注解将类实例化到`Spring`容器中。

![image-20240119134800264](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401191348336.png)

（1）如上图所示，我在`User`上添加了一个`@Component`注解，该注解是什么？

`@Component`的作用是把普通`POJO`实例化到`Spring`容器中，`@Component`是一个泛化的概念，仅仅表示一个组件（Bean），可以作用在任何层次。基于`@Component`注解有三个扩展，分别是：`@Repository`，`@Service`，`@Controller`。被他们四个标注的类，会被纳入到Spring容器中进行管理。除了上面四个注解之外，用户可以创建自定义的注解，然后在自定义的注解上标注`@Component`，那么，该自定义的注解便具有了与`@Component`相同的功能。

（2）`@Component`注解如何使用？

基于`@Component`注解有三个扩展，分别是：`@Repository`，`@Service`，`@Controller`，他们只是分别具有不同的业务逻辑，但是被`@Component`，`@Controller`，`@Service`，`@Repository`注解的类，都会把这些类纳入进`Spring`容器中进行管理。

- `@Component`：标注一个普通的`POJO`实例化到`Spring`容器中，它是一个通用泛化的注解，当某个组件不能通过业务进行归类时，可以使用这个注解进行标注
- `@Controller`：用于标注控制层组件
- `@Service`：用于标注业务层组件
- `@Repository`：用于标注持久层组件

（3）`@Value`注解是什么

该注解的作用是将我们配置文件的属性读出来，有`@Value("${}")`和`@Value("#{}")`两种方式。

**第一种方式**：`@Value("${}")`

我们使用的是SpringBoot搭建的项目，配置文件`application.properties`已经被加载到了项目中：

![image-20240119141921039](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401191419099.png)

我们读取它的`server.port`属性，便可以用：

![image-20240119142101473](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401191421586.png)

**第二种方式**：`@Value("#{}")` 

详情请看：[https://blog.csdn.net/woheniccc/article/details/79804600](https://blog.csdn.net/woheniccc/article/details/79804600)

[https://cloud.tencent.com/developer/article/1861247](https://cloud.tencent.com/developer/article/1861247)

---

紧接着，我们使用`@Autowired`自动装配：

![image-20240119142629991](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401191426059.png)

切记：我已在`application.properties`文件中声明值：

![image-20240119143006535](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401191430585.png)

那么，我的`@Value`的使用则是：

![image-20240119143048673](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401191430761.png)

这么一看，有人就会问了，这么多的字段，难道都要在字段上加上`@Value`注解吗？

答案是否定的。

我们可以使用一个`@ConfigurationProperties`注解，该注解的作用是：常用于`bean`属性和`yml`配置文件的绑定。`prefix`属性可以指定配置文件中某一个节点，该节点中的子节点将自动和属性进行绑定，并且它是支持**松散绑定**的:

```xml
# application.yml
user:
	USERNAME: 徐哲
user: 
	userName: 徐哲
user:
	user_name: 徐哲
user:
	user-name: 徐哲
```

以上4种命名方式可以自动绑定`bean`属性，反过来说，如果`User`类属性username的名称是以上4种方式也是可以的。



此时我们就可以使用一个user前缀，spring容器会自动帮助我们进行属性注入：

![image-20240119143525850](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401191435922.png)

我们发现：此时我们并没有使用`@Value`注解，而是`@ConfigurationProperties`。

> **Note**
>
> `@AutoWired`注解是什么？
>
> 这个注解的功能是为我们注入一个定义好的bean；从所属范围来看，这个注解是属于Spring的容器配置的一个注解，与它同属容器配置的注解还有：`@Required`，`@Primary`，`@Qualifier`等等。因此`@Autowired`是一个用于容器配置的注解。
>
> 其次，我可以直接从字面意思来看，`autowire`单词的意思是自动装配，在Spring的世界中，自动装配指的就是使用将`Spring`容器中的`bean`自动的和我们需要这个`bean`的类组装在一起。
>
> `@Autowired`可应用于构造函数，`setter`方法，任意名称多个参数的方法，或应用于字段或将其与构造函数混用。
>
> 详情可参考：[https://www.w3cschool.cn/wkspring/rw2h1mmj.html](https://www.w3cschool.cn/wkspring/rw2h1mmj.html)

> **Note**
>
> `@ConfigurationProperties`注解是什么？
>
> 将大量的参数配置在 application.properties 或 application.yml 文件中，通过`@ConfigurationProperties` 注解，我们可以方便的获取这些参数值；常用于`bean`属性和`yml`配置文件的绑定。

> `@Value`获取值和`@ConfigurationProperties`获取值比较

|                      | @ConfigurationProperties |   @Value   |
| :------------------: | :----------------------: | :--------: |
|         绑定         | 批量注入配置文件中的属性 | 一个个指定 |
| 松散绑定（松散语法） |           支持           |  支持有限  |
|         SpEL         |          不支持          |    支持    |
|       自动提示       |           支持           |   不支持   |

配置文件`yml`还是`properties`他们都能获取到值。

**使用场景**

如果说，我们只是在某个业务逻辑中需要获取配置文件中的某项值，使用`@Value`；

如果说，我们专门编写了一个`javaBean`来和配置文件进行映射，我们就直接使用`@ConfigurationProperties`；

> **如何让类属性自动提示在yml文件中生效：**
>
> 子项目中：

```xml
<!--- 会生成META-INFO 元数据 用于提供idea自动提示配置文件的--->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-configuration-processor</artifactId>
    <!--- 依赖不会传播--->
    <optional>true</optional>
</dependency>
```

同时需要保证下面这个被选上：

![image-20240119163643337](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401191636841.png)

之后你在`yml`或`properties`文件输入类属性就可以自动提示了。

> **属性占位符**：@ConfigurationProperties是不支持SpeL表达式，但是支持属性占位符

![image-20240201193416901](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202402011934001.png)

格式如下所示：

```yaml
person:
  lastName: 李四
  age: 23
  boss: false
  maps: {k1: "v1", k2: "v2"}
  lists:
    - lisi
    - zhaoliu
  dog:
    name: ${person.lastName}的小狗
    age: 3
  birth: 2017/12/12
```

> @ConfigurationProperties也是可以支持随机值的${random.value}

![image-20240201194330640](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202402011943680.png)

如下测试：

```yaml
person:
  lastName: ${random.value}
  age: ${random.int(2)}
  boss: false
  maps: {k1: "v1", k2: "v2"}
  lists:
    - lisi
    - zhaoliu
  dog:
    name: ${person.lastName}的小狗
    age: 3
  birth: 2017/12/12
```

![image-20240201194419537](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202402011944575.png)

小结：@ConfigurationProperties仅支持这两种方式：属性占位符，随机数；@ConfigurationProperties不支持SPeL，但是@Value支持SpeL格式。

### 4.2 属性注入与数据校验

第一步、导入依赖：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-validation</artifactId>
</dependency>
```

我们可以通过这个链接：[https://docs.spring.io/spring-boot/docs/3.1.8/reference/html/using.html#using.build-systems.starters](https://docs.spring.io/spring-boot/docs/3.1.8/reference/html/using.html#using.build-systems.starters)，找到对应的**starter**。

第二步、在有`@ConfigurationProperties`的类上加入注解`@Validate`

![image-20240201201652717](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202402012016763.png)

```java
@Component
@ConfigurationProperties(prefix = "person")
@Validated
public class Person {
//    @Value("${person.lastName}")
    private String lastName;
    private Integer age;
    private Date birth;
    private Map<String, String> maps;
    private List<String> lists;
    private Dog dog;
    @NotNull
    private Boolean boss;

    public Boolean getBoss() {
        return boss;
    }
```

第三步、加入验证注解，比如@NotNull，@Email

**小结：**

- @ConfigurationProperties作用 常用于bean属性和yaml配置文件的绑定

- prefix 可以指定文件中的某一个节点，该节点中的子节点将自动和属性进行绑定

- @Value和@ConfigurationProperties都支持jsr-303数据校验:@Validate

  ```java
  package com.lqy.spring_initializr.bean;
  
  import jakarta.validation.constraints.Email;
  import jakarta.validation.constraints.NotNull;
  import org.springframework.beans.factory.annotation.Value;
  import org.springframework.boot.context.properties.ConfigurationProperties;
  import org.springframework.stereotype.Component;
  import org.springframework.validation.annotation.Validated;
  
  import java.util.Date;
  import java.util.List;
  import java.util.Map;
  
  @Component
  @ConfigurationProperties(prefix = "person")
  @Validated
  public class Person {
  //    @Value("${person.lastName}")
      @Email
      @Value("徐徐老师")
      private String lastName;
      private Integer age;
      private Date birth;
      private Map<String, String> maps;
      private List<String> lists;
      private Dog dog;
      private Boolean boss;
  
      public Boolean getBoss() {
          return boss;
      }
  
      public void setBoss(Boolean boss) {
          this.boss = boss;
      }
  
      @Override
      public String toString() {
          return "Person{" +
                  "lastName='" + lastName + '\'' +
                  ", age=" + age +
                  ", birth=" + birth +
                  ", maps=" + maps +
                  ", lists=" + lists +
                  ", dog=" + dog +
                  ", boss=" + boss +
                  '}';
      }
  
      public String getLastName() {
          return lastName;
      }
  
      public void setLastName(String lastName) {
          this.lastName = lastName;
      }
  
      public Integer getAge() {
          return age;
      }
  
      public void setAge(Integer age) {
          this.age = age;
      }
  
      public Date getBirth() {
          return birth;
      }
  
      public void setBirth(Date birth) {
          this.birth = birth;
      }
  
      public Map<String, String> getMaps() {
          return maps;
      }
  
      public void setMaps(Map<String, String> maps) {
          this.maps = maps;
      }
  
      public List<String> getLists() {
          return lists;
      }
  
      public void setLists(List<String> lists) {
          this.lists = lists;
      }
  
      public Dog getDog() {
          return dog;
      }
  
      public void setDog(Dog dog) {
          this.dog = dog;
      }
  }
  ```

  application.yml：

  ```yaml
  person:
  #  lastName: ${random.value}
    age: ${random.int[1,100]}
    maps: {k1: "v1", k2: "v2"}
    lists:
      - lisi
      - zhaoliu
    dog:
      name: ${person.lastName}的小狗
      age: 3
    birth: 2017/12/12
  ```

  运行下面的代码就会报错：

  ```java
  package com.lqy.spring_initializr;
  
  import com.lqy.spring_initializr.bean.Person;
  import org.junit.jupiter.api.Test;
  import org.springframework.beans.factory.annotation.Autowired;
  import org.springframework.boot.test.context.SpringBootTest;
  
  @SpringBootTest
  class SpringInitializrApplicationTests {
      @Autowired
      private Person person;
  
      @Test
      void contextLoads() {
          System.out.println(person);
          System.out.println(person.getDog().getName());
      }
  
  }
  ```

  ![image-20240201202751501](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202402012027541.png)



### 4.3 @PropertySource加载指定的配置文件

**注意：**这个注解只能加载后缀是`.properties`的文件

```properties
person.lastName= ${random.value}
person.age= ${random.int[1,100]}
person.maps.k1= "v1"
person.maps.k2= "v2"
person.lists= lisi, zhaoliu
person.dog.name= ${person.lastName}的小狗
person.dog.age= 3
person.birth= 2017/12/12
```

记住：**map格式**，或者 **对象的属性**的格式，都要写成键值对的格式；**列表或者数组**直接用逗号隔开就行。

注解的添加方式如下：

```java
@Component
@ConfigurationProperties(prefix = "person")
@Validated
@PropertySource("classpath:data/person.properties")
public class Person {
//    @Value("${person.lastName}")
//    @Email
//    @Value("徐徐老师")
    private String lastName;
    private Integer age;
    private Date birth;
    private Map<String, String> maps;
    private List<String> lists;
    private Dog dog;
    private Boolean boss;

    public Boolean getBoss() {
        return boss;
    }

    public void setBoss(Boolean boss) {
        this.boss = boss;
    }

    @Override
    public String toString() {
        return "Person{" +
                "lastName='" + lastName + '\'' +
                ", age=" + age +
                ", birth=" + birth +
                ", maps=" + maps +
                ", lists=" + lists +
                ", dog=" + dog +
                ", boss=" + boss +
                '}';
    }

    public String getLastName() {
        return lastName;
    }
```



**properties文件在idea中默认utf-8可能会乱码**

调整：

![image-20240201205057827](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202402012050876.png)



### 4.4 自动配置

链接地址：[https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties.server](https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties.server)

![image-20240201210412602](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202402012104658.png)

![image-20240201210450060](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202402012104118.png)

这种方式的自动配置，官方已经帮我们把默的配置写好，所以我们可以查表的方式来改变默认的配置；

但是我们更推荐下面这种利用上底层代码的自动配置方式。

**首先从启动类开始入手：@SpringBootApplication**

![image-20240201210735441](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202402012107484.png)

```java
@Target(ElementType.Type)  设置当前的注解可以标注在哪儿
@Retention(RetentionPolicy.RUNTIME) 当注解标注的类编译后以什么方式保留；会被jvm加载
@Documented java doc会生成注解信息
@Inherited 是否会被继承
```

```java
@SpringBootConfiguration：SpringBoot的配置类
    标注在某个类上，表示这是一个Spring Boot的配置类
@Configuration：配置类上标注这个注解
    配置类——配置文件：配置类也是容器中的一个组件；@Component
@EnableAutoConfiguration：开启自动配置功能
    以前我们需要配置的东西，SpringBoot帮我们自动配置；@EnableAutoConfiguration告诉SpringBoot开启自动配置功能；这样自动配置才能生效。
@ComponentScan：扫描包 相当于在spring xml配置中的<context:component-scan> 但是并没有指定basepackage；如果没有指定，spring底层会自动扫描当前配置类所在的包
```

`TypeExcludeFilter`：spring对外提供的扩展类，可以供我们去按照我们的方式进行排除。

`AutoConfigurationExcludeFilter`：排除所有配置类并且是自动配置类中的其中一个。

示例如下：继承`TypeExcludeFilter`重写`match`方法

```java
public class MyExcludeFilter extends TypeExcludeFilter {
    @Override
    public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException {
        if (metadataReader.getClassMetadata().getClass()== HelloController.class)
            return true; // 排除掉
        return false; // 不做排除
    }
}
```



这个注解里面，最主要的就是`@EnableAutoConfiguration`，它可以开启自动配置，进入`@EnableAutoConfiguration`的源码。

```java
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@AutoConfigurationPackage
@Import({AutoConfigurationImportSelector.class})
public @interface EnableAutoConfiguration {
```

`@AutoConfigurationPackage`：将当前配置类所在的包保存在BasePackages的Bean中，供`spring`内部使用。

`@AutoConfigurationPackage`

```java
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@Import({AutoConfigurationPackages.Registrar.class})// 保存扫描路径，提供给spring-data-jpa需要扫描的@Entity
public @interface AutoConfigurationPackage {
```

就是注册一个保存当前配置类所在包的一个Bean。

![springboot自动配置流程](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202402061940225.png)

[图片原文](https://www.processon.com/diagraming/65c2043e0f4b51315102909c)

`@Import(EnableAutoConfigurationImportSelector.class)`关键点！

可以看到，在@EnableAutoConfiguration注解内部使用到了`@Import`来完成导入配置的功能，而`EnableAutoConfigurationImportSelector`实现了`DefferedImportSelectorSpring`内部在解析`@Import`注解时会调用`getAutoConfigurationEntry`方法，下面是spring3.1实现源码：

```java
protected AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) {
        if (!this.isEnabled(annotationMetadata)) {
            return EMPTY_ENTRY;
        } else {
            AnnotationAttributes attributes = this.getAttributes(annotationMetadata);
            List<String> configurations = this.getCandidateConfigurations(annotationMetadata, attributes);
            configurations = this.removeDuplicates(configurations);
            Set<String> exclusions = this.getExclusions(annotationMetadata, attributes);
            this.checkExcludedClasses(configurations, exclusions);
            configurations.removeAll(exclusions);
            configurations = this.getConfigurationClassFilter().filter(configurations);
            this.fireAutoConfigurationImportEvents(configurations, exclusions);
            return new AutoConfigurationEntry(configurations, exclusions);
        }
    }
```

任何一个springboot应用，都会引入spring-boot-autoconfigure，而spring.factories文件就在该包下面。spring.factories文件是key=value形式，多个value时使用逗号隔开，该文件中定义了关于初始化，监听器等信息，而真正使用自动配置生效的key是org.springframework.boot.autoconfigure.EnableAutoConfiguration，如下所示：

等同于：

![image-20240206195711121](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202402061957165.png)

[所有自动配置类表](https://docs.spring.io/spring-boot/docs/current/reference/html/auto-configuration-classes.html#appendix.auto-configuration-classes)

每一个自动配置类进行自动配置功能。

`@EnableAutoConfiguration`注解通过`@SpringBootApplication`被间接标记在SpringBoot的启动类上。在`SpringApplication.run(...)`的内部就会执行selectImports()方法，找到所有JavaConfig自动配置类的全限定名对应的class，然后将所有自动配置类加载到spring容器中



**以HttpEncodingAutoConfiguration（Http编码自动配置）为例解释自动配置原理：**

```java
1
2 @Configuration(proxyBeanMethods = false)
3 @EnableConfigurationProperties(ServerProperties.class)
4 @ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)
5 @ConditionalOnClass(CharacterEncodingFilter.class)
6 @ConditionalOnProperty(prefix = "server.servlet.encoding", value = "enabled", matchIfMissing = true)
7 public class HttpEncodingAutoConfiguration {
8
9 private final Encoding properties;
10
11 public HttpEncodingAutoConfiguration(ServerProperties properties) {
12 		this.properties = properties.getServlet().getEncoding();
13 }
14
15 @Bean
16 @ConditionalOnMissingBean
17 public CharacterEncodingFilter characterEncodingFilter() {
18 		CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter();
19 		filter.setEncoding(this.properties.getCharset().name());
20 		filter.setForceRequestEncoding(this.properties.shouldForce(Encoding.Type.REQUEST));
21 		filter.setForceResponseEncoding(this.properties.shouldForce(Encoding.Type.RESPONSE));
22 return filter;
23 }
```

![image-20240207205649407](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202402072056539.png)

`@Configuration(proxyBeanMethods=false)`

标记了`@Configuration Spring`底层会给配置创建cglib动态代理。作用：就是防止每次调用本类的Bean方法而重新创建对象，Bean是默认单例的。

@EnableConfigurationProperties(ServerProperties.class)

启用可以在配置类设置的属性：对应的类

`@xxxConditional`根据当前不同的条件判断，决定这个配置类是否生效？



`@Conditional`派生注解（Spring注解版原生的@Conditional作用）

作用：必须是`@Conditional`指定的条件成立，才给容器中添加组件配置里面的内容才能生效；

| @Conditional扩展注解作用        | 判断是否满足当前指定条件                           |
| ------------------------------- | -------------------------------------------------- |
| @ConditionalOnJava              | 系统的java版本是否符合要求                         |
| @ConditionalOnBean              | 容器中存在指定的Bean                               |
| @ConditionalOnMissingBean       | 容器中不存在指定的Bean                             |
| @ConditionalOnExpression        | 满足SpEL表达式指定                                 |
| @ConditionalOnClass             | 系统中有指定的类                                   |
| @ConditionalOnMissingClass      | 系统中没有指定的类                                 |
| @ConditionalOnSingleCandidate   | 容器中只有一个指定的Bean，或者这个Bean是首选的Bean |
| @ConditionalOnProperty          | 系统中指定的属性是否有指定的值                     |
| @ConditionalOnResource          | 类路径下是否存在指定资源文件                       |
| @ConditionalOnWebApplication    | 当前是web环境                                      |
| @ConditionalOnNotWebApplication | 当前不是web环境                                    |
| @ConditionalOnJndi              | JNDI存在指定项                                     |

我们怎么知道哪些自动配置类生效？

我们可以通过设置配置文件中：启用 `debug=true`属性，来让控制台打印自动配置报告，这样我们就可以方便的知道哪些自动配置类生效。

![image-20240207210109638](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202402072101686.png)

![image-20240207210215607](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202402072102643.png)

![image-20240207210300246](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202402072103290.png)











