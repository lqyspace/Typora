# 简介及快速搭建

SpringBoot它基于Spring4.0设计，是由pivotal公司提供的框架

Spring发展史，Rod Johnson 2003 Interface Spring，2004开源《Spring Source》

2008收购Tomcat Apache Servlet，整个生态掌握在自己手中

2009 Spring VMware 4.6亿 VMware收购了Spring

先后收购RabbitMQ，redis

2013年，VMware，EMC，通用电气合力成立了Pivotal。

![image-20240118095653816](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401180957773.png)

![image-20240118095720971](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401180957024.png)

2014年4月发布Spring Boot1.0 基于Spring4.0

2018年3月Spring Boot2.0发布 基于Spring5.0

**SpringBoot基于Spring开发**，不仅继承了Spring框架原有的优秀特性，而且还通过简化配置来进一步简化了Spring应用的整个搭建和开发过程，**其设计目的是来简化Spring应用的初始搭建以及开发过程**，怎么简化的呢？就是通过提供默认我配置等方式让我们更容易使用。

SpringBoot本身并不提供Spring框架的核心特性以及扩展功能，也就是说，它并不是用来替代Spring的解决方案，而是和Spring框架紧密结合用于提升Spring开发者体验的工具。

关于SpringBoot有一句很出名的话就是**约定大于配置**。采用配置可以大大简化开发模式，它集成了大量常用的第三方库，所有你想集成的常用框架，它都有对应的组件支持，例如Redis，MongoDB，Dubbo，kafka，ES等等。

SpringBoot中这些第三方库几乎可以零配置地开箱即用，大部分的SpringBoot应用都只需要少量的配置代码，开发者能够更加专注业务罗逻辑。另外SpringBoot通过集成大量的框架使得依赖包的版本冲突，以及引用的不稳定性等问题得到了很好的解决。

> 简化Spring应用开发的一个框架
>
> 对整个企级开发技术栈的一个大整合build anything
>
> J2EE开发的一站式解决方案

**优点：**

- 快速搭建一个独立的Spring应用程序
- 嵌入的Tomcat，Jetty或者Undertow，无需部署WAR文件
- 提供starter POMs来简化Maven配置和简化版本冲突所带来的问题
- 对Spring和第三方库提供默认配置，也可以修改默认配置，简化框架配置
- 提供生产就绪功能，如指标，健康检查和外部配置
- 无需配置XML，无代码生成，开箱即用



# Why SpringBoot

上面说到SpringBoot简化了基于Spring开发。

也更得力于各微服务组件的支持（起初是Netflix移植到Spring），可以说是Spring Cloud带动了SpringBoot，SpringBoot成就了SpringCloud。

![image-20240118102209390](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401181022442.png)

SpringBoot和微服务的火热程度是同步的。

![image-20240118102559881](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401181025933.png)

# 微服务

2014年一个叫Martin Fowler（同时也是经典著作《重构：改善既有代码的设计》一书的作者）发表了一篇关于微服务的博客，比较生动形象的介绍了什么是微服务，然后微服务才慢慢被人们所熟知。

![image-20240118103105540](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401181031604.png)

他说微服务其实是一中架构风格，我们在开发一个应用的时候应该是由一组小型服务组成，每个小型服务运行在自己的进程内，小服务之间通过HTTP的方式进行互联互通。

和微服务相对应的就是我们之前的，单体应用，就是大名鼎鼎的 `all in one` 的风格。这种风格把所有的东西都写在一个应用里面，比如我们熟悉的`OA`,`CRM`,`ERP`系统，所有的页面，所有的代码都放在一起，打成一个war，然后把war包放在Tomcat容器中运行。

这种传统的web开发的架构模式淡然也有它的优势，因为不涉及到多个服务的互联互调，只需要把一个包上传到服务器就行，可以说是一人吃饱全家不饿。同样也不会给运维带来麻烦，方便水平扩展，只需要把相同的应用复制多份放到不同的服务器中就达到了扩展的目的。

单体应用的缺点也是显而易见，容易牵一发而动全身，比如要更改一个小小功能，就可能需要更改整个应用。当然，更大的挑战就是日益增长的用户需求。

![image-20240118103841165](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401181038239.png)



# 快速开始

**第一步：创建maven项目**

![image-20240118125246659](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401181252732.png)



**第二步、POM导入parent**

导入以下的内容到POM文件中，这样才能父你的项目标记为SpringBoot项目，这样你才能继承父项目的所有依赖。

```xml
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>2.7.18</version>
</parent>
```

此时我们可以在项目根目录下输入 `mvn dependency:tree`，此命令可以打印项目的依赖项，我们可以发现`spring-boot-starter-parent`本身并不提供任何依赖项。我们为了进行web开发，可以添加下面的依赖项：

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
</dependencies>
```

此时我们如果再使用`mvn dependency:tree`，我们就可以发现大量的额外依赖项，包括Tomcat web server 和SpringBoot本身。

![image-20240118132914486](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401181329541.png)



**第三步、快速创建helloworld**

![image-20240118133052785](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401181330842.png)

> 创建Controller

从上图我可以看出，我在`org.lqy.springboot.controller`的文件中创建了一个`HelloController`类，类中使用了注解`@RestController`，该注解相当于`@Controller + @ResponseBody`。

`@Controller`将当前修饰的类注入到`SpringBoot IOC`容器中，使得从该类所在的项目跑起来的过程中，这个类就被实例化。当然也有语义化的作用，即代表该类是充当`Controller`的作用。

`@ResponseBody`它的作用简短来说就是指该类中所有`API`接口返回的数据，甭管你对应的方法返回的是`MAP`还是其他的`Object`，它会以`Json`字符串的形式返回给客服端，如果返回的是`String`类型，则仍然是`String`类型。

在使用`springmvc`框架的时候，在处理`json`的时候需要使用到`spring`框架特有的注解`@ResponseBody`或者`@RestController`注解，==这两个注解都会处理返回的数据格式，使用了该类型的注解返回的不再是视图，不会进行跳转，而是返回json或xml数据格式，输出在页面上。==

这两个注解的使用区别如下：

- `@ResponseBody`一般使用在单独的方法上，需要哪个方法返回json数据格式，就在哪个方法上使用，具有针对性。
- `@RestController`，一般使用在类上，它表示的意识是结合了`@Controller`和`@ResponseBody`两个注解，如果哪个类的所有方法需要返回json格式的数据，就在哪个类上使用该注解，具有统一性；需要注意的是，使用了该注解，相当于该类中的所有方法都是用`@ResponseBody`注解，输出在页面上，而不会返回视图。

> 创建启动类

我在`org.lqy.springboot`文件中创建了一个启动类`Application`

![image-20240118134742069](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401181347132.png)

首先在类上添加`@SpringBootApplication`注解，表明该类是`启动类`。

然后在主方法`main`中调用`SpringApplication`的`run`方法，里面传入两个参数：`Application.class`和`args`

最后运行主方法，即可看到如下界面：

![image-20240118135054796](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401181350862.png)

如果看到如下提示，则说明其启动成功：

![image-20240118135131671](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401181351730.png)

最后运行localhost:8080/hello/world即可以看到如下界面：

![image-20240118135221619](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401181352670.png)

# 打包jar

如果我们想把一个服务打包成可以独立运行的`jar`，我们首先需要在`pom`文件中添加如下依赖：

```xml
<build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
        </plugin>
    </plugins>
</build>
```

注意：如果不添加的话，在运行jar包时会提示缺少classpath。

然后我们双击maven里面的`package`或者在项目根目录下输入`mvn package`：

![image-20240118140932161](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401181409234.png)

最后我们就可以在`target`目录中看到`jar`文件：

![image-20240118141032291](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401181410377.png)

运行`jar`：`java -jar xxx.jar`

![image-20240118141153680](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401181411743.png)

由上图所示，我们运行成功。



# 改端口号

我们需要在`resources`文件夹中添加一个配置文件`application.properties`（一定要是这个名字，**约定大于配置**）

添加如下内容：

```properties
server.port=8080
server.servlet.context-path= /tuling
```

注意：第二行表示给URL加一个项目名，所以新的URL就是：localhost:8080/tuling/hello/world



# 代码说明

## 文件说明

![image-20240118142640911](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401181426030.png)

> **@SpringBootApplication**

`SpringBoot`的启动类（入口），我们追踪一下该注解，发现该注解是一个配置类`@Configuration`：

![image-20240118143426143](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401181434187.png)

![image-20240118143520274](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401181435329.png)

![image-20240118143542904](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401181435985.png)

我们发现还有`@ComponentScan`这个注解，这个注解就相当于以前配置文件里面的：

```xml
<context:component-scan basePackages="org.lqy.springboot"></context:component-scan>
```

`Spring`底层在解析配置类，会去解析`@ComponentScan`，读取`basePackages`这个属性，如果读到了肯定以里面设置的值为扫描的包路径；如果没有读取到，会将当前配置类所在的包当做扫描包。如下图所示：

![image-20240118145401461](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401181454568.png)

当前类所在的包为：`org.lqy.springboot`

下面的源码是`ComponentScanAnnotationParse.java`：

![image-20240118145733318](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401181457392.png)

如果`basePackages`为空，则会获取当前类的类路径：`org.lqy.springboot.Application`，然后通过`ClassUtils.getPackageName()`方法获取包名：`org.lqy.springboot`，然后就会将`org.lqy.springboot`设置成`basePackages`。



> **实例：假设我们把启动类移动到org.lqy.springboot.application包下**

再次启动SpringBoot时肯定是可以启动成功，但是我们在做请求时就会报404错误：

![image-20240118150420482](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401181504537.png)

![image-20240118150406190](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401181504243.png)

但是此时如果我们`激活`启动类中`@ComponentScan`注解，然后配置正确的包路径，那么就可以正常访问：

![image-20240118150608497](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401181506556.png)

![image-20240118150624202](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401181506243.png)

**小结：最好将Application放在需要放到需要扫描包的根目录下面，或者放在所有Bean的顶层目录下面。**



> **约定大于配置**

配置文件一定要按照要求命名。

![image-20240118150915190](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401181509260.png)

> **POM文件**

```xml
<!--    有了这个parent，才能标记此项目为springboot项目，或者 引入了父Maven项目，继承了父Maven项目所有的配置信息-->
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.7.18</version>
    </parent>
```

在`spring-boot-starter-parent`父项目中又引入了`spring-boot-dependencies`：

```xml
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-dependencies</artifactId>
    <version>2.7.18</version>
</parent>
```

这个 `spring-boot-dependencies` 帮我们管理了SpringBoot应用中所有的依赖的版本，以后我们导入已有的依赖就不需要写版本号了，它帮助我们解决了第三方库之间的版本冲突问题——**SpringBoot的版本冲裁中心**

**注意：**

- starter 场景启动器
  - spring-boot-starter-web：使用Spring MVC构建Web（包括Restful）应用程序，使用Tomcat座位默认的嵌入式容器
- 不同的场景启动器维护了所对应的所有依赖，从而简化了maven的文件书写



我们可以右键`pom.xml`文件的空白部分，然后点击`Diagram——>Show Diagram`，即可看到如下的可视化视图：

![image-20240118152111098](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202401181521324.png)