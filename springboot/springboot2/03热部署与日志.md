# 热部署与日志

## springboot中devtools热部署

### 引言

> 为了进一步提高开发效率，springboot为我们提供了全局项目热部署，日后修改部分代码以及相关配置后，不需要每次重启修改即可生效，在项目中开启了springboot全局热部署后只需要在修改以后等待几秒即可生效。

### 开启热部署

> **引入项目依赖**

```xml
<dependency>
   <groupId>org.springframework.boot</groupId>
   <artifactId>spring-boot-devtools</artifactId>
   <optional>true</optional>
</dependency>
```

> **IDEA中配置**

当我们修改了类文件以后，idea不会自动编译，得修改idea设置

- File-Settings-Compiler-Build Project automatically
- ctrl+shift+alt+/，选择**Register**，勾上Compiler autoMake allow when app running

> 启动项目检测热部署是否生效

启动出现如下日志代表生效：

![image-20240208205604890](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202402082056918.png)

**注意：**日志出现`restartedMain`代表已经生效，在使用热部署时如果碰到修改之后不能生效，请重启项目再试。



## Java日志体系

![image-20240208223720608](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202402082237640.png)

![image-20240208223748255](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202402082237296.png)

推荐使用`logback`和`SJF4J`。因为它两是同一个作者写的。

![image-20240208223834765](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202402082238790.png)

具体实例如下：

**JUL：**

```java
import java.util.logging.Logger;

/*
* 崇尚官方开发组
* */
public class JulMain {
    public static void main(String[] args) {
        Logger logger = Logger.getLogger(JulMain.class.getName());
        logger.info("崇尚官方开发组：Jul");
    }
}
```

输出：![image-20240210160918666](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202402101609692.png)

**Log4J：**

```java
import org.apache.log4j.Logger;

/*
* 崇尚开源开发组
* */
public class Log4jMain {
    public static void main(String[] args) {
        Logger logger = Logger.getLogger(Log4jMain.class);
        logger.info("崇尚开源开发组：log4j");
    }
}
```

需要在resources文件夹下配置一个log4j.properties配置文件：

```properties
#trace<debug<info<warn<error<fatal
log4j.rootLogger=trace, stdout
log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=%d %p [%c] - %m%n
```

添加依赖：

```xml
<dependency>
    <groupId>log4j</groupId>
    <artifactId>log4j</artifactId>
    <version>1.2.12</version>
</dependency>
```

然后运行即可看见结果：

![image-20240210161156297](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202402101611318.png)

![image-20240208223953906](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202402082239945.png)

![image-20240208224127550](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202402082241582.png)

slf4j跟jcl机制不一样，它就相当于是一个游戏机，本身没有游戏，只提供一个运行游戏的平台（门面），要运行哪一个游戏我不管，你给我放哪块光盘我就运行哪个游戏；而JCL是自己去找，先找到哪个运行哪个。

**slf4j与其他各种日志组件的桥接器说明：**

| jar包名                                                      | 说明                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| slf4j-log4j12-1.7.13.jar                                     | Log4j1.2版本的桥接器，你需要将Log4j.jar加入Classpath。       |
| log4j-slf4j-impl.jar                                         | Log4j2版本的桥接器，还需要log4j­-api.jar  log4j­-core.jar    |
| slf4j-jdk14-1.7.13.jar                                       | java.util.logging的桥接器，Jdk原生日志框架。                 |
| slf4j-nop-1.7.13.jar                                         | NOP桥接器，默默丢弃一切日志。                                |
| slf4j-simple-1.7.13.jar                                      | 一个简单实现的桥接器，该实现输出所有事件到System.err. 只有Info以及高于该级别的消息被打印，在小 型应用中它也许是有用的。 |
| slf4j-jcl-1.7.13.jar                                         | Jakarta Commons Logging 的桥接器. 这个桥接器将Slf4j所有日志委派给Jcl。 |
| logback-classic-1.0.13.jar(requires logback-core-1.0.13.jar) | Slf4j的原生实现，Logback直接实现了Slf4j的接口，因此使用Slf4j与Logback的结合使用也意味更小的内存与计算开销 |

如上图所示，应用调用了slf4j-api，即日志门面接口。日志门面接口本身通常并没有实际的日志输出能力，它底层还是需要去调用具体的日志框架API的，也就是实际上它需要跟具体的日志框架结合使用。由于具体日志框架比较多，而且互相也大都不兼容，日志门面接口要想实现与任意日志框架结合可能需要具体的桥接器，上图中的红框即是对应的桥接器！

我们在代码中需要写日志，变成下面这么写：

```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
// Log4j实现 + slf4j（门面）  必须加上桥接器
public class Slf4JMain {
    public static void main(String[] args) {
        Logger logger = LoggerFactory.getLogger(Slf4JMain.class);
        logger.info("info");
    }
}
```

输出：![image-20240210163002397](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202402101630421.png)

注意引入依赖：

```xml
<!--        slf4j的核心框架-->
        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-api</artifactId>
        </dependency>
<!--        添加slf4j —— log4j的桥接器-->
        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>log4j-over-slf4j</artifactId>
        </dependency>
```

为了日志统一实现，将JCL转化到SLF4J，添加JCL-SLF4J的适配器。

```xml
<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>log4j-over-slf4j</artifactId>
</dependency>
```

**因此，在阿里的开发手册中有这么一条：**

==强制：应用中不可直接使用日志系统（log4j，logback）中的API，而应依赖使用日志框架SLF4J中的API。使用门面模式的日志框架，有利于维护和各个类的日志处理方式的统一。==



## logback日志集成

![image-20240210195551024](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202402101955088.png)

![image-20240210200133131](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202402102001174.png)

总结：

- springBoot底层也是使用slf4j+logback的方式进行日志记录
  - logback桥接：logback-classic
- SpringBoot也把其他的日志替换成了slf4j
  - log4j适配：log4j-over-slf4j
  - jul适配：jul-to-slf4j
  - 这两个适配器都是为了适配Spring的默认日志：jcl-over-slf4j

### SpringBoot日志使用

> **日志使用**

可以设置Trace、Debug、Info、Warn、Error、Fatal或Off之一。

![image-20240210200905764](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202402102009793.png)

![image-20240210202246047](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202402102022073.png)

> **日志格式**

![image-20240210203703154](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202402102037187.png)

详细介绍：

- 时间和日期：毫秒精度，易于排序

  - %clr(%d{${LOG_DATEFORMAT_PATTERN:-yyyy-MM-dd'T'HH:mm:ss.SSSXXX}}){faint}

    - %clr 当前内容的颜色 {faint}，faint表示没有颜色，[颜色设置](https://docs.spring.io/spring-boot/docs/3.1.8/reference/html/features.html#features.logging.console-output)

    - 括号中就是要显示的内容：(%d{${LOG_DATEFORMAT_PATTERN:-yyyy-MM-dd'T'HH:mm:ss.SSSXXX}})

    - **%d{${LOG_DATEFORMAT_PATTERN:-yyyy-MM-dd'T'HH:mm:ss.SSSXXX}}**

      - **${LOG_DATEFORMAT_PATTERN:-yyyy-MM-dd'T'HH:mm:ss.SSSXXX}**

      - ${value: value2} springboot的占位符 + null条件表达式（如果value为null则使用value2）

      - **LOG_DATEFORMAT_PATTERN**：系统环境变量中的值，springboot底层会根据对应的配置项将值设置到对应的环境变量中

      - 如：LOG_DATEFORMAT_PATTERN=logging.pattern.dateformat 可以在官网中[4.8章节](https://docs.spring.io/spring-boot/docs/3.1.8/reference/html/features.html#features.logging.file-output)查看

        ![image-20240210210708038](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202402102107114.png)

  - %d{-yyyy-MM-dd HH:mm:ss.SSS}

    - %d logback的日期显示方式

    - {-yyyy-MM-dd HH:mm:ss.SSS} 日期的格式

      ![image-20240210211133533](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202402102111611.png)

- 日志级别：error，warn，info，debug，or trace

  - %clr(${LOG_LEVEL_PATTERN:-%5p})
    - %5 代表当前内容所占字符长度
    - p 输出日志事件的级别（p/le/level）
  - %clr颜色 会根据不同的日志级别输出对应的颜色

- 进程ID

  - %clr(${PID:- }){magenta}
  - ${PID:- } springboot的占位符 + null条件的表达式（如果value为null 使用value2)
  - PID是系统环境变量中的进程ID（由系统分配）

- 一个 `---`分离器来区分实际日志消息的开始

- 线程名称：用方括号括起来（对于控制台输出可能会被截断）

- 记录器名称：这通常是源类名称（通常缩写）

- 日志消息

可以使用`logging.pattern.console`修改默认的控制台的日志格式：

```shell
%clr(%d{${LOG_DATEFORMAT_PATTERN:-yyyy-MM-dd'T'HH:mm:ss.SSSXXX}}){faint} %clr(${LOG_LEVEL_PATTERN:-%5p}) %clr(${PID:- }){magenta} %clr(---){faint} %clr([%15.15t]){faint} %clr(%-40.40logger{39}){cyan} %clr(:){faint} %m%n${LOG_EXCEPTION_CONVERSION_WORD:-%wEx}
```

注意：在yml中比如%，$需要转义的符号可以使用**单引号**括起来。



> **日志以文件的格式输出**

默认情况下，SpringBoot仅记录到控制台，不写日志文件。如果除了控制同输出外还想写日志文件，则需要设置一个`logging.file.name`或`logging.file.path`属性（例如，在中application.properties）。

| logging.file.name | logging.file.path | 实例     | 描述                     |
| ----------------- | ----------------- | -------- | ------------------------ |
| 无                | 无                |          | 仅控制台记录             |
| 指定文件名        | 无                | my.log   | 写入指定的日志文件       |
| 无                | 具体目录          | /var/log | 写入spring.log指定的目录 |

- logging.file.name
  - 可以设置文件的名称，如果没有设置路径会默认在项目的相对目录下（项目根目录下）
  - 还可以指定路径+文件名：![image-20240210213314430](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202402102133452.png)

- logging.file.path
  - 不可以指定文件名称，必须要指定一个物理文件夹路径，会默认使用spring.log作为日志的名称
  - 会在项目根目录下创建一个spring.log的日志文件：![image-20240210213742753](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202402102137782.png)



> **日志迭代（轮转）**

如果您使用的是Logback，则可以使用application.properties或application.yml文件微调日志轮播设置。对于所有其他的日志记录系统，您需要直接自己配置轮转设置（例如：如果使用Log4J2，则可以使用log4j.xml文件）

| 名称                                                 | 描述                                 |
| ---------------------------------------------------- | ------------------------------------ |
| logging.logback.rollingpolicy.file­name­pattern      | 归档的文件名                         |
| logging.logback.rollingpolicy.clean­history­on­start | 是否在应用程序启动时进行日志归档清理 |
| logging.logback.rollingpolicy.max­file­size          | 归档前日志文件的最大大小             |
| logging.logback.rollingpolicy.total­size­cap         | 删除日志档案之前可以使用的最大大小   |
| logging.logback.rollingpolicy.max­history            | 保留日志存档的天数（默认为7）        |

- logging.logback.rollingpolicy.file­name­pattern
  - ${LOG_FILE}.%d{yyyy-MM-dd}.%i.gz
    - ${LOG_FILE} 对应 logging.file.name
    - %d{yyyy-MM-dd} 日期 年-月-日
    - %i 索引，当文件超出指定大小后进行的文件索引递增

![image-20240210215859987](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202402102159044.png)



> **自定义日志配置文件**

可以通过在类路径中包含日志配置文件来激活各种日志记录系统或使用logging.config

| Logging System         | Customization                                                |
| ---------------------- | ------------------------------------------------------------ |
| Logback                | logback-spring.xml，logback-spring.groovy，logback.xml，logback.groovy |
| Log4j2                 | log4j2-spring.xml，log4j2.xml                                |
| JDK(Java Util Logging) | logging.properties                                           |

[Logback中文网](https://www.docs4dev.com/docs/zh/logback/1.3.0-alpha4/reference/appenders.html)

**注意：**

- 如果使用自定义日志配置文件，会使springBoot中全局配置文件的logging相关配置失效

- 结合SpringBoot提供Profile来控制日志的生效

  - **注意：**一定要将日志配置文件的文件名改成`logback-spring.xml`，因为`logback.xml`会在springboot容器加载前先被`logback`给加载到，那么由于logback无法解析spring profile将会报错。

    ![image-20240211003753987](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202402110037015.png)

具体内容如下：logback-spring.xml：

```xml
<configuration>
    <!--appender 追加器   日志以哪种方式进行输出
            name 取个名字
            class 不同实现类会输出到不同地方
                ch.qos.logback.core.ConsoleAppender 输出到控制台
    -->
    <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <!-- 格式 -->
            <springProfile name="dev">
                <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{100} ======== %msg%n</pattern>
            </springProfile>
            <springProfile name="!dev">
                <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{100} ++++++++ %msg%n</pattern>
            </springProfile>


        </encoder>
    </appender>
<!--cn.tulingxueyuan.mapper-->
<!--控制跟细粒度的日志级别  根据包\根据类-->
    <logger name="com.spring.logging" level="TRACE"></logger>
    org.apache.ibatis.transaction
    <!--控制所有的日志级别-->
    <root level="error">
        <!-- 将当前日志级别输出到哪个追加器上面 -->
        <appender-ref ref="STDOUT" />
    </root>
</configuration>
```

更高级的用法：

```xml
<configuration>
    <!--appender 追加器   日志以哪种方式进行输出
            name 取个名字
            class 不同实现类会输出到不同地方
                ch.qos.logback.core.ConsoleAppender 输出到控制台
    -->
    <!--可以引用SpringBoot全局配置文件中的配置项-->
    <springProperty scope="context" name="dateformat" source="logging.pattern.dateformat" defaultValue="-yyyy-MM-dd HH:mm:ss.SSS"/>
    <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <!-- 格式 -->
            <springProfile name="dev">
                <pattern>%d{${dateformat}} [%thread] %-5level %logger{100} ======== %msg%n</pattern>
            </springProfile>
            <springProfile name="!dev">
                <pattern>%d{${dateformat}} [%thread] %-5level %logger{100} ++++++++ %msg%n</pattern>
            </springProfile>


        </encoder>
    </appender>
<!--cn.tulingxueyuan.mapper-->
<!--控制跟细粒度的日志级别  根据包\根据类-->
    <logger name="com.spring.logging" level="TRACE"></logger>
    org.apache.ibatis.transaction
    <!--控制所有的日志级别-->
    <root level="error">
        <!-- 将当前日志级别输出到哪个追加器上面 -->
        <appender-ref ref="STDOUT" />
    </root>
</configuration>
```

参考教程：[4.9.2 Environment Properties](https://docs.spring.io/spring-boot/docs/3.1.8/reference/html/features.html#features.logging.logback-extensions)

### 切换日志框架

- 将logback切换成log4j2
  - 将logback的场景启动器排除（slf4j只能运行一个桥接器）
  - 添加log4j2的场景启动器
  - 添加log4j2的配置文件

```xml
<dependency>
    <!‐‐starter‐web里面自动添加starter‐logging 也就是logback的依赖‐‐>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
    <exclusions>
        <!‐‐排除starter‐logging 也就是logback的依赖‐‐>
        <exclusion>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-logging</artifactId>
        </exclusion>
    </exclusions>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-log4j2</artifactId>
</dependency>
```

- 将logback切换成log4j

  要将logback的桥接器排除

  ![image-20240215140659291](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202402151406335.png)

  添加log4j的桥接器

  ![image-20240215140729578](https://fastly.jsdelivr.net/gh/lqyspace/mypic@master/img1/202402151407603.png)

  添加log4j的配置文件

  ```xml
  #trace<debug<info<warn<error<fatal
  log4j.rootLogger=trace, stdout
  log4j.appender.stdout=org.apache.log4j.ConsoleAppender
  log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
  log4j.appender.stdout.layout.ConversionPattern=%d %p [%c] ‐ %m%n
  ```

  
